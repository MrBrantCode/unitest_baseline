{
  "task_id": "cf_63201",
  "entry_point": "minPathWithBlockedCells",
  "mutant_count": 93,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "minPath = ''",
      "mutated_line": "minPath = 'MUTATED'",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = 'MUTATED'\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "blocked = [[False]*n for _ in range(n)]",
      "mutated_line": "blocked = [[False] / n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] / n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "blocked = [[False]*n for _ in range(n)]",
      "mutated_line": "blocked = [[False] + n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] + n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "blocked = [[False]*n for _ in range(n)]",
      "mutated_line": "blocked = [[False] ** n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] ** n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "blocked[x][y] = True",
      "mutated_line": "blocked[x][y] = False",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = False\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dp = [[float('inf')]*n for _ in range(n)]  # Initialize with largest possible value",
      "mutated_line": "path = [[''] * n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] / n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dp = [[float('inf')]*n for _ in range(n)]  # Initialize with largest possible value",
      "mutated_line": "path = [[''] * n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] + n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dp = [[float('inf')]*n for _ in range(n)]  # Initialize with largest possible value",
      "mutated_line": "path = [[''] * n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] ** n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "path = [['']*n for _ in range(n)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] / n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "path = [['']*n for _ in range(n)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] + n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "path = [['']*n for _ in range(n)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] ** n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k != 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if dp[x][y] != float('inf'):",
      "mutated_line": "if dp[x][y] == float('inf'):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] == float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "minVal = float('inf')",
      "mutated_line": "minVal = float('')",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 1:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == -1:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 1:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 0 <= nx < n or 0 <= ny < n or (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n or 0 <= ny < n or (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "blocked = [[False]*n for _ in range(n)]",
      "mutated_line": "blocked = [[True] * n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[True] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "path = [['']*n for _ in range(n)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [['MUTATED'] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, left, down, up",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dp[x][y] != float('inf'):",
      "mutated_line": "if dp[x][y] != float(''):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float(''):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 0 < nx < n and 0 <= ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 0 > nx < n and 0 <= ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 0 == nx < n and 0 <= ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 0 <= nx < n and 0 < ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 < ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 0 <= nx < n and 0 > ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 > ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 0 <= nx < n and 0 == ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 == ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "val = dfs(nx, ny, k - 1) + grid[x][y]",
      "mutated_line": "val = dfs(nx, ny, k - 1) - grid[x][y]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) - grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "val = dfs(nx, ny, k - 1) + grid[x][y]",
      "mutated_line": "val = dfs(nx, ny, k - 1) * grid[x][y]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) * grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if val < dp[x][y]:",
      "mutated_line": "if val <= dp[x][y]:",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val <= dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if val < dp[x][y]:",
      "mutated_line": "if val >= dp[x][y]:",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val >= dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if val < dp[x][y]:",
      "mutated_line": "if val != dp[x][y]:",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val != dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if dp[i][j] < minVal:",
      "mutated_line": "if dp[i][j] <= minVal:",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] <= minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if dp[i][j] < minVal:",
      "mutated_line": "if dp[i][j] >= minVal:",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] >= minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if dp[i][j] < minVal:",
      "mutated_line": "if dp[i][j] != minVal:",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] != minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[float('inf')]*n for _ in range(n)]  # Initialize with largest possible value",
      "mutated_line": "path = [[''] * n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 1 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if -1 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 1 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 0 <= nx < n and 1 <= ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 1 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 0 <= nx < n and -1 <= ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and -1 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not blocked[nx][ny]:",
      "mutated_line": "if 0 <= nx < n and 1 <= ny < n and (not blocked[nx][ny]):",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 1 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]",
      "mutated_line": "path[x][y] = str(grid[x][y]) + ' ' - path[nx][ny]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' - path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]",
      "mutated_line": "path[x][y] = (str(grid[x][y]) + ' ') * path[nx][ny]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = (str(grid[x][y]) + ' ') * path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dfs(i, j, k - 1)",
      "mutated_line": "dfs(i, j, k + 1)",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k + 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dfs(i, j, k - 1)",
      "mutated_line": "dfs(i, j, k * 1)",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k * 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "val = dfs(nx, ny, k - 1) + grid[x][y]",
      "mutated_line": "val = dfs(nx, ny, k + 1) + grid[x][y]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k + 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "val = dfs(nx, ny, k - 1) + grid[x][y]",
      "mutated_line": "val = dfs(nx, ny, k * 1) + grid[x][y]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k * 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]",
      "mutated_line": "path[x][y] = str(grid[x][y]) - ' ' + path[nx][ny]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) - ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]",
      "mutated_line": "path[x][y] = str(grid[x][y]) * ' ' + path[nx][ny]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) * ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dfs(i, j, k - 1)",
      "mutated_line": "dfs(i, j, k - 2)",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 2)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dfs(i, j, k - 1)",
      "mutated_line": "dfs(i, j, k - 0)",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 0)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dfs(i, j, k - 1)",
      "mutated_line": "dfs(i, j, k - 0)",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 0)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dfs(i, j, k - 1)",
      "mutated_line": "dfs(i, j, k - -1)",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - -1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "val = dfs(nx, ny, k - 1) + grid[x][y]",
      "mutated_line": "val = dfs(nx, ny, k - 2) + grid[x][y]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 2) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "val = dfs(nx, ny, k - 1) + grid[x][y]",
      "mutated_line": "val = dfs(nx, ny, k - 0) + grid[x][y]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 0) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "val = dfs(nx, ny, k - 1) + grid[x][y]",
      "mutated_line": "val = dfs(nx, ny, k - 0) + grid[x][y]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 0) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "val = dfs(nx, ny, k - 1) + grid[x][y]",
      "mutated_line": "val = dfs(nx, ny, k - -1) + grid[x][y]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - -1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "path[x][y] = str(grid[x][y]) + ' ' + path[nx][ny]",
      "mutated_line": "path[x][y] = str(grid[x][y]) + '' + path[nx][ny]",
      "code": "from typing import List, Tuple\n\ndef minPathWithBlockedCells(grid: List[List[int]], k: int, blockedCells: List[Tuple[int, int]]) -> List[int]:\n    n = len(grid)\n    blocked = [[False] * n for _ in range(n)]\n    for (x, y) in blockedCells:\n        blocked[x][y] = True\n    dp = [[float('inf')] * n for _ in range(n)]\n    path = [[''] * n for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            path[x][y] = str(grid[x][y])\n            return grid[x][y]\n        if dp[x][y] != float('inf'):\n            return dp[x][y]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not blocked[nx][ny]):\n                val = dfs(nx, ny, k - 1) + grid[x][y]\n                if val < dp[x][y]:\n                    dp[x][y] = val\n                    path[x][y] = str(grid[x][y]) + '' + path[nx][ny]\n        return dp[x][y]\n    minVal = float('inf')\n    minPath = ''\n    for i in range(n):\n        for j in range(n):\n            if not blocked[i][j]:\n                dfs(i, j, k - 1)\n                if dp[i][j] < minVal:\n                    minVal = dp[i][j]\n                    minPath = path[i][j]\n    return list(map(int, minPath.split()))"
    }
  ]
}