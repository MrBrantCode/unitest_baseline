{
  "task_id": "cf_48842",
  "entry_point": "rolling_max_min",
  "mutant_count": 34,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if (current_max, current_min) != rolling_min_max[-1]:",
      "mutated_line": "if (current_max, current_min) == rolling_min_max[-1]:",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) == rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for num in numbers[1:]:",
      "mutated_line": "for num in numbers[2:]:",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[2:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for num in numbers[1:]:",
      "mutated_line": "for num in numbers[0:]:",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[0:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for num in numbers[1:]:",
      "mutated_line": "for num in numbers[0:]:",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[0:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for num in numbers[1:]:",
      "mutated_line": "for num in numbers[-1:]:",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[-1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rolling_min_max = [(numbers[0], numbers[0])]",
      "mutated_line": "rolling_min_max = [(numbers[1], numbers[0])]",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[1], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rolling_min_max = [(numbers[0], numbers[0])]",
      "mutated_line": "rolling_min_max = [(numbers[-1], numbers[0])]",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[-1], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rolling_min_max = [(numbers[0], numbers[0])]",
      "mutated_line": "rolling_min_max = [(numbers[1], numbers[0])]",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[1], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rolling_min_max = [(numbers[0], numbers[0])]",
      "mutated_line": "rolling_min_max = [(numbers[0], numbers[1])]",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[1])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rolling_min_max = [(numbers[0], numbers[0])]",
      "mutated_line": "rolling_min_max = [(numbers[0], numbers[-1])]",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[-1])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rolling_min_max = [(numbers[0], numbers[0])]",
      "mutated_line": "rolling_min_max = [(numbers[0], numbers[1])]",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[1])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_max = max(num, rolling_min_max[-1][0])",
      "mutated_line": "current_max = max(num, rolling_min_max[-1][1])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][1])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_max = max(num, rolling_min_max[-1][0])",
      "mutated_line": "current_max = max(num, rolling_min_max[-1][-1])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][-1])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_max = max(num, rolling_min_max[-1][0])",
      "mutated_line": "current_max = max(num, rolling_min_max[-1][1])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][1])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_min = min(num, rolling_min_max[-1][1])",
      "mutated_line": "current_min = min(num, rolling_min_max[-1][2])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][2])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_min = min(num, rolling_min_max[-1][1])",
      "mutated_line": "current_min = min(num, rolling_min_max[-1][0])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][0])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_min = min(num, rolling_min_max[-1][1])",
      "mutated_line": "current_min = min(num, rolling_min_max[-1][0])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][0])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_min = min(num, rolling_min_max[-1][1])",
      "mutated_line": "current_min = min(num, rolling_min_max[-1][-1])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][-1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if (current_max, current_min) != rolling_min_max[-1]:",
      "mutated_line": "if (current_max, current_min) != rolling_min_max[+1]:",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[+1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "current_max = max(num, rolling_min_max[-1][0])",
      "mutated_line": "current_max = max(num, rolling_min_max[+1][0])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[+1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "current_min = min(num, rolling_min_max[-1][1])",
      "mutated_line": "current_min = min(num, rolling_min_max[+1][1])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[+1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (current_max, current_min) != rolling_min_max[-1]:",
      "mutated_line": "if (current_max, current_min) != rolling_min_max[-2]:",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-2]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (current_max, current_min) != rolling_min_max[-1]:",
      "mutated_line": "if (current_max, current_min) != rolling_min_max[-0]:",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-0]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (current_max, current_min) != rolling_min_max[-1]:",
      "mutated_line": "if (current_max, current_min) != rolling_min_max[-0]:",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-0]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (current_max, current_min) != rolling_min_max[-1]:",
      "mutated_line": "if (current_max, current_min) != rolling_min_max[--1]:",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[--1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_max = max(num, rolling_min_max[-1][0])",
      "mutated_line": "current_max = max(num, rolling_min_max[-2][0])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-2][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_max = max(num, rolling_min_max[-1][0])",
      "mutated_line": "current_max = max(num, rolling_min_max[-0][0])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-0][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_max = max(num, rolling_min_max[-1][0])",
      "mutated_line": "current_max = max(num, rolling_min_max[-0][0])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-0][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_max = max(num, rolling_min_max[-1][0])",
      "mutated_line": "current_max = max(num, rolling_min_max[--1][0])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[--1][0])\n        current_min = min(num, rolling_min_max[-1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_min = min(num, rolling_min_max[-1][1])",
      "mutated_line": "current_min = min(num, rolling_min_max[-2][1])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-2][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_min = min(num, rolling_min_max[-1][1])",
      "mutated_line": "current_min = min(num, rolling_min_max[-0][1])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-0][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_min = min(num, rolling_min_max[-1][1])",
      "mutated_line": "current_min = min(num, rolling_min_max[-0][1])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[-0][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_min = min(num, rolling_min_max[-1][1])",
      "mutated_line": "current_min = min(num, rolling_min_max[--1][1])",
      "code": "from typing import List, Union, Tuple\n\ndef rolling_max_min(numbers: List[Union[int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    From a given numeral array or erroneous code, create a list of rolling maximum and minimum numbers observed \n    till a particular point in the array, represented as a tuple (max, min), ensuring there are no repeated \n    (max, min) tuples in the final list. The function should handle erroneous code inputs.\n    \"\"\"\n    numbers = [n for n in numbers if isinstance(n, int)]\n    if not numbers:\n        return []\n    rolling_min_max = [(numbers[0], numbers[0])]\n    for num in numbers[1:]:\n        current_max = max(num, rolling_min_max[-1][0])\n        current_min = min(num, rolling_min_max[--1][1])\n        if (current_max, current_min) != rolling_min_max[-1]:\n            rolling_min_max.append((current_max, current_min))\n    return rolling_min_max"
    }
  ]
}