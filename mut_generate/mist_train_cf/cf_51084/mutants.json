{
  "task_id": "cf_51084",
  "entry_point": "slidingPuzzle",
  "mutant_count": 132,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if grid == final:",
      "mutated_line": "if grid != final:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid != final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 1\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return -1\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 1\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "distances = {state(grid): 0}",
      "mutated_line": "distances = {state(grid): 1}",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 1}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "distances = {state(grid): 0}",
      "mutated_line": "distances = {state(grid): -1}",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): -1}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "distances = {state(grid): 0}",
      "mutated_line": "distances = {state(grid): 1}",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 1}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[2, 2], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[2, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[0, 2], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[0, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[0, 2], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[0, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[-1, 2], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[-1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 3], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 3], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 1], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 1], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 0], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 0], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 1], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 1], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, -2], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, -2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [4, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [4, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [2, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [2, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [0, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [0, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [1, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [1, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [-3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [-3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [3, 1]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 1]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [3, -1]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, -1]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [3, 1]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 1]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (1, 0)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (1, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (-1, 0)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (-1, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (1, 0)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (1, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (0, 1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 1)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (0, -1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, -1)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (0, 1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 1)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for r in range(2):",
      "mutated_line": "for r in range(3):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(3):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for r in range(2):",
      "mutated_line": "for r in range(1):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(1):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for r in range(2):",
      "mutated_line": "for r in range(0):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(0):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for r in range(2):",
      "mutated_line": "for r in range(1):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(1):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for r in range(2):",
      "mutated_line": "for r in range(-2):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(-2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 or 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 or 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue = [[grid, 0]]",
      "mutated_line": "queue = [[grid, 1]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 1]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue = [[grid, 0]]",
      "mutated_line": "queue = [[grid, -1]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, -1]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue = [[grid, 0]]",
      "mutated_line": "queue = [[grid, 1]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 1]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "current, step = queue.pop(0)",
      "mutated_line": "(current, step) = queue.pop(1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(1)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "current, step = queue.pop(0)",
      "mutated_line": "(current, step) = queue.pop(-1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(-1)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "current, step = queue.pop(0)",
      "mutated_line": "(current, step) = queue.pop(1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(1)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if newState not in distances:",
      "mutated_line": "if newState in distances:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for c in range(2):",
      "mutated_line": "for c in range(3):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(3):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for c in range(2):",
      "mutated_line": "for c in range(1):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(1):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for c in range(2):",
      "mutated_line": "for c in range(0):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(0):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for c in range(2):",
      "mutated_line": "for c in range(1):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(1):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for c in range(2):",
      "mutated_line": "for c in range(-2):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(-2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if grid[r][c] == 0:",
      "mutated_line": "if grid[r][c] != 0:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] != 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(+1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(+1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 2), (1, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 2), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, -1), (1, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, -1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (2, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (2, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (0, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (0, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (0, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (0, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (-1, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (-1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 2), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 2), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 0), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 0), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, -1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, -1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (+1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (+1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, +1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, +1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (2, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (2, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (-1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (-1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, +1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, +1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 < nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 > nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 == nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 < ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 < ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 > ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 > ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 == ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 == ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step - 1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step - 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step * 1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step * 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if newState == str(final):",
      "mutated_line": "if newState != str(final):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState != str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if grid[r][c] == 0:",
      "mutated_line": "if grid[r][c] == 1:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 1:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if grid[r][c] == 0:",
      "mutated_line": "if grid[r][c] == -1:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == -1:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if grid[r][c] == 0:",
      "mutated_line": "if grid[r][c] == 1:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 1:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-2, 1), (1, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-2, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 1), (1, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-0, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 1), (1, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-0, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(--1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(--1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-2, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-2, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-0, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-0, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-0, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-0, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (--1, -1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (--1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -2), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -2), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -0), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -0), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -0), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -0), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, --1), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, --1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -2)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -2)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -0)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -0)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -0)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -0)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for dx, dy in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, --1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, --1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 1 <= nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if -1 <= nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 1 <= nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 3 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 3 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 1 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 1 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 0 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 0 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 1 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 1 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < -2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < -2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 1 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 1 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and -1 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and -1 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 1 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 1 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 <= ny < 3:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 3:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 <= ny < 1:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 1:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 <= ny < 0:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 0:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 <= ny < 1:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 1:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 <= ny < -2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < -2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step + 2",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 2\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step + 0",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 0\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step + 0",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 0\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step + -1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + -1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 1])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "queue.append([nextGrid, step + 1])",
      "mutated_line": "queue.append([nextGrid, step - 1])",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step - 1])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "queue.append([nextGrid, step + 1])",
      "mutated_line": "queue.append([nextGrid, step * 1])",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step * 1])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append([nextGrid, step + 1])",
      "mutated_line": "queue.append([nextGrid, step + 2])",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 2])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append([nextGrid, step + 1])",
      "mutated_line": "queue.append([nextGrid, step + 0])",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 0])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append([nextGrid, step + 1])",
      "mutated_line": "queue.append([nextGrid, step + 0])",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + 0])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append([nextGrid, step + 1])",
      "mutated_line": "queue.append([nextGrid, step + -1])",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(grid):\n        return str(grid)\n\n    def adjacents(grid):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if grid[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (1, 1), (-1, -1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in grid]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [[grid, 0]]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if newState == str(final):\n                    return distances[newState]\n                queue.append([nextGrid, step + -1])\n    return -1"
    }
  ]
}