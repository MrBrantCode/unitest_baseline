{
  "task_id": "cf_82013",
  "entry_point": "min_turns",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if '00000' in deadends_set:",
      "mutated_line": "if '00000' not in deadends_set:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' not in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if '00000' in deadends_set:",
      "mutated_line": "if '' in deadends_set:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return +1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited = set('00000')",
      "mutated_line": "visited = set('')",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if state == target:",
      "mutated_line": "if state != target:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state != target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -2\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -0\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -0\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return --1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue = [('00000', 0)]",
      "mutated_line": "queue = [('', 0)]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue = [('00000', 0)]",
      "mutated_line": "queue = [('00000', 1)]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 1)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue = [('00000', 0)]",
      "mutated_line": "queue = [('00000', -1)]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', -1)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue = [('00000', 0)]",
      "mutated_line": "queue = [('00000', 1)]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 1)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state, distance = queue.pop(0)",
      "mutated_line": "(state, distance) = queue.pop(1)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(1)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state, distance = queue.pop(0)",
      "mutated_line": "(state, distance) = queue.pop(-1)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(-1)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state, distance = queue.pop(0)",
      "mutated_line": "(state, distance) = queue.pop(1)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(1)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(5):",
      "mutated_line": "for i in range(6):",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(6):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(5):",
      "mutated_line": "for i in range(4):",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(4):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(5):",
      "mutated_line": "for i in range(0):",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(0):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(5):",
      "mutated_line": "for i in range(1):",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(1):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(5):",
      "mutated_line": "for i in range(-5):",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(-5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "for j in [-1, 1]:",
      "mutated_line": "for j in [+1, 1]:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [+1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in [-1, 1]:",
      "mutated_line": "for j in [-1, 2]:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 2]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in [-1, 1]:",
      "mutated_line": "for j in [-1, 0]:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 0]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in [-1, 1]:",
      "mutated_line": "for j in [-1, 0]:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 0]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in [-1, 1]:",
      "mutated_line": "for j in [-1, -1]:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, -1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "new_digit = (int(state[i]) + j) % 10",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) * 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "new_digit = (int(state[i]) + j) % 10",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = int(state[i]) + j + 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "new_state = state[:i] + str(new_digit) + state[i+1:]",
      "mutated_line": "new_state = state[:i] + str(new_digit) - state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) - state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "new_state = state[:i] + str(new_digit) + state[i+1:]",
      "mutated_line": "new_state = (state[:i] + str(new_digit)) * state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = (state[:i] + str(new_digit)) * state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "new_distance = distance + 1 + (new_state in obstacles_set)",
      "mutated_line": "new_distance = distance + 1 - (new_state in obstacles_set)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 - (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "new_distance = distance + 1 + (new_state in obstacles_set)",
      "mutated_line": "new_distance = (distance + 1) * (new_state in obstacles_set)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = (distance + 1) * (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 50,
      "original_line": "if new_state not in deadends_set and new_state not in visited:",
      "mutated_line": "if new_state not in deadends_set or new_state not in visited:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set or new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in [-1, 1]:",
      "mutated_line": "for j in [-2, 1]:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-2, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in [-1, 1]:",
      "mutated_line": "for j in [-0, 1]:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-0, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in [-1, 1]:",
      "mutated_line": "for j in [-0, 1]:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-0, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in [-1, 1]:",
      "mutated_line": "for j in [--1, 1]:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [--1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "new_digit = (int(state[i]) + j) % 10",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) - j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "new_digit = (int(state[i]) + j) % 10",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = int(state[i]) * j % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_digit = (int(state[i]) + j) % 10",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 11\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_digit = (int(state[i]) + j) % 10",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 9\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_digit = (int(state[i]) + j) % 10",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 0\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_digit = (int(state[i]) + j) % 10",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 1\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_digit = (int(state[i]) + j) % 10",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % -10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "new_state = state[:i] + str(new_digit) + state[i+1:]",
      "mutated_line": "new_state = state[:i] - str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] - str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "new_state = state[:i] + str(new_digit) + state[i+1:]",
      "mutated_line": "new_state = state[:i] * str(new_digit) + state[i + 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] * str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "new_distance = distance + 1 + (new_state in obstacles_set)",
      "mutated_line": "new_distance = distance - 1 + (new_state in obstacles_set)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance - 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "new_distance = distance + 1 + (new_state in obstacles_set)",
      "mutated_line": "new_distance = distance * 1 + (new_state in obstacles_set)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance * 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "new_distance = distance + 1 + (new_state in obstacles_set)",
      "mutated_line": "new_distance = distance + 1 + (new_state not in obstacles_set)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state not in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if new_state not in deadends_set and new_state not in visited:",
      "mutated_line": "if new_state in deadends_set and new_state not in visited:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if new_state not in deadends_set and new_state not in visited:",
      "mutated_line": "if new_state not in deadends_set and new_state in visited:",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "new_distance = distance + 1 + (new_state in obstacles_set)",
      "mutated_line": "new_distance = distance + 2 + (new_state in obstacles_set)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 2 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "new_distance = distance + 1 + (new_state in obstacles_set)",
      "mutated_line": "new_distance = distance + 0 + (new_state in obstacles_set)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 0 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "new_distance = distance + 1 + (new_state in obstacles_set)",
      "mutated_line": "new_distance = distance + 0 + (new_state in obstacles_set)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + 0 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "new_distance = distance + 1 + (new_state in obstacles_set)",
      "mutated_line": "new_distance = distance + -1 + (new_state in obstacles_set)",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 1:]\n                new_distance = distance + -1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "new_state = state[:i] + str(new_digit) + state[i+1:]",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i - 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i - 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "new_state = state[:i] + str(new_digit) + state[i+1:]",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i * 1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i * 1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_state = state[:i] + str(new_digit) + state[i+1:]",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 2:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 2:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_state = state[:i] + str(new_digit) + state[i+1:]",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 0:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 0:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_state = state[:i] + str(new_digit) + state[i+1:]",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + 0:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + 0:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "new_state = state[:i] + str(new_digit) + state[i+1:]",
      "mutated_line": "new_state = state[:i] + str(new_digit) + state[i + -1:]",
      "code": "def min_turns(deadends, obstacles, target):\n    \"\"\"\n    This function calculates the minimum total number of turns needed to unlock the lock.\n    \n    Parameters:\n    deadends (list): A list of codes that, if displayed on the lock, will cause the wheels to cease turning.\n    obstacles (list): A list of codes that, if displayed on the lock, will require an additional move to proceed.\n    target (str): The unlock code.\n    \n    Returns:\n    int: The minimum total number of turns needed to unlock the lock, or -1 if it's impossible.\n    \"\"\"\n    deadends_set = set(deadends)\n    if '00000' in deadends_set:\n        return -1\n    queue = [('00000', 0)]\n    visited = set('00000')\n    obstacles_set = set(obstacles)\n    while queue:\n        (state, distance) = queue.pop(0)\n        if state == target:\n            return distance\n        for i in range(5):\n            for j in [-1, 1]:\n                new_digit = (int(state[i]) + j) % 10\n                new_state = state[:i] + str(new_digit) + state[i + -1:]\n                new_distance = distance + 1 + (new_state in obstacles_set)\n                if new_state not in deadends_set and new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, new_distance))\n    return -1"
    }
  ]
}