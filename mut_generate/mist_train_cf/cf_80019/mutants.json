{
  "task_id": "cf_80019",
  "entry_point": "precedence",
  "mutant_count": 56,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "return char in operators",
      "mutated_line": "return char not in operators",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char not in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rpn = \"\"",
      "mutated_line": "rpn = 'MUTATED'",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = 'MUTATED'\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "rpn += stack.pop()",
      "mutated_line": "rpn -= stack.pop()",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn -= stack.pop()\n    return rpn"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return len(self.stack) == 0",
      "mutated_line": "return len(self.stack) != 0",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) != 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '': 1, '*': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': 2, '': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 2, '-': 1, '*': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 2, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 0, '-': 1, '*': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 0, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 0, '-': 1, '*': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 0, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': -1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': -1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 2, '*': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 2, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 0, '*': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 0, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 0, '*': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 0, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': -1, '*': 2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': -1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 3, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 3, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 1, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 1, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 0, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 0, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 1, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 1, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': -2, '/': 2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': -2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': 3, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 3, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': 1, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 1, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': 0, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 0, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': 1, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 1, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': -2, '^': 3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': -2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 4}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 4}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 2}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 2}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 0}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 0}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 1}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 1}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prec = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}",
      "mutated_line": "prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': -3}",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': -3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "rpn += char",
      "mutated_line": "rpn -= char",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn -= char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return len(self.stack) == 0",
      "mutated_line": "return len(self.stack) == 1",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 1\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return len(self.stack) == 0",
      "mutated_line": "return len(self.stack) == -1",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == -1\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return len(self.stack) == 0",
      "mutated_line": "return len(self.stack) == 1",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 1\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operators = set([\"+\", \"-\", \"*\", \"/\", \"^\"])",
      "mutated_line": "operators = set(['', '-', '*', '/', '^'])",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operators = set([\"+\", \"-\", \"*\", \"/\", \"^\"])",
      "mutated_line": "operators = set(['+', '', '*', '/', '^'])",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operators = set([\"+\", \"-\", \"*\", \"/\", \"^\"])",
      "mutated_line": "operators = set(['+', '-', '', '/', '^'])",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operators = set([\"+\", \"-\", \"*\", \"/\", \"^\"])",
      "mutated_line": "operators = set(['+', '-', '*', '', '^'])",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operators = set([\"+\", \"-\", \"*\", \"/\", \"^\"])",
      "mutated_line": "operators = set(['+', '-', '*', '/', ''])",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', ''])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "while (not stack.is_empty() and is_operator(stack.stack[-1]) and",
      "mutated_line": "while not stack.is_empty() or is_operator(stack.stack[-1]) or precedence(char) <= precedence(stack.stack[-1]):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() or is_operator(stack.stack[-1]) or precedence(char) <= precedence(stack.stack[-1]):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "rpn += stack.pop()",
      "mutated_line": "rpn -= stack.pop()",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn -= stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "precedence(char) <= precedence(stack.stack[-1])):",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) < precedence(stack.stack[-1])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) < precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "precedence(char) <= precedence(stack.stack[-1])):",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) > precedence(stack.stack[-1])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) > precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "precedence(char) <= precedence(stack.stack[-1])):",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) == precedence(stack.stack[-1])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) == precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "while (not stack.is_empty() and is_operator(stack.stack[-1]) and",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[+1]) and (precedence(char) <= precedence(stack.stack[-1])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[+1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while (not stack.is_empty() and is_operator(stack.stack[-1]) and",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-2]) and (precedence(char) <= precedence(stack.stack[-1])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-2]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while (not stack.is_empty() and is_operator(stack.stack[-1]) and",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-0]) and (precedence(char) <= precedence(stack.stack[-1])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-0]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while (not stack.is_empty() and is_operator(stack.stack[-1]) and",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-0]) and (precedence(char) <= precedence(stack.stack[-1])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-0]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while (not stack.is_empty() and is_operator(stack.stack[-1]) and",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[--1]) and (precedence(char) <= precedence(stack.stack[-1])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[--1]) and (precedence(char) <= precedence(stack.stack[-1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "precedence(char) <= precedence(stack.stack[-1])):",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[+1])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[+1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "precedence(char) <= precedence(stack.stack[-1])):",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-2])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-2])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "precedence(char) <= precedence(stack.stack[-1])):",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-0])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-0])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "precedence(char) <= precedence(stack.stack[-1])):",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-0])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[-0])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "precedence(char) <= precedence(stack.stack[-1])):",
      "mutated_line": "while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[--1])):",
      "code": "class Stack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, char):\n        self.stack.append(char)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef precedence(operator):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    return prec[operator]\n\ndef is_operator(char):\n    operators = set(['+', '-', '*', '/', '^'])\n    return char in operators\n\ndef infix_to_rpn(expression):\n    stack = Stack()\n    rpn = ''\n    for char in expression:\n        if is_operator(char):\n            while not stack.is_empty() and is_operator(stack.stack[-1]) and (precedence(char) <= precedence(stack.stack[--1])):\n                rpn += stack.pop()\n            stack.push(char)\n        else:\n            rpn += char\n    while not stack.is_empty():\n        rpn += stack.pop()\n    return rpn"
    }
  ]
}