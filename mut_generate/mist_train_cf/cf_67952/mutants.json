{
  "task_id": "cf_67952",
  "entry_point": "find_hex_cluster",
  "mutant_count": 38,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if current_product == target_product:",
      "mutated_line": "if current_product != target_product:",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product != target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if current_product > target_product or start >= len(hex_series):",
      "mutated_line": "if current_product > target_product and start >= len(hex_series):",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product and start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(0, 1, [])",
      "mutated_line": "return backtrack(1, 1, [])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(1, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(0, 1, [])",
      "mutated_line": "return backtrack(-1, 1, [])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(-1, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(0, 1, [])",
      "mutated_line": "return backtrack(1, 1, [])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(1, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(0, 1, [])",
      "mutated_line": "return backtrack(0, 2, [])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 2, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(0, 1, [])",
      "mutated_line": "return backtrack(0, 0, [])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(0, 1, [])",
      "mutated_line": "return backtrack(0, 0, [])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(0, 1, [])",
      "mutated_line": "return backtrack(0, -1, [])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, -1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if current_product > target_product or start >= len(hex_series):",
      "mutated_line": "if current_product >= target_product or start >= len(hex_series):",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product >= target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if current_product > target_product or start >= len(hex_series):",
      "mutated_line": "if current_product <= target_product or start >= len(hex_series):",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product <= target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if current_product > target_product or start >= len(hex_series):",
      "mutated_line": "if current_product != target_product or start >= len(hex_series):",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product != target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if current_product > target_product or start >= len(hex_series):",
      "mutated_line": "if current_product > target_product or start > len(hex_series):",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start > len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if current_product > target_product or start >= len(hex_series):",
      "mutated_line": "if current_product > target_product or start < len(hex_series):",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start < len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if current_product > target_product or start >= len(hex_series):",
      "mutated_line": "if current_product > target_product or start == len(hex_series):",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start == len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "num = int(hex_series[start], 16)",
      "mutated_line": "num = int(hex_series[start], 17)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 17)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "num = int(hex_series[start], 16)",
      "mutated_line": "num = int(hex_series[start], 15)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 15)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "num = int(hex_series[start], 16)",
      "mutated_line": "num = int(hex_series[start], 0)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 0)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "num = int(hex_series[start], 16)",
      "mutated_line": "num = int(hex_series[start], 1)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 1)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "num = int(hex_series[start], 16)",
      "mutated_line": "num = int(hex_series[start], -16)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], -16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start - 1, current_product * num, current_cluster + [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start - 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start * 1, current_product * num, current_cluster + [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start * 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start + 1, current_product / num, current_cluster + [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product / num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start + 1, current_product + num, current_cluster + [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product + num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start + 1, current_product ** num, current_cluster + [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product ** num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster - [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster - [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster * [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster * [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "excluded_cluster = backtrack(start + 1, current_product, current_cluster)",
      "mutated_line": "excluded_cluster = backtrack(start - 1, current_product, current_cluster)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start - 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "excluded_cluster = backtrack(start + 1, current_product, current_cluster)",
      "mutated_line": "excluded_cluster = backtrack(start * 1, current_product, current_cluster)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start * 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start + 2, current_product * num, current_cluster + [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 2, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start + 0, current_product * num, current_cluster + [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 0, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start + 0, current_product * num, current_cluster + [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 0, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])",
      "mutated_line": "included_cluster = backtrack(start + -1, current_product * num, current_cluster + [hex_series[start]])",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + -1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "excluded_cluster = backtrack(start + 1, current_product, current_cluster)",
      "mutated_line": "excluded_cluster = backtrack(start + 2, current_product, current_cluster)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 2, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "excluded_cluster = backtrack(start + 1, current_product, current_cluster)",
      "mutated_line": "excluded_cluster = backtrack(start + 0, current_product, current_cluster)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 0, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "excluded_cluster = backtrack(start + 1, current_product, current_cluster)",
      "mutated_line": "excluded_cluster = backtrack(start + 0, current_product, current_cluster)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + 0, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "excluded_cluster = backtrack(start + 1, current_product, current_cluster)",
      "mutated_line": "excluded_cluster = backtrack(start + -1, current_product, current_cluster)",
      "code": "def find_hex_cluster(hex_series, target_product):\n    \"\"\"\n    Find the cluster of hexadecimal numbers in a given series such that their product equals a preordained result.\n\n    Args:\n        hex_series (list): A list of hexadecimal numbers as strings.\n        target_product (int): The target product.\n\n    Returns:\n        list: A list of hexadecimal numbers whose product equals the target product, or an empty list if no such cluster is found.\n    \"\"\"\n\n    def backtrack(start, current_product, current_cluster):\n        if current_product == target_product:\n            return current_cluster\n        if current_product > target_product or start >= len(hex_series):\n            return []\n        num = int(hex_series[start], 16)\n        included_cluster = backtrack(start + 1, current_product * num, current_cluster + [hex_series[start]])\n        excluded_cluster = backtrack(start + -1, current_product, current_cluster)\n        return included_cluster if included_cluster else excluded_cluster\n    return backtrack(0, 1, [])"
    }
  ]
}