{
  "task_id": "cf_31277",
  "entry_point": "move_player",
  "mutant_count": 97,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if direction == \"up\":",
      "mutated_line": "if direction != 'up':",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction != 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "new_position[0] -= 1",
      "mutated_line": "if direction == 'up':",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] += 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if (0 <= new_position[0] < len(maze) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) or 0 <= new_position[1] < len(maze[0]) or maze[new_position[0]][new_position[1]] != '#':\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def move_player(maze, direction, player_position=[1, 1]):",
      "mutated_line": "def move_player(maze, direction, player_position=[2, 1]):",
      "code": "def move_player(maze, direction, player_position=[2, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def move_player(maze, direction, player_position=[1, 1]):",
      "mutated_line": "def move_player(maze, direction, player_position=[0, 1]):",
      "code": "def move_player(maze, direction, player_position=[0, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def move_player(maze, direction, player_position=[1, 1]):",
      "mutated_line": "def move_player(maze, direction, player_position=[0, 1]):",
      "code": "def move_player(maze, direction, player_position=[0, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def move_player(maze, direction, player_position=[1, 1]):",
      "mutated_line": "def move_player(maze, direction, player_position=[-1, 1]):",
      "code": "def move_player(maze, direction, player_position=[-1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def move_player(maze, direction, player_position=[1, 1]):",
      "mutated_line": "def move_player(maze, direction, player_position=[1, 2]):",
      "code": "def move_player(maze, direction, player_position=[1, 2]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def move_player(maze, direction, player_position=[1, 1]):",
      "mutated_line": "def move_player(maze, direction, player_position=[1, 0]):",
      "code": "def move_player(maze, direction, player_position=[1, 0]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def move_player(maze, direction, player_position=[1, 1]):",
      "mutated_line": "def move_player(maze, direction, player_position=[1, 0]):",
      "code": "def move_player(maze, direction, player_position=[1, 0]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def move_player(maze, direction, player_position=[1, 1]):",
      "mutated_line": "def move_player(maze, direction, player_position=[1, -1]):",
      "code": "def move_player(maze, direction, player_position=[1, -1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if direction == \"up\":",
      "mutated_line": "if direction == '':",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == '':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "new_position[0] -= 1",
      "mutated_line": "new_position[0] -= 2",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 2\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "new_position[0] -= 1",
      "mutated_line": "new_position[0] -= 0",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 0\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "new_position[0] -= 1",
      "mutated_line": "new_position[0] -= 0",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 0\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "new_position[0] -= 1",
      "mutated_line": "new_position[0] -= -1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= -1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif direction == \"down\":",
      "mutated_line": "elif direction != 'down':",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction != 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "new_position[0] += 1",
      "mutated_line": "new_position[0] -= 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] -= 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (0 <= new_position[0] < len(maze) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 < new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (0 <= new_position[0] < len(maze) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 > new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (0 <= new_position[0] < len(maze) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 == new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 < new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 > new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 == new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "maze[new_position[0]][new_position[1]] != '#'):",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] == '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "new_position[0] -= 1",
      "mutated_line": "new_position[1] -= 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[1] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "new_position[0] -= 1",
      "mutated_line": "new_position[-1] -= 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[-1] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "new_position[0] -= 1",
      "mutated_line": "new_position[1] -= 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[1] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif direction == \"down\":",
      "mutated_line": "elif direction == '':",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == '':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_position[0] += 1",
      "mutated_line": "new_position[0] += 2",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 2\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_position[0] += 1",
      "mutated_line": "new_position[0] += 0",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 0\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_position[0] += 1",
      "mutated_line": "new_position[0] += 0",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 0\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_position[0] += 1",
      "mutated_line": "new_position[0] += -1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += -1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif direction == \"left\":",
      "mutated_line": "elif direction != 'left':",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction != 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "new_position[1] -= 1",
      "mutated_line": "elif direction == 'left':",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] += 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (0 <= new_position[0] < len(maze) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 1 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (0 <= new_position[0] < len(maze) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if -1 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (0 <= new_position[0] < len(maze) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 1 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 1 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and -1 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 1 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maze[new_position[0]][new_position[1]] != '#'):",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != ''):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_position[0] += 1",
      "mutated_line": "new_position[1] += 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[1] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_position[0] += 1",
      "mutated_line": "new_position[-1] += 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[-1] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_position[0] += 1",
      "mutated_line": "new_position[1] += 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[1] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif direction == \"left\":",
      "mutated_line": "elif direction == '':",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == '':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_position[1] -= 1",
      "mutated_line": "new_position[1] -= 2",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 2\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_position[1] -= 1",
      "mutated_line": "new_position[1] -= 0",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 0\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_position[1] -= 1",
      "mutated_line": "new_position[1] -= 0",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 0\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_position[1] -= 1",
      "mutated_line": "new_position[1] -= -1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= -1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif direction == \"right\":",
      "mutated_line": "elif direction != 'right':",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction != 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "new_position[1] += 1",
      "mutated_line": "new_position[1] -= 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] -= 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (0 <= new_position[0] < len(maze) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[1] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (0 <= new_position[0] < len(maze) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[-1] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (0 <= new_position[0] < len(maze) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[1] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[2] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[0] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[0] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[-1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[1], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[1], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[-1], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[-1], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[1], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[1], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[2]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[2]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[0]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[0]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[0]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[0]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[-1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[-1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[1], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[1], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[-1], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[-1], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[1], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[1], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[2])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[2])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[0])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[0])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[0])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[0])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "player_position[0], player_position[1] = new_position[0], new_position[1]",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[-1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[-1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_position[1] -= 1",
      "mutated_line": "new_position[2] -= 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[2] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_position[1] -= 1",
      "mutated_line": "new_position[0] -= 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[0] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_position[1] -= 1",
      "mutated_line": "new_position[0] -= 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[0] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_position[1] -= 1",
      "mutated_line": "new_position[-1] -= 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[-1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif direction == \"right\":",
      "mutated_line": "elif direction == '':",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == '':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_position[1] += 1",
      "mutated_line": "new_position[1] += 2",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 2\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_position[1] += 1",
      "mutated_line": "new_position[1] += 0",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 0\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_position[1] += 1",
      "mutated_line": "new_position[1] += 0",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 0\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_position[1] += 1",
      "mutated_line": "new_position[1] += -1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += -1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[1]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[-1]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "0 <= new_position[1] < len(maze[0]) and",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[1]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maze[new_position[0]][new_position[1]] != '#'):",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[2]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maze[new_position[0]][new_position[1]] != '#'):",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[0]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maze[new_position[0]][new_position[1]] != '#'):",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[0]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maze[new_position[0]][new_position[1]] != '#'):",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[-1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_position[1] += 1",
      "mutated_line": "new_position[2] += 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[2] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_position[1] += 1",
      "mutated_line": "new_position[0] += 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[0] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_position[1] += 1",
      "mutated_line": "new_position[0] += 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[0] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_position[1] += 1",
      "mutated_line": "new_position[-1] += 1",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[-1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maze[new_position[0]][new_position[1]] != '#'):",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[1]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maze[new_position[0]][new_position[1]] != '#'):",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[-1]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "maze[new_position[0]][new_position[1]] != '#'):",
      "mutated_line": "(player_position[0], player_position[1]) = (new_position[0], new_position[1])",
      "code": "def move_player(maze, direction, player_position=[1, 1]):\n    \"\"\"\n    Move the player within a given maze, considering the maze boundaries and obstacles.\n\n    Args:\n    maze (list): A 2D grid representing the maze.\n    direction (str): The direction of movement (up, down, left, or right).\n    player_position (list): The initial player position (default is [1, 1]).\n\n    Returns:\n    list: The updated player position.\n    \"\"\"\n    new_position = player_position.copy()\n    if direction == 'up':\n        new_position[0] -= 1\n    elif direction == 'down':\n        new_position[0] += 1\n    elif direction == 'left':\n        new_position[1] -= 1\n    elif direction == 'right':\n        new_position[1] += 1\n    if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[1]][new_position[1]] != '#'):\n        (player_position[0], player_position[1]) = (new_position[0], new_position[1])\n    return player_position"
    }
  ]
}