{
  "task_id": "cf_72635",
  "entry_point": "solve",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "weight_sum += nodeWeights[node]",
      "mutated_line": "weight_sum -= nodeWeights[node]",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum -= nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return False",
      "mutated_line": "return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return True\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if node == end: return True",
      "mutated_line": "return True",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node != end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if node in seen: continue",
      "mutated_line": "if node not in seen:",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node not in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if weight_sum >= weight: continue",
      "mutated_line": "continue",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum > weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if weight_sum >= weight: continue",
      "mutated_line": "continue",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum < weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if weight_sum >= weight: continue",
      "mutated_line": "continue",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum == weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue = [(0, start, 0)]",
      "mutated_line": "queue = [(1, start, 0)]",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(1, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue = [(0, start, 0)]",
      "mutated_line": "queue = [(-1, start, 0)]",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(-1, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue = [(0, start, 0)]",
      "mutated_line": "queue = [(1, start, 0)]",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(1, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue = [(0, start, 0)]",
      "mutated_line": "queue = [(0, start, 1)]",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 1)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue = [(0, start, 0)]",
      "mutated_line": "queue = [(0, start, -1)]",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, -1)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue = [(0, start, 0)]",
      "mutated_line": "queue = [(0, start, 1)]",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 1)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if node == end: return True",
      "mutated_line": "return False",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return False\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if edge < limit:",
      "mutated_line": "if edge <= limit:",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge <= limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if edge < limit:",
      "mutated_line": "if edge >= limit:",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge >= limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if edge < limit:",
      "mutated_line": "if edge != limit:",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge != limit:\n                    heapq.heappush(queue, (dist + edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "heapq.heappush(queue, (dist + edge, next_node, weight_sum))",
      "mutated_line": "heapq.heappush(queue, (dist - edge, next_node, weight_sum))",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist - edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "heapq.heappush(queue, (dist + edge, next_node, weight_sum))",
      "mutated_line": "heapq.heappush(queue, (dist * edge, next_node, weight_sum))",
      "code": "import heapq\n\ndef solve(n, edgeList, nodeWeights, queries):\n    \"\"\"\n    This function determines whether there is a path between two nodes in the given undirected graph \n    that satisfies the given constraints.\n\n    Parameters:\n    n (int): The number of nodes in the graph.\n    edgeList (list): A list of edges in the graph, where each edge is represented as a list [ui, vi, disi], \n                     denoting an edge between nodes ui and vi with distance disi.\n    nodeWeights (list): A list of node weights, where nodeWeights[k] is the weight of node k.\n    queries (list): A list of queries, where each query is represented as a list [pj, qj, limitj, weightj].\n\n    Returns:\n    list: A boolean array where each value represents the result of the corresponding query.\n    \"\"\"\n    graph = {i: [] for i in range(n)}\n    for (u, v, p) in edgeList:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    def shortestPath(start, end, limit, weight):\n        \"\"\"\n        This function calculates the shortest path between two nodes in the graph.\n\n        Parameters:\n        start (int): The starting node.\n        end (int): The ending node.\n        limit (int): The maximum distance.\n        weight (int): The maximum weight.\n\n        Returns:\n        bool: Whether there is a path between the two nodes that satisfies the constraints.\n        \"\"\"\n        queue = [(0, start, 0)]\n        seen = set()\n        while queue:\n            (dist, node, weight_sum) = heapq.heappop(queue)\n            if node == end:\n                return True\n            if node in seen:\n                continue\n            seen.add(node)\n            weight_sum += nodeWeights[node]\n            if weight_sum >= weight:\n                continue\n            for (next_node, edge) in graph[node]:\n                if edge < limit:\n                    heapq.heappush(queue, (dist * edge, next_node, weight_sum))\n        return False\n    return [shortestPath(u, v, limit, weight) for (u, v, limit, weight) in queries]"
    }
  ]
}