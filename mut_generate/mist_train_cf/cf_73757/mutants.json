{
  "task_id": "cf_73757",
  "entry_point": "canMouseWin",
  "mutant_count": 200,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "UOI",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "UOI",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else True",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else True"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if grid[i][j] == 'C':",
      "mutated_line": "if grid[i][j] != 'C':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] != 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "i, j, x, y, k = queue.pop(0)",
      "mutated_line": "(i, j, x, y, k) = queue.pop(1)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(1)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "i, j, x, y, k = queue.pop(0)",
      "mutated_line": "(i, j, x, y, k) = queue.pop(-1)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(-1)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "i, j, x, y, k = queue.pop(0)",
      "mutated_line": "(i, j, x, y, k) = queue.pop(1)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(1)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nk = 1-k",
      "mutated_line": "nk = 1 + k",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 + k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nk = 1-k",
      "mutated_line": "nk = 1 * k",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 * k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == 0 or max(abs(nx - x), abs(ny - y)) > catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 or max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 1 or max(abs(nx - x), abs(ny - y)) > mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 or max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':",
      "mutated_line": "if dp[nx][ny][i][j][nk] is None or grid[nx][ny] != '#':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None or grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][2] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][2] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][0] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][0] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][0] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][0] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][-1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][-1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[1]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[-1]))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[-1]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[1]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if grid[i][j] == 'C':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif grid[i][j] == 'M':",
      "mutated_line": "elif grid[i][j] != 'M':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] != 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for k in range(2):",
      "mutated_line": "for k in range(3):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(3):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for k in range(2):",
      "mutated_line": "for k in range(1):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(1):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for k in range(2):",
      "mutated_line": "for k in range(0):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(0):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for k in range(2):",
      "mutated_line": "for k in range(1):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(1):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for k in range(2):",
      "mutated_line": "for k in range(-2):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(-2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][food[0]][food[1]][k] = False",
      "mutated_line": "dp[i][j][food[0]][food[1]][k] = True",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = True\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if grid[i][j] != '#':",
      "mutated_line": "if grid[i][j] == '#':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] == '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + k*dx, y + k*dy",
      "mutated_line": "(nx, ny) = (x - k * dx, y + k * dy)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x - k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + k*dx, y + k*dy",
      "mutated_line": "(nx, ny) = (x * (k * dx), y + k * dy)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x * (k * dx), y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + k*dx, y + k*dy",
      "mutated_line": "(nx, ny) = (x + k * dx, y - k * dy)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y - k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + k*dx, y + k*dy",
      "mutated_line": "(nx, ny) = (x + k * dx, y * (k * dy))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y * (k * dy))\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nk = 1-k",
      "mutated_line": "nk = 2 - k",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 2 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nk = 1-k",
      "mutated_line": "nk = 0 - k",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 0 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nk = 1-k",
      "mutated_line": "nk = 0 - k",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 0 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nk = 1-k",
      "mutated_line": "nk = -1 - k",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = -1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (0 <= nx < rows or 0 <= ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows or 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k != 0 and max(abs(nx - x), abs(ny - y)) > catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k != 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == 0 and max(abs(nx - x), abs(ny - y)) >= catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) >= catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == 0 and max(abs(nx - x), abs(ny - y)) <= catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) <= catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == 0 and max(abs(nx - x), abs(ny - y)) != catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) != catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k != 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k != 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 1 and max(abs(nx - x), abs(ny - y)) >= mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) >= mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 1 and max(abs(nx - x), abs(ny - y)) <= mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) <= mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 1 and max(abs(nx - x), abs(ny - y)) != mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) != mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':",
      "mutated_line": "if dp[nx][ny][i][j][nk] is not None and grid[nx][ny] != '#':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is not None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':",
      "mutated_line": "if dp[nx][ny][i][j][nk] is None and grid[nx][ny] == '#':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] == '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and dp[nx][ny][nx][ny][1-nk] is None:",
      "mutated_line": "if nx == i or ny == j or dp[nx][ny][nx][ny][nk] or (dp[nx][ny][nx][ny][1 - nk] is None):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i or ny == j or dp[nx][ny][nx][ny][nk] or (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][2] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][2] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][0] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][0] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][0] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][0] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][-1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][-1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif grid[i][j] == 'M':",
      "mutated_line": "elif grid[i][j] == '':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == '':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif grid[i][j] == 'F':",
      "mutated_line": "elif grid[i][j] != 'F':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] != 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if grid[i][j] != '#':",
      "mutated_line": "if grid[i][j] != '':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i][j][i][j][1-k] = True",
      "mutated_line": "dp[i][j][i][j][1 - k] = False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = False\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + k*dx, y + k*dy",
      "mutated_line": "(nx, ny) = (x + k / dx, y + k * dy)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k / dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + k*dx, y + k*dy",
      "mutated_line": "(nx, ny) = (x + (k + dx), y + k * dy)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + (k + dx), y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + k*dx, y + k*dy",
      "mutated_line": "(nx, ny) = (x + k ** dx, y + k * dy)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k ** dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + k*dx, y + k*dy",
      "mutated_line": "(nx, ny) = (x + k * dx, y + k / dy)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k / dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + k*dx, y + k*dy",
      "mutated_line": "(nx, ny) = (x + k * dx, y + (k + dy))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + (k + dy))\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + k*dx, y + k*dy",
      "mutated_line": "(nx, ny) = (x + k * dx, y + k ** dy)",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k ** dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (0 < nx < rows and 0 <= ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 < nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (0 > nx < rows and 0 <= ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 > nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (0 == nx < rows and 0 <= ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 == nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (0 <= nx < rows and 0 < ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 < ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (0 <= nx < rows and 0 > ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 > ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (0 <= nx < rows and 0 == ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 == ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == 1 and max(abs(nx - x), abs(ny - y)) > catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == -1 and max(abs(nx - x), abs(ny - y)) > catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == -1 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == 1 and max(abs(nx - x), abs(ny - y)) > catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 2 and max(abs(nx - x), abs(ny - y)) > mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 2 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 0 and max(abs(nx - x), abs(ny - y)) > mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 0 and max(abs(nx - x), abs(ny - y)) > mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == -1 and max(abs(nx - x), abs(ny - y)) > mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == -1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':",
      "mutated_line": "if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and dp[nx][ny][nx][ny][1-nk] is None:",
      "mutated_line": "if nx != i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx != i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and dp[nx][ny][nx][ny][1-nk] is None:",
      "mutated_line": "if nx == i and ny != j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny != j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and dp[nx][ny][nx][ny][1-nk] is None:",
      "mutated_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is not None):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is not None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[2]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[2]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[0]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[0]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[0]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[0]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[-1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[-1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif grid[i][j] == 'F':",
      "mutated_line": "elif grid[i][j] == '':",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == '':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[i][j][i][j][1-k] = True",
      "mutated_line": "dp[i][j][i][j][1 + k] = True",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 + k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[i][j][i][j][1-k] = True",
      "mutated_line": "dp[i][j][i][j][1 * k] = True",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 * k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (1 <= nx < rows and 0 <= ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (1 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (-1 <= nx < rows and 0 <= ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (-1 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (1 <= nx < rows and 0 <= ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (1 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (0 <= nx < rows and 1 <= ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 1 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (0 <= nx < rows and -1 <= ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and -1 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not (0 <= nx < rows and 0 <= ny < cols):",
      "mutated_line": "if not (0 <= nx < rows and 1 <= ny < cols):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 1 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[nx][ny][nx][ny][1-nk] = not dp[nx][ny][nx][ny][nk]",
      "mutated_line": "dp[nx][ny][nx][ny][1 + nk] = not dp[nx][ny][nx][ny][nk]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 + nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[nx][ny][nx][ny][1-nk] = not dp[nx][ny][nx][ny][nk]",
      "mutated_line": "dp[nx][ny][nx][ny][1 * nk] = not dp[nx][ny][nx][ny][nk]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 * nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[2]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[2]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[0]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[0]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[0]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[0]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[-1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[-1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[1]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[1]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[-1]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[-1]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[1]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[1]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][food[0]][food[1]][k] = False",
      "mutated_line": "dp[i][j][food[0]][food[2]][k] = False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[2]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][food[0]][food[1]][k] = False",
      "mutated_line": "dp[i][j][food[0]][food[0]][k] = False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[0]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][food[0]][food[1]][k] = False",
      "mutated_line": "dp[i][j][food[0]][food[0]][k] = False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[0]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][food[0]][food[1]][k] = False",
      "mutated_line": "dp[i][j][food[0]][food[-1]][k] = False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[-1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((i, j, food[0], food[1], k))",
      "mutated_line": "queue.append((i, j, food[1], food[1], k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[1], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((i, j, food[0], food[1], k))",
      "mutated_line": "queue.append((i, j, food[-1], food[1], k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[-1], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((i, j, food[0], food[1], k))",
      "mutated_line": "queue.append((i, j, food[1], food[1], k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[1], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((i, j, food[0], food[1], k))",
      "mutated_line": "queue.append((i, j, food[0], food[2], k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[2], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((i, j, food[0], food[1], k))",
      "mutated_line": "queue.append((i, j, food[0], food[0], k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[0], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((i, j, food[0], food[1], k))",
      "mutated_line": "queue.append((i, j, food[0], food[0], k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[0], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((i, j, food[0], food[1], k))",
      "mutated_line": "queue.append((i, j, food[0], food[-1], k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[-1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i][j][i][j][1-k] = True",
      "mutated_line": "dp[i][j][i][j][2 - k] = True",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][2 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i][j][i][j][1-k] = True",
      "mutated_line": "dp[i][j][i][j][0 - k] = True",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][0 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i][j][i][j][1-k] = True",
      "mutated_line": "dp[i][j][i][j][0 - k] = True",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][0 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i][j][i][j][1-k] = True",
      "mutated_line": "dp[i][j][i][j][-1 - k] = True",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][-1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "queue.append((i, j, i, j, 1-k))",
      "mutated_line": "queue.append((i, j, i, j, 1 + k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 + k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "queue.append((i, j, i, j, 1-k))",
      "mutated_line": "queue.append((i, j, i, j, 1 * k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 * k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == 0 and max(abs(nx + x), abs(ny - y)) > catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx + x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == 0 and max(abs(nx * x), abs(ny - y)) > catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx * x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == 0 and max(abs(nx - x), abs(ny + y)) > catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny + y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if k == 0 and max(abs(nx-x), abs(ny-y)) > catJump:",
      "mutated_line": "if k == 0 and max(abs(nx - x), abs(ny * y)) > catJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny * y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 1 and max(abs(nx + x), abs(ny - y)) > mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx + x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 1 and max(abs(nx * x), abs(ny - y)) > mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx * x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 1 and max(abs(nx - x), abs(ny + y)) > mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny + y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if k == 1 and max(abs(nx-x), abs(ny-y)) > mouseJump:",
      "mutated_line": "if k == 1 and max(abs(nx - x), abs(ny * y)) > mouseJump:",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny * y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and dp[nx][ny][nx][ny][1-nk] is None:",
      "mutated_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 + nk] is None):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 + nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and dp[nx][ny][nx][ny][1-nk] is None:",
      "mutated_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 * nk] is None):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 * nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[nx][ny][nx][ny][1-nk] = not dp[nx][ny][nx][ny][nk]",
      "mutated_line": "dp[nx][ny][nx][ny][2 - nk] = not dp[nx][ny][nx][ny][nk]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][2 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[nx][ny][nx][ny][1-nk] = not dp[nx][ny][nx][ny][nk]",
      "mutated_line": "dp[nx][ny][nx][ny][0 - nk] = not dp[nx][ny][nx][ny][nk]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][0 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[nx][ny][nx][ny][1-nk] = not dp[nx][ny][nx][ny][nk]",
      "mutated_line": "dp[nx][ny][nx][ny][0 - nk] = not dp[nx][ny][nx][ny][nk]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][0 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[nx][ny][nx][ny][1-nk] = not dp[nx][ny][nx][ny][nk]",
      "mutated_line": "dp[nx][ny][nx][ny][-1 - nk] = not dp[nx][ny][nx][ny][nk]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][-1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "queue.append((nx, ny, nx, ny, 1-nk))",
      "mutated_line": "queue.append((nx, ny, nx, ny, 1 + nk))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 + nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "queue.append((nx, ny, nx, ny, 1-nk))",
      "mutated_line": "queue.append((nx, ny, nx, ny, 1 * nk))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 * nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[1]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[1]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[-1]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[-1]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[1]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[1]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[2]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[2]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[0]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[0]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[0]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[0]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[-1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[-1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "dp = [[[[[None for _ in range(3)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(3)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "dp = [[[[[None for _ in range(1)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(1)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "dp = [[[[[None for _ in range(0)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(0)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "dp = [[[[[None for _ in range(1)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(1)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "dp = [[[[[None for _ in range(-2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(-2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][food[0]][food[1]][k] = False",
      "mutated_line": "dp[i][j][food[1]][food[1]][k] = False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[1]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][food[0]][food[1]][k] = False",
      "mutated_line": "dp[i][j][food[-1]][food[1]][k] = False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[-1]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][food[0]][food[1]][k] = False",
      "mutated_line": "dp[i][j][food[1]][food[1]][k] = False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[1]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((i, j, i, j, 1-k))",
      "mutated_line": "queue.append((i, j, i, j, 2 - k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 2 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((i, j, i, j, 1-k))",
      "mutated_line": "queue.append((i, j, i, j, 0 - k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 0 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((i, j, i, j, 1-k))",
      "mutated_line": "queue.append((i, j, i, j, 0 - k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 0 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((i, j, i, j, 1-k))",
      "mutated_line": "queue.append((i, j, i, j, -1 - k))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, -1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and dp[nx][ny][nx][ny][1-nk] is None:",
      "mutated_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][2 - nk] is None):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][2 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and dp[nx][ny][nx][ny][1-nk] is None:",
      "mutated_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][0 - nk] is None):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][0 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and dp[nx][ny][nx][ny][1-nk] is None:",
      "mutated_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][0 - nk] is None):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][0 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and dp[nx][ny][nx][ny][1-nk] is None:",
      "mutated_line": "if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][-1 - nk] is None):",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][-1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "queue.append((nx, ny, nx, ny, 1-nk))",
      "mutated_line": "queue.append((nx, ny, nx, ny, 2 - nk))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 2 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "queue.append((nx, ny, nx, ny, 1-nk))",
      "mutated_line": "queue.append((nx, ny, nx, ny, 0 - nk))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 0 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "queue.append((nx, ny, nx, ny, 1-nk))",
      "mutated_line": "queue.append((nx, ny, nx, ny, 0 - nk))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 0 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "queue.append((nx, ny, nx, ny, 1-nk))",
      "mutated_line": "queue.append((nx, ny, nx, ny, -1 - nk))",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, -1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[2]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[2]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[0]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[0]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[0]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[0]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[-1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[-1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[1]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[1]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[-1]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[-1]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[1]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[1]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[1]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[1]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[-1]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[-1]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "mutated_line": "return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[1]][mouse[1]][cat[0]][cat[1]][1] is not None else False",
      "code": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\ndef canMouseWin(grid, catJump, mouseJump):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (cat, mouse, food) = (None, None, None)\n    dp = [[[[[None for _ in range(2)] for _ in range(cols)] for _ in range(rows)] for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'C':\n                cat = (i, j)\n            elif grid[i][j] == 'M':\n                mouse = (i, j)\n            elif grid[i][j] == 'F':\n                food = (i, j)\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(2):\n                dp[i][j][food[0]][food[1]][k] = False\n                queue.append((i, j, food[0], food[1], k))\n                if grid[i][j] != '#':\n                    dp[i][j][i][j][1 - k] = True\n                    queue.append((i, j, i, j, 1 - k))\n    while queue:\n        (i, j, x, y, k) = queue.pop(0)\n        for (dx, dy) in directions:\n            (nx, ny) = (x + k * dx, y + k * dy)\n            nk = 1 - k\n            if not (0 <= nx < rows and 0 <= ny < cols):\n                continue\n            if k == 0 and max(abs(nx - x), abs(ny - y)) > catJump:\n                continue\n            if k == 1 and max(abs(nx - x), abs(ny - y)) > mouseJump:\n                continue\n            if dp[nx][ny][i][j][nk] is None and grid[nx][ny] != '#':\n                dp[nx][ny][i][j][nk] = not dp[i][j][x][y][k]\n                queue.append((nx, ny, i, j, nk))\n                if nx == i and ny == j and dp[nx][ny][nx][ny][nk] and (dp[nx][ny][nx][ny][1 - nk] is None):\n                    dp[nx][ny][nx][ny][1 - nk] = not dp[nx][ny][nx][ny][nk]\n                    queue.append((nx, ny, nx, ny, 1 - nk))\n    return dp[mouse[0]][mouse[1]][cat[0]][cat[1]][1] if dp[mouse[1]][mouse[1]][cat[0]][cat[1]][1] is not None else False"
    }
  ]
}