{
  "task_id": "cf_85887",
  "entry_point": "minBuildTime",
  "mutant_count": 74,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] / (n + 1) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] / (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] + (n + 1) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] + (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] ** (n + 1) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] ** (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n + 1, -1, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n * 1, -1, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n * 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, +1, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, +1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, +1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, +1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "blocks.sort(reverse=True)",
      "mutated_line": "blocks.sort(reverse=False)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=False)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n - 1) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n - 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n * 1) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n * 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 2, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 0, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 0, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - -1, -1, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - -1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -2, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -2, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -0, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -0, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, --1, -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, --1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -2):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -2):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -0):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -0):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, --1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, --1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n - 1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n * 1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n * 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if j >= i:",
      "mutated_line": "if j > i:",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j > i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if j >= i:",
      "mutated_line": "if j < i:",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j < i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if j >= i:",
      "mutated_line": "if j == i:",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j == i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] - j * split for j in range(maxSplit + 1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] - j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] * (j * split) for j in range(maxSplit + 1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] * (j * split) for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[1] * (n + 1) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[1] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[1] * (n + 1) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[1] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n + 2) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 2) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n + 0) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 0) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n + 0) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 0) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n + -1) for _ in range(n + 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + -1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(n - 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n - 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(n * 1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n * 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n + 2):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 2):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n + 0):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 0):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n + 0):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 0):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n + -1):",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + -1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] + j / split for j in range(maxSplit + 1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j / split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] + (j + split) for j in range(maxSplit + 1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + (j + split) for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] + j ** split for j in range(maxSplit + 1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j ** split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(n + 2)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 2)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(n + 0)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 0)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(n + 0)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 0)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[0] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[0] * (n + 1) for _ in range(n + -1)]",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + -1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] - blocks[i], dp[i][j + 1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] - blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] * blocks[i], dp[i][j + 1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] * blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] - split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] - split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] * split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] * split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] + j * split for j in range(maxSplit - 1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] + j * split for j in range(maxSplit * 1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit * 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[1][j] + j * split for j in range(maxSplit + 1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[1][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[-1][j] + j * split for j in range(maxSplit + 1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[-1][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[1][j] + j * split for j in range(maxSplit + 1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[1][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] + j * split for j in range(maxSplit + 2)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 2)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] + j * split for j in range(maxSplit + 0)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 0)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] + j * split for j in range(maxSplit + 0)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 0)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(dp[0][j] + j * split for j in range(maxSplit + 1))",
      "mutated_line": "return min((dp[0][j] + j * split for j in range(maxSplit + -1)))",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + -1)))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j - 1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j - 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j * 1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j * 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i - 1][j] + blocks[i], dp[i][j + 1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i - 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i * 1][j] + blocks[i], dp[i][j + 1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i * 1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 2] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 2] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 0] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 0] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 0] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 0] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + -1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + -1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 2][j] + blocks[i], dp[i][j + 1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 2][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 0][j] + blocks[i], dp[i][j + 1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 0][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + 0][j] + blocks[i], dp[i][j + 1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + 0][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i][j] = min(dp[i + 1][j] + blocks[i], dp[i][j + 1] + split)",
      "mutated_line": "dp[i][j] = min(dp[i + -1][j] + blocks[i], dp[i][j + 1] + split)",
      "code": "import heapq\n\ndef minBuildTime(blocks, split, maxSplit):\n    n = len(blocks)\n    blocks.sort(reverse=True)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = blocks[i]\n            else:\n                dp[i][j] = min(dp[i + -1][j] + blocks[i], dp[i][j + 1] + split)\n    return min((dp[0][j] + j * split for j in range(maxSplit + 1)))"
    }
  ]
}