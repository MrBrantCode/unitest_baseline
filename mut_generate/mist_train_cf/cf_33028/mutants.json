{
  "task_id": "cf_33028",
  "entry_point": "calculate_similarity_matrix",
  "mutant_count": 105,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(input_bboxes) > keep_top_k:",
      "mutated_line": "if len(input_bboxes) >= keep_top_k:",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) >= keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(input_bboxes) > keep_top_k:",
      "mutated_line": "if len(input_bboxes) <= keep_top_k:",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) <= keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(input_bboxes) > keep_top_k:",
      "mutated_line": "if len(input_bboxes) != keep_top_k:",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) != keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) / max(0, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) / max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) + max(0, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) + max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) ** max(0, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) ** max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) / (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) / (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = box1[2] - box1[0] + (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = box1[2] - box1[0] + (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) ** (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) ** (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) / (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) / (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = box2[2] - box2[0] + (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = box2[2] - box2[0] + (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) ** (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) ** (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "union = area1 + area2 - intersection",
      "mutated_line": "union = area1 + area2 + intersection",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 + intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "union = area1 + area2 - intersection",
      "mutated_line": "union = (area1 + area2) * intersection",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = (area1 + area2) * intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return intersection / union",
      "mutated_line": "return intersection * union",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection * union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return intersection / union",
      "mutated_line": "return intersection // union",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection // union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] + box1[0]) * (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] + box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = box1[2] * box1[0] * (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = box1[2] * box1[0] * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] + box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] + box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] * box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] * box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] + box2[0]) * (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] + box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = box2[2] * box2[0] * (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = box2[2] * box2[0] * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] + box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] + box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] * box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] * box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "union = area1 + area2 - intersection",
      "mutated_line": "union = area1 - area2 - intersection",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 - area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "union = area1 + area2 - intersection",
      "mutated_line": "union = area1 * area2 - intersection",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 * area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "indices = np.argsort(-input_scores)[:keep_top_k]",
      "mutated_line": "indices = np.argsort(+input_scores)[:keep_top_k]",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(+input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[1], box2[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[1], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[-1], box2[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[-1], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[1], box2[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[1], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[0], box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[1])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[0], box2[-1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[-1])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[0], box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[1])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[2], box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[2], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[0], box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[0], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[0], box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[0], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[-1], box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[-1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[1], box2[2])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[2])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[1], box2[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[0])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[1], box2[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[0])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[1], box2[-1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[-1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[3], box2[2])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[3], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[1], box2[2])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[1], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[0], box2[2])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[0], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[1], box2[2])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[1], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[-2], box2[2])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[-2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[2], box2[3])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[3])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[2], box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[1])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[2], box2[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[0])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[2], box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[1])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[2], box2[-2])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[-2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[4], box2[3])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[4], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[2], box2[3])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[2], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[0], box2[3])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[0], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[1], box2[3])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[1], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[-3], box2[3])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[-3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[3], box2[4])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[4])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[3], box2[2])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[2])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[3], box2[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[0])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[3], box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[1])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[3], box2[-3])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[-3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(1, x2 - x1) * max(0, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(1, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(-1, x2 - x1) * max(0, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(-1, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(1, x2 - x1) * max(0, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(1, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 + x1) * max(0, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 + x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 * x1) * max(0, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 * x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) * max(1, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(1, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) * max(-1, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(-1, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) * max(1, y2 - y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(1, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) * max(0, y2 + y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 + y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) * max(0, y2 * y1)",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 * y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[3] - box1[0]) * (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[3] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[1] - box1[0]) * (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[1] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[0] - box1[0]) * (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[0] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[1] - box1[0]) * (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[1] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[-2] - box1[0]) * (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[-2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[1]) * (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[1]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[-1]) * (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[-1]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[1]) * (box1[3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[1]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[4] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[4] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[2] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[2] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[0] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[0] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[1] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[1] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[-3] - box1[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[-3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[2])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[2])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[0])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[0])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area1 = (box1[2] - box1[0]) * (box1[3] - box1[-1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[-1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[3] - box2[0]) * (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[3] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[1] - box2[0]) * (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[1] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[0] - box2[0]) * (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[0] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[1] - box2[0]) * (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[1] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[-2] - box2[0]) * (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[-2] - box2[0]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[1]) * (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[1]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[-1]) * (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[-1]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[1]) * (box2[3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[1]) * (box2[3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[4] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[4] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[2] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[2] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[0] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[0] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[1] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[1] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[-3] - box2[1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[-3] - box2[1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[2])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[2])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[0])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[0])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[0])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area2 = (box2[2] - box2[0]) * (box2[3] - box2[-1])",
      "code": "import numpy as np\n\ndef calculate_similarity_matrix(input_scores, input_bboxes, keep_top_k):\n    if len(input_bboxes) > keep_top_k:\n        indices = np.argsort(-input_scores)[:keep_top_k]\n        scores = input_scores[indices]\n        bboxes = input_bboxes[indices]\n    else:\n        scores = np.copy(input_scores)\n        indices = np.arange(len(scores))\n        bboxes = input_bboxes\n\n    def calculate_iou(box1, box2):\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area2 = (box2[2] - box2[0]) * (box2[3] - box2[-1])\n        union = area1 + area2 - intersection\n        return intersection / union\n    similarity_matrix = np.zeros((len(bboxes), len(bboxes)))\n    for i in range(len(bboxes)):\n        for j in range(len(bboxes)):\n            similarity_matrix[i, j] = calculate_iou(bboxes[i], bboxes[j])\n    return similarity_matrix"
    }
  ]
}