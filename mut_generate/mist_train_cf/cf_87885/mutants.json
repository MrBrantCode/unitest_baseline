{
  "task_id": "cf_87885",
  "entry_point": "get_combinations",
  "mutant_count": 25,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if remaining_length == 0:",
      "mutated_line": "if remaining_length != 0:",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length != 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "counter[char] -= 1",
      "mutated_line": "counter[char] += 1",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] += 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "counter[char] += 1",
      "mutated_line": "counter[char] -= 1",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] -= 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if remaining_length == 0:",
      "mutated_line": "if remaining_length == 1:",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 1:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if remaining_length == 0:",
      "mutated_line": "if remaining_length == -1:",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == -1:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if remaining_length == 0:",
      "mutated_line": "if remaining_length == 1:",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 1:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if counter[char] == 0:",
      "mutated_line": "if counter[char] != 0:",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] != 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "counter[char] -= 1",
      "mutated_line": "counter[char] -= 2",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 2\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "counter[char] -= 1",
      "mutated_line": "counter[char] -= 0",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 0\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "counter[char] -= 1",
      "mutated_line": "counter[char] -= 0",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 0\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "counter[char] -= 1",
      "mutated_line": "counter[char] -= -1",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= -1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "counter[char] += 1",
      "mutated_line": "counter[char] += 2",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 2\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "counter[char] += 1",
      "mutated_line": "counter[char] += 0",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 0\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "counter[char] += 1",
      "mutated_line": "counter[char] += 0",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 0\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "counter[char] += 1",
      "mutated_line": "counter[char] += -1",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += -1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if counter[char] == 0:",
      "mutated_line": "if counter[char] == 1:",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 1:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if counter[char] == 0:",
      "mutated_line": "if counter[char] == -1:",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == -1:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if counter[char] == 0:",
      "mutated_line": "if counter[char] == 1:",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 1:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "backtrack(current_combination, remaining_chars, remaining_length - 1)",
      "mutated_line": "backtrack(current_combination, remaining_chars, remaining_length + 1)",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length + 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "backtrack(current_combination, remaining_chars, remaining_length - 1)",
      "mutated_line": "backtrack(current_combination, remaining_chars, remaining_length * 1)",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length * 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "backtrack(current_combination, remaining_chars, remaining_length - 1)",
      "mutated_line": "backtrack(current_combination, remaining_chars, remaining_length - 2)",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 2)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "backtrack(current_combination, remaining_chars, remaining_length - 1)",
      "mutated_line": "backtrack(current_combination, remaining_chars, remaining_length - 0)",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 0)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "backtrack(current_combination, remaining_chars, remaining_length - 1)",
      "mutated_line": "backtrack(current_combination, remaining_chars, remaining_length - 0)",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 0)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "backtrack(current_combination, remaining_chars, remaining_length - 1)",
      "mutated_line": "backtrack(current_combination, remaining_chars, remaining_length - -1)",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append(''.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - -1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "combinations.append(\"\".join(current_combination))",
      "mutated_line": "combinations.append('MUTATED'.join(current_combination))",
      "code": "from collections import Counter\n\ndef get_combinations(string, n):\n    counter = Counter(string)\n    unique_chars = sorted(set(string))\n    combinations = []\n\n    def backtrack(current_combination, remaining_chars, remaining_length):\n        if remaining_length == 0:\n            combinations.append('MUTATED'.join(current_combination))\n            return\n        for char in remaining_chars:\n            if counter[char] == 0:\n                continue\n            current_combination.append(char)\n            counter[char] -= 1\n            backtrack(current_combination, remaining_chars, remaining_length - 1)\n            current_combination.pop()\n            counter[char] += 1\n    backtrack([], unique_chars, n)\n    return combinations"
    }
  ]
}