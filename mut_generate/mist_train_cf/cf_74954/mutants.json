{
  "task_id": "cf_74954",
  "entry_point": "convert_number",
  "mutant_count": 156,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if conversion_type == 'int_to_roman':",
      "mutated_line": "if conversion_type != 'int_to_roman':",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type != 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, '': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, '': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, '': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, '': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, '': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, '': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, '': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, '': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, '': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, '': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, '': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, '': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 2, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 0, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 0, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': -1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 5, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 3, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 0, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 1, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': -4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 6, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 4, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 0, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 1, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': -5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 10, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 8, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 0, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 1, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': -9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 11, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 9, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 0, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 1, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': -10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 41, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 39, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 0, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 1, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': -40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 51, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 49, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 0, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 1, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50,",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': -50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 91, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 89, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 0, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 1, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': -90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 101, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 99, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 0, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 1, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': -100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 401, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 399, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 0, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 1, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': -400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 501, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 499, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 0, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 1, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': -500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 901, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 899, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 0, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 1, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': -900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1001}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 999}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 0}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000",
      "mutated_line": "int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': -1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if conversion_type == 'int_to_roman':",
      "mutated_line": "if conversion_type == '':",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == '':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) and number < 1 and (number > 1000):",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) and number < 1 and (number > 1000):\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "result = ''",
      "mutated_line": "result = 'MUTATED'",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = 'MUTATED'\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif conversion_type == 'roman_to_int':",
      "mutated_line": "elif conversion_type != 'roman_to_int':",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type != 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)",
      "mutated_line": "descending_values = sorted(int_to_roman_mapping.keys(), reverse=False)",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=False)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number <= 1 or number > 1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number <= 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number >= 1 or number > 1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number >= 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number != 1 or number > 1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number != 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 1 or number >= 1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number >= 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 1 or number <= 1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number <= 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 1 or number != 1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number != 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 'Invalid number. Input should be an integer between 1 and 1000.'",
      "mutated_line": "return ''",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return ''\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while number >= value:",
      "mutated_line": "while number > value:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number > value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while number >= value:",
      "mutated_line": "while number < value:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number < value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while number >= value:",
      "mutated_line": "while number == value:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number == value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "number -= value",
      "mutated_line": "number += value",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number += value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "result += int_to_roman_mapping[value]",
      "mutated_line": "result -= int_to_roman_mapping[value]",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result -= int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif conversion_type == 'roman_to_int':",
      "mutated_line": "elif conversion_type == '':",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == '':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 1\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "result = 0",
      "mutated_line": "result = -1",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = -1\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 1\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 1\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = -1\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 1\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while i < len(number):",
      "mutated_line": "while i <= len(number):",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i <= len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while i < len(number):",
      "mutated_line": "while i >= len(number):",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i >= len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while i < len(number):",
      "mutated_line": "while i != len(number):",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i != len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'",
      "mutated_line": "return ''",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 2 or number > 1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 2 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 0 or number > 1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 0 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 0 or number > 1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 0 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < -1 or number > 1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < -1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 1 or number > 1001:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1001:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 1 or number > 999:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 999:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 1 or number > 0:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 0:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 1 or number > 1:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not isinstance(number, int) or number < 1 or number > 1000:",
      "mutated_line": "if not isinstance(number, int) or number < 1 or number > -1000:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > -1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return 'Invalid number. Input should be a string.'",
      "mutated_line": "return ''",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return ''\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 < len(number) or number[i:i + 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) or number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "result += roman_to_int_mapping[number[i:i+2].lower()]",
      "mutated_line": "result -= roman_to_int_mapping[number[i:i + 2].lower()]",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result -= roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "i += 2",
      "mutated_line": "i -= 2",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i -= 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 <= len(number) and number[i:i + 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 <= len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 >= len(number) and number[i:i + 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 >= len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 != len(number) and number[i:i + 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 != len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 < len(number) and number[i:i + 2].lower() not in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() not in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i += 2",
      "mutated_line": "i += 3",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 3\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i += 2",
      "mutated_line": "i += 1",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 1\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i += 2",
      "mutated_line": "i += 0",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 0\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i += 2",
      "mutated_line": "i += 1",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 1\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i += 2",
      "mutated_line": "i += -2",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += -2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif number[i].lower() in roman_to_int_mapping:",
      "mutated_line": "elif number[i].lower() not in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() not in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "result += roman_to_int_mapping[number[i].lower()]",
      "mutated_line": "result -= roman_to_int_mapping[number[i].lower()]",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result -= roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i -= 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i - 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i - 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i * 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i * 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 2\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 0\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 0\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += -1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 'Invalid roman numeral.'",
      "mutated_line": "return ''",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return ''\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 2 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 2 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 0 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 0 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 0 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 0 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + -1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + -1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 < len(number) and number[i:i - 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i - 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 < len(number) and number[i:i * 2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i * 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "result += roman_to_int_mapping[number[i:i+2].lower()]",
      "mutated_line": "result += roman_to_int_mapping[number[i:i - 2].lower()]",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i - 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "result += roman_to_int_mapping[number[i:i+2].lower()]",
      "mutated_line": "result += roman_to_int_mapping[number[i:i * 2].lower()]",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i * 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 < len(number) and number[i:i + 3].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 3].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 < len(number) and number[i:i + 1].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 1].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 < len(number) and number[i:i + 0].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 0].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 < len(number) and number[i:i + 1].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 1].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if (i+1) < len(number) and number[i:i+2].lower() in roman_to_int_mapping:",
      "mutated_line": "if i + 1 < len(number) and number[i:i + -2].lower() in roman_to_int_mapping:",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + -2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result += roman_to_int_mapping[number[i:i+2].lower()]",
      "mutated_line": "result += roman_to_int_mapping[number[i:i + 3].lower()]",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 3].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result += roman_to_int_mapping[number[i:i+2].lower()]",
      "mutated_line": "result += roman_to_int_mapping[number[i:i + 1].lower()]",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 1].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result += roman_to_int_mapping[number[i:i+2].lower()]",
      "mutated_line": "result += roman_to_int_mapping[number[i:i + 0].lower()]",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 0].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result += roman_to_int_mapping[number[i:i+2].lower()]",
      "mutated_line": "result += roman_to_int_mapping[number[i:i + 1].lower()]",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + 1].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "result += roman_to_int_mapping[number[i:i+2].lower()]",
      "mutated_line": "result += roman_to_int_mapping[number[i:i + -2].lower()]",
      "code": "def convert_number(number, conversion_type):\n    roman_to_int_mapping = {'i': 1, 'iv': 4, 'v': 5, 'ix': 9, 'x': 10, 'xl': 40, 'l': 50, 'xc': 90, 'c': 100, 'cd': 400, 'd': 500, 'cm': 900, 'm': 1000}\n    int_to_roman_mapping = {value: key for (key, value) in roman_to_int_mapping.items()}\n    descending_values = sorted(int_to_roman_mapping.keys(), reverse=True)\n    if conversion_type == 'int_to_roman':\n        if not isinstance(number, int) or number < 1 or number > 1000:\n            return 'Invalid number. Input should be an integer between 1 and 1000.'\n        result = ''\n        for value in descending_values:\n            while number >= value:\n                number -= value\n                result += int_to_roman_mapping[value]\n        return result.lower()\n    elif conversion_type == 'roman_to_int':\n        if not isinstance(number, str):\n            return 'Invalid number. Input should be a string.'\n        result = 0\n        i = 0\n        while i < len(number):\n            if i + 1 < len(number) and number[i:i + 2].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i:i + -2].lower()]\n                i += 2\n            elif number[i].lower() in roman_to_int_mapping:\n                result += roman_to_int_mapping[number[i].lower()]\n                i += 1\n            else:\n                return 'Invalid roman numeral.'\n        return result\n    else:\n        return 'Invalid conversion_type. Options: int_to_roman or roman_to_int'"
    }
  ]
}