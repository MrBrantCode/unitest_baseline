{
  "task_id": "cf_94618",
  "entry_point": "findMaxOverlap",
  "mutant_count": 61,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maxOverlap = 0",
      "mutated_line": "maxOverlap = 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 1\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maxOverlap = 0",
      "mutated_line": "maxOverlap = -1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = -1\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maxOverlap = 0",
      "mutated_line": "maxOverlap = 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 1\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, len(sortedIntervals)):",
      "mutated_line": "for i in range(2, len(sortedIntervals)):",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(2, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, len(sortedIntervals)):",
      "mutated_line": "for i in range(0, len(sortedIntervals)):",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(0, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, len(sortedIntervals)):",
      "mutated_line": "for i in range(0, len(sortedIntervals)):",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(0, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, len(sortedIntervals)):",
      "mutated_line": "for i in range(-1, len(sortedIntervals)):",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(-1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if currentInterval[0] > topInterval[1]:",
      "mutated_line": "if currentInterval[0] >= topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] >= topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if currentInterval[0] > topInterval[1]:",
      "mutated_line": "if currentInterval[0] <= topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] <= topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if currentInterval[0] > topInterval[1]:",
      "mutated_line": "if currentInterval[0] != topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] != topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "stack.append(sortedIntervals[0])",
      "mutated_line": "stack.append(sortedIntervals[1])",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[1])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "stack.append(sortedIntervals[0])",
      "mutated_line": "stack.append(sortedIntervals[-1])",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[-1])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "stack.append(sortedIntervals[0])",
      "mutated_line": "stack.append(sortedIntervals[1])",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[1])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "topInterval = stack[-1]",
      "mutated_line": "topInterval = stack[+1]",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[+1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[1] < topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] < topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[1] > topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] > topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[1] == topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] == topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "topInterval = stack[-1]",
      "mutated_line": "topInterval = stack[-2]",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-2]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "topInterval = stack[-1]",
      "mutated_line": "topInterval = stack[-0]",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-0]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "topInterval = stack[-1]",
      "mutated_line": "topInterval = stack[-0]",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-0]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "topInterval = stack[-1]",
      "mutated_line": "topInterval = stack[--1]",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[--1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if currentInterval[0] > topInterval[1]:",
      "mutated_line": "if currentInterval[1] > topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[1] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if currentInterval[0] > topInterval[1]:",
      "mutated_line": "if currentInterval[-1] > topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[-1] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if currentInterval[0] > topInterval[1]:",
      "mutated_line": "if currentInterval[1] > topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[1] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if currentInterval[0] > topInterval[1]:",
      "mutated_line": "if currentInterval[0] > topInterval[2]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[2]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if currentInterval[0] > topInterval[1]:",
      "mutated_line": "if currentInterval[0] > topInterval[0]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[0]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if currentInterval[0] > topInterval[1]:",
      "mutated_line": "if currentInterval[0] > topInterval[0]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[0]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if currentInterval[0] > topInterval[1]:",
      "mutated_line": "if currentInterval[0] > topInterval[-1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[-1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[1] - currentInterval[0] - 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] - 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = (topInterval[1] - currentInterval[0]) * 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = (topInterval[1] - currentInterval[0]) * 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if overlap > maxOverlap:",
      "mutated_line": "if overlap >= maxOverlap:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap >= maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if overlap > maxOverlap:",
      "mutated_line": "if overlap <= maxOverlap:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap <= maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if overlap > maxOverlap:",
      "mutated_line": "if overlap != maxOverlap:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap != maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[2] <= topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[2] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[0] <= topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[0] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[0] <= topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[0] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[-1] <= topInterval[1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[-1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[1] <= topInterval[2]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[2]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[1] <= topInterval[0]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[0]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[1] <= topInterval[0]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[0]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif currentInterval[1] <= topInterval[1]:",
      "mutated_line": "elif currentInterval[1] <= topInterval[-1]:",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[-1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[1] + currentInterval[0] + 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] + currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[1] * currentInterval[0] + 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] * currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[1] - currentInterval[0] + 2",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 2\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[1] - currentInterval[0] + 0",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 0\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[1] - currentInterval[0] + 0",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 0\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[1] - currentInterval[0] + -1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + -1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))",
      "mutated_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[1], x[1]))",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[1], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))",
      "mutated_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[-1], x[1]))",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[-1], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))",
      "mutated_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[1], x[1]))",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[1], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))",
      "mutated_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[2]))",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[2]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))",
      "mutated_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[0]))",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[0]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))",
      "mutated_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[0]))",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[0]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))",
      "mutated_line": "sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[-1]))",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[-1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[2] - currentInterval[0] + 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[2] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[0] - currentInterval[0] + 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[0] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[0] - currentInterval[0] + 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[0] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[-1] - currentInterval[0] + 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[-1] - currentInterval[0] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[1] - currentInterval[1] + 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[1] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[1] - currentInterval[-1] + 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[-1] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "overlap = topInterval[1] - currentInterval[0] + 1",
      "mutated_line": "overlap = topInterval[1] - currentInterval[1] + 1",
      "code": "def findMaxOverlap(intervals):\n    sortedIntervals = sorted(intervals, key=lambda x: (x[0], x[1]))\n    maxOverlap = 0\n    maxOverlapIntervals = []\n    stack = []\n    stack.append(sortedIntervals[0])\n    for i in range(1, len(sortedIntervals)):\n        currentInterval = sortedIntervals[i]\n        topInterval = stack[-1]\n        if currentInterval[0] > topInterval[1]:\n            stack.append(currentInterval)\n        elif currentInterval[1] <= topInterval[1]:\n            stack.pop()\n            stack.append(currentInterval)\n        else:\n            overlap = topInterval[1] - currentInterval[1] + 1\n            if overlap > maxOverlap:\n                maxOverlap = overlap\n                maxOverlapIntervals = [topInterval, currentInterval]\n    return (maxOverlap, maxOverlapIntervals)"
    }
  ]
}