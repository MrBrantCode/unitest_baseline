{
  "task_id": "cf_84868",
  "entry_point": "non_identical_frequency",
  "mutant_count": 17,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if k in counter_t1 and k in counter_t2:",
      "mutated_line": "if k in counter_t1 or k in counter_t2:",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 or k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if k in counter_t1 and k in counter_t2:",
      "mutated_line": "if k not in counter_t1 and k in counter_t2:",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k not in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if k in counter_t1 and k in counter_t2:",
      "mutated_line": "if k in counter_t1 and k not in counter_t2:",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k not in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if counter_t1[k] != counter_t2[k]:",
      "mutated_line": "if counter_t1[k] == counter_t2[k]:",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] == counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif k in counter_t1:",
      "mutated_line": "elif k not in counter_t1:",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k not in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], \"both\")",
      "mutated_line": "non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], '')",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], '')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "non_identical_dict[k] = ([counter_t1[k], 0], \"tuple1\")",
      "mutated_line": "non_identical_dict[k] = ([counter_t1[k], 0], '')",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], '')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "non_identical_dict[k] = ([0, counter_t2[k]], \"tuple2\")",
      "mutated_line": "non_identical_dict[k] = ([0, counter_t2[k]], '')",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], '')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "non_identical_dict[k] = ([counter_t1[k], 0], \"tuple1\")",
      "mutated_line": "non_identical_dict[k] = ([counter_t1[k], 1], 'tuple1')",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 1], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "non_identical_dict[k] = ([counter_t1[k], 0], \"tuple1\")",
      "mutated_line": "non_identical_dict[k] = ([counter_t1[k], -1], 'tuple1')",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], -1], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "non_identical_dict[k] = ([counter_t1[k], 0], \"tuple1\")",
      "mutated_line": "non_identical_dict[k] = ([counter_t1[k], 1], 'tuple1')",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 1], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "non_identical_dict[k] = ([0, counter_t2[k]], \"tuple2\")",
      "mutated_line": "non_identical_dict[k] = ([1, counter_t2[k]], 'tuple2')",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([1, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "non_identical_dict[k] = ([0, counter_t2[k]], \"tuple2\")",
      "mutated_line": "non_identical_dict[k] = ([-1, counter_t2[k]], 'tuple2')",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([-1, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "non_identical_dict[k] = ([0, counter_t2[k]], \"tuple2\")",
      "mutated_line": "non_identical_dict[k] = ([1, counter_t2[k]], 'tuple2')",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([1, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)",
      "mutated_line": "flat_list.append('anonymous_function' if elem.__name__ != '<lambda>' else elem.__name__)",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ != '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)",
      "mutated_line": "flat_list.append('' if elem.__name__ == '<lambda>' else elem.__name__)",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('' if elem.__name__ == '<lambda>' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flat_list.append('anonymous_function' if elem.__name__ == '<lambda>' else elem.__name__)",
      "mutated_line": "flat_list.append('anonymous_function' if elem.__name__ == '' else elem.__name__)",
      "code": "from collections import Counter\nfrom itertools import chain\nimport types\n\ndef non_identical_frequency(t1, t2):\n\n    def flatten_tuple(t):\n        flat_list = []\n        for elem in t:\n            if isinstance(elem, (tuple, list, set)):\n                flat_list.extend(flatten_tuple(elem))\n            elif isinstance(elem, dict):\n                flat_list.extend(flatten_tuple(list(elem.items())))\n            elif isinstance(elem, types.FunctionType):\n                flat_list.append('anonymous_function' if elem.__name__ == '' else elem.__name__)\n            else:\n                flat_list.append(elem)\n        return flat_list\n    flat_t1 = flatten_tuple(t1)\n    flat_t2 = flatten_tuple(t2)\n    counter_t1 = Counter(flat_t1)\n    counter_t2 = Counter(flat_t2)\n    non_identical_dict = {}\n    for k in set(chain(counter_t1.keys(), counter_t2.keys())):\n        if k in counter_t1 and k in counter_t2:\n            if counter_t1[k] != counter_t2[k]:\n                non_identical_dict[k] = ([counter_t1[k], counter_t2[k]], 'both')\n        elif k in counter_t1:\n            non_identical_dict[k] = ([counter_t1[k], 0], 'tuple1')\n        else:\n            non_identical_dict[k] = ([0, counter_t2[k]], 'tuple2')\n    return non_identical_dict"
    }
  ]
}