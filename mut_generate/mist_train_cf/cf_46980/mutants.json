{
  "task_id": "cf_46980",
  "entry_point": "can_be_sorted",
  "mutant_count": 185,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "decrease_count = 0",
      "mutated_line": "decrease_count = 1",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 1\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "decrease_count = 0",
      "mutated_line": "decrease_count = -1",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = -1\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "decrease_count = 0",
      "mutated_line": "decrease_count = 1",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 1\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if decrease_count == 0:",
      "mutated_line": "if decrease_count != 0:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count != 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(len(numbers)-1):",
      "mutated_line": "for i in range(len(numbers) + 1):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) + 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(len(numbers)-1):",
      "mutated_line": "for i in range(len(numbers) * 1):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) * 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if numbers[i] > numbers[i+1]:",
      "mutated_line": "if numbers[i] >= numbers[i + 1]:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] >= numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if numbers[i] > numbers[i+1]:",
      "mutated_line": "if numbers[i] <= numbers[i + 1]:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] <= numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if numbers[i] > numbers[i+1]:",
      "mutated_line": "if numbers[i] != numbers[i + 1]:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] != numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "decrease_count += 1",
      "mutated_line": "decrease_count -= 1",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count -= 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if decrease_count == 0:",
      "mutated_line": "if decrease_count == 1:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 1:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if decrease_count == 0:",
      "mutated_line": "if decrease_count == -1:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == -1:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if decrease_count == 0:",
      "mutated_line": "if decrease_count == 1:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 1:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return False\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif decrease_count == 1:",
      "mutated_line": "elif decrease_count != 1:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count != 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(len(numbers)-1):",
      "mutated_line": "for i in range(len(numbers) - 2):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 2):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(len(numbers)-1):",
      "mutated_line": "for i in range(len(numbers) - 0):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 0):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(len(numbers)-1):",
      "mutated_line": "for i in range(len(numbers) - 0):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 0):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(len(numbers)-1):",
      "mutated_line": "for i in range(len(numbers) - -1):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - -1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "decrease_count += 1",
      "mutated_line": "decrease_count += 2",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 2\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "decrease_count += 1",
      "mutated_line": "decrease_count += 0",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 0\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "decrease_count += 1",
      "mutated_line": "decrease_count += 0",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 0\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "decrease_count += 1",
      "mutated_line": "decrease_count += -1",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += -1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif decrease_count == 1:",
      "mutated_line": "elif decrease_count == 2:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 2:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif decrease_count == 1:",
      "mutated_line": "elif decrease_count == 0:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 0:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif decrease_count == 1:",
      "mutated_line": "elif decrease_count == 0:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 0:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif decrease_count == 1:",
      "mutated_line": "elif decrease_count == -1:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == -1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1]) and (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1]) and (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif decrease_count == 2:",
      "mutated_line": "elif decrease_count != 2:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count != 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if numbers[i] > numbers[i+1]:",
      "mutated_line": "if numbers[i] > numbers[i - 1]:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i - 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if numbers[i] > numbers[i+1]:",
      "mutated_line": "if numbers[i] > numbers[i * 1]:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i * 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if (index[0] > 0 or numbers[index[0] - 1] <= numbers[index[0] + 1]) or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if (index[0] > 0 or numbers[index[0] - 1] <= numbers[index[0] + 1]) or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 or numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 or numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return False\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif decrease_count == 2:",
      "mutated_line": "elif decrease_count == 3:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 3:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif decrease_count == 2:",
      "mutated_line": "elif decrease_count == 1:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 1:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif decrease_count == 2:",
      "mutated_line": "elif decrease_count == 0:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 0:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif decrease_count == 2:",
      "mutated_line": "elif decrease_count == 1:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 1:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif decrease_count == 2:",
      "mutated_line": "elif decrease_count == -2:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == -2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] == index[0] + 1 or (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 or (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if numbers[i] > numbers[i+1]:",
      "mutated_line": "if numbers[i] > numbers[i + 2]:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 2]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if numbers[i] > numbers[i+1]:",
      "mutated_line": "if numbers[i] > numbers[i + 0]:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 0]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if numbers[i] > numbers[i+1]:",
      "mutated_line": "if numbers[i] > numbers[i + 0]:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 0]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if numbers[i] > numbers[i+1]:",
      "mutated_line": "if numbers[i] > numbers[i + -1]:",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + -1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] >= 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] >= 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] <= 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] <= 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] != 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] != 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] < numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] < numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] > numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] > numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] == numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] == numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] <= len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] <= len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] >= len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] >= len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] != len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] != len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] < numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] < numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] > numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] > numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] == numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] == numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] != index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] != index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and ((index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1]) and (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and ((index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1]) and (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return False\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 1 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 1 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > -1 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > -1 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 1 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 1 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) + 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) + 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) * 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) * 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] == index[0] - 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] - 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] == index[0] * 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] * 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and ((index[0] > 0 or numbers[index[0] - 1] <= numbers[index[1] + 1]) or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and ((index[0] > 0 or numbers[index[0] - 1] <= numbers[index[1] + 1]) or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 or numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 or numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[1] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[1] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[-1] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[-1] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[1] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[1] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] + 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] + 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] * 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] * 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] - 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] - 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] * 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] * 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[-1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[-1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 3 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 3 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 1 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 1 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 0 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 0 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 1 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 1 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - -2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - -2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] - 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] - 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] * 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] * 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[2] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[2] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[0] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[0] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[0] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[0] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[-1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[-1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] == index[0] + 2 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 2 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] == index[0] + 0 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 0 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] == index[0] + 0 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 0 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] == index[0] + -1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + -1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] >= 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] >= 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] <= 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] <= 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] != 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] != 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] < numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] < numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] > numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] > numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] == numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] == numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] <= len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] <= len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] >= len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] >= len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] != len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] != len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] < numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] < numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] > numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] > numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] == numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] == numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 2] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 2] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 0] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 0] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 0] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 0] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - -1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - -1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 2] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 2] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 0] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 0] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 0] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 0] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + -1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + -1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[1]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[1]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[-1]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[-1]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[1]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[1]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 3]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 3]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 1]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 1]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 0]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 0]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 1]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 1]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + -2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + -2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] == index[1] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[1] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] == index[-1] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[-1] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if index[1] == index[0]+1 and\\",
      "mutated_line": "if index[1] == index[1] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[1] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 1 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 1 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > -1 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > -1 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 1 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 1 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) + 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) + 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) * 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) * 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[1] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[1] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[-1] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[-1] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[1] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[1] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[-1] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[-1] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if (index[0] > 0 and numbers[index[0]-1] <= numbers[index[0]+1]) or\\",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[-1] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[-1] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(index[0] < len(numbers)-2 and numbers[index[0]] <= numbers[index[0]+2]):",
      "mutated_line": "if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2]):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[1] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[1] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[-1] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[-1] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[1] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[1] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] + 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] + 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] * 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] * 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] - 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] - 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] * 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] * 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[2] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[2] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[-1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[-1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 3 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 3 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 1 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 1 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 0 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 0 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 1 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 1 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - -2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - -2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] - 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] - 2])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] * 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] * 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 2] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 2] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 0] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 0] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 0] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 0] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - -1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - -1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 2] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 2] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 0] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 0] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 0] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 0] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + -1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + -1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[1]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[1]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[-1]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[-1]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[1]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[1]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 3])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 3])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 1])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 1])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 0])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 0])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 1])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 1])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + -2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + -2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[1] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[1] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[-1] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[-1] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[1] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[1] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[2] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[2] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "((index[0] >0 and numbers[index[0]-1] <= numbers[index[1]+1]) or\\",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[-1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[-1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[2] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[2] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[1]+2])):",
      "mutated_line": "if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[-1] + 2])):",
      "code": "def can_be_sorted(numbers: list):\n    \"\"\"\n    Returns True if it's possible to sort the numbers list by:\n    - reversing any sublist indefinitely, \n    - discarding a single element from the list\n    - performing a one-time swap operation on any two elements\n    \"\"\"\n    decrease_count = 0\n    index = []\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            decrease_count += 1\n            index.append(i)\n    if decrease_count == 0:\n        return True\n    elif decrease_count == 1:\n        if index[0] > 0 and numbers[index[0] - 1] <= numbers[index[0] + 1] or (index[0] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[0] + 2]):\n            return True\n    elif decrease_count == 2:\n        if index[1] == index[0] + 1 and (index[0] > 0 and numbers[index[0] - 1] <= numbers[index[1] + 1] or (index[1] < len(numbers) - 2 and numbers[index[0]] <= numbers[index[-1] + 2])):\n            return True\n    return False"
    }
  ]
}