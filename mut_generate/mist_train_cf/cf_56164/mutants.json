{
  "task_id": "cf_56164",
  "entry_point": "shortest_path",
  "mutant_count": 14,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\"\"\"\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 1\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = -1",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = -1\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 1\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if current == end:",
      "mutated_line": "if current != end:",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current != end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(1, start)]",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(1, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(-1, start)]",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(-1, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(1, start)]",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(1, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distances = {node: float('infinity') for node in graph}",
      "mutated_line": "distances = {node: float('') for node in graph}",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(0, start)]\n    distances = {node: float('') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_distance = dist + distance",
      "mutated_line": "new_distance = dist - distance",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist - distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_distance = dist + distance",
      "mutated_line": "new_distance = dist * distance",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist * distance\n            if new_distance < old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if new_distance < old_distance:",
      "mutated_line": "if new_distance <= old_distance:",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance <= old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if new_distance < old_distance:",
      "mutated_line": "if new_distance >= old_distance:",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance >= old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if new_distance < old_distance:",
      "mutated_line": "if new_distance != old_distance:",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function uses Dijkstra's Algorithm to find the shortest distance from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph where keys are the nodes and values are dictionaries of neighboring nodes and their respective edge weights.\n    start (node): The source node.\n    end (node): The target node.\n\n    Returns:\n    float: The shortest distance from the start node to the end node.\n    \"\"\"\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    while heap:\n        (dist, current) = heapq.heappop(heap)\n        if current == end:\n            return distances[end]\n        for (neighbor, distance) in graph[current].items():\n            old_distance = distances[neighbor]\n            new_distance = dist + distance\n            if new_distance != old_distance:\n                distances[neighbor] = new_distance\n                heapq.heappush(heap, (new_distance, neighbor))\n    return None"
    }
  ]
}