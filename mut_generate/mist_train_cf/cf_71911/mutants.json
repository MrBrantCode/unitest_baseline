{
  "task_id": "cf_71911",
  "entry_point": "beneficial_divisions",
  "mutant_count": 39,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def beneficial_divisions(s):\n    \"\"\"\"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 1\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = -1\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 1\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "right[char] -= 1",
      "mutated_line": "right[char] += 1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] += 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if char in right:",
      "mutated_line": "if char not in right:",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char not in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "right[char] += 1",
      "mutated_line": "right[char] -= 1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] -= 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if char in left:",
      "mutated_line": "if char not in left:",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char not in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "left[char] += 1",
      "mutated_line": "left[char] -= 1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] -= 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "right[char] -= 1",
      "mutated_line": "right[char] -= 2",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 2\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "right[char] -= 1",
      "mutated_line": "right[char] -= 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 0\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "right[char] -= 1",
      "mutated_line": "right[char] -= 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 0\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "right[char] -= 1",
      "mutated_line": "right[char] -= -1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= -1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right[char] == 0:",
      "mutated_line": "if right[char] != 0:",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] != 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if len(left) == len(right):",
      "mutated_line": "if len(left) != len(right):",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) != len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count -= 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right[char] += 1",
      "mutated_line": "right[char] += 2",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 2\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right[char] += 1",
      "mutated_line": "right[char] += 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 0\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right[char] += 1",
      "mutated_line": "right[char] += 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 0\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right[char] += 1",
      "mutated_line": "right[char] += -1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += -1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "right[char] = 1",
      "mutated_line": "right[char] = 2",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 2\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "right[char] = 1",
      "mutated_line": "right[char] = 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 0\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "right[char] = 1",
      "mutated_line": "right[char] = 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 0\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "right[char] = 1",
      "mutated_line": "right[char] = -1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = -1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left[char] += 1",
      "mutated_line": "left[char] += 2",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 2\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left[char] += 1",
      "mutated_line": "left[char] += 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 0\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left[char] += 1",
      "mutated_line": "left[char] += 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 0\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left[char] += 1",
      "mutated_line": "left[char] += -1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += -1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left[char] = 1",
      "mutated_line": "left[char] = 2",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 2\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left[char] = 1",
      "mutated_line": "left[char] = 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 0\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left[char] = 1",
      "mutated_line": "left[char] = 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 0\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left[char] = 1",
      "mutated_line": "left[char] = -1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = -1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if right[char] == 0:",
      "mutated_line": "if right[char] == 1:",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 1:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if right[char] == 0:",
      "mutated_line": "if right[char] == -1:",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == -1:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if right[char] == 0:",
      "mutated_line": "if right[char] == 1:",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 1:\n            del right[char]\n        if len(left) == len(right):\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 2\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def beneficial_divisions(s):\n    \"\"\"\n    Calculate the quantity of beneficial divisions that can be performed on string s.\n    \n    A division is deemed beneficial if s can be divided into two non-empty substrings \n    p and q such that their concatenation equals s and the quantity of unique characters \n    in p and q are identical, with no overlapping characters between p and q.\n\n    Args:\n    s (str): The input string containing lowercase English alphabets.\n\n    Returns:\n    int: The quantity of beneficial divisions.\n    \"\"\"\n    (left, right) = ({}, {})\n    for char in s:\n        if char in right:\n            right[char] += 1\n        else:\n            right[char] = 1\n    count = 0\n    for char in s:\n        if char in left:\n            left[char] += 1\n        else:\n            left[char] = 1\n        right[char] -= 1\n        if right[char] == 0:\n            del right[char]\n        if len(left) == len(right):\n            count += -1\n    return count"
    }
  ]
}