{
  "task_id": "cf_24903",
  "entry_point": "navigate_maze",
  "mutant_count": 73,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if current == end:",
      "mutated_line": "if current != end:",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current != end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) or 0 <= y < len(maze[0]) or maze[x][y] == 0 or ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) or 0 <= y < len(maze[0]) or maze[x][y] == 0 or ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] - direction[0], current[1] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] - direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] * direction[0], current[1] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] * direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[0], current[1] - direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] - direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[0], current[1] * direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] * direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 < x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 < x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 > x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 > x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 == x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 == x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 < y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 < y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 > y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 > y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 == y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 == y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] != 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] != 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 1 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 1 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if -1 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if -1 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 1 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 1 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 1 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 1 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and -1 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and -1 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 1 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 1 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 1) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 1) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == -1) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == -1) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 1) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 1) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "result = dfs((x, y), path + [(x, y)])",
      "mutated_line": "result = dfs((x, y), path - [(x, y)])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path - [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "result = dfs((x, y), path + [(x, y)])",
      "mutated_line": "result = dfs((x, y), path * [(x, y)])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path * [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[1] + direction[0], current[1] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[1] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[-1] + direction[0], current[1] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[-1] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[1] + direction[0], current[1] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[1] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[1], current[1] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[1], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[-1], current[1] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[-1], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[1], current[1] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[1], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[0], current[2] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[2] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[0], current[0] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[0] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[0], current[0] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[0] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[0], current[-1] + direction[1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[-1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[0], current[1] + direction[2])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[2])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[0], current[1] + direction[0])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[0])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[0], current[1] + direction[0])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[0])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x, y = current[0] + direction[0], current[1] + direction[1]",
      "mutated_line": "(x, y) = (current[0] + direction[0], current[1] + direction[-1])",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[-1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 <= y < len(maze[1]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[1]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 <= y < len(maze[-1]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[-1]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < len(maze) and 0 <= y < len(maze[1]) and (maze[x][y] == 0) and ((x, y) not in visited):",
      "code": "def navigate_maze(maze, start, end):\n    \"\"\"\n    This function navigates through a given maze from a start point to an end point.\n    \n    Args:\n    maze (list): A 2D list representing the maze. 0 indicates an open path and 1 indicates a wall.\n    start (tuple): The coordinates of the start point in the maze.\n    end (tuple): The coordinates of the end point in the maze.\n    \n    Returns:\n    list: A list of coordinates representing the path from the start to the end of the maze. If no path exists, returns None.\n    \"\"\"\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n\n    def dfs(current, path):\n        if current == end:\n            return path\n        visited.add(current)\n        for direction in directions:\n            (x, y) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= x < len(maze) and 0 <= y < len(maze[1]) and (maze[x][y] == 0) and ((x, y) not in visited):\n                result = dfs((x, y), path + [(x, y)])\n                if result:\n                    return result\n        return None\n    return dfs(start, [start])"
    }
  ]
}