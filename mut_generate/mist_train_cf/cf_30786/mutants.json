{
  "task_id": "cf_30786",
  "entry_point": "dijkstra_shortest_path",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = 1",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 1\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = -1",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = -1\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = 1",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 1\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if current_distance > distances[current_node]:",
      "mutated_line": "if current_distance >= distances[current_node]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance >= distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if current_distance > distances[current_node]:",
      "mutated_line": "if current_distance <= distances[current_node]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance <= distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if current_distance > distances[current_node]:",
      "mutated_line": "if current_distance != distances[current_node]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance != distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distances = {node: float('inf') for edge in graph for node in edge[:2]}",
      "mutated_line": "distances = {node: float('') for edge in graph for node in edge[:2]}",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(0, source)]",
      "mutated_line": "queue = [(1, source)]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(1, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(0, source)]",
      "mutated_line": "queue = [(-1, source)]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(-1, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(0, source)]",
      "mutated_line": "queue = [(1, source)]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(1, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if edge[0] == current_node:",
      "mutated_line": "if edge[0] != current_node:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] != current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "distance = current_distance + weight",
      "mutated_line": "distance = current_distance - weight",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance - weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "distance = current_distance + weight",
      "mutated_line": "distance = current_distance * weight",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance * weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance <= distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance <= distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance >= distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance >= distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance != distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance != distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distances = {node: float('inf') for edge in graph for node in edge[:2]}",
      "mutated_line": "distances = {node: float('inf') for edge in graph for node in edge[:3]}",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:3]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distances = {node: float('inf') for edge in graph for node in edge[:2]}",
      "mutated_line": "distances = {node: float('inf') for edge in graph for node in edge[:1]}",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:1]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distances = {node: float('inf') for edge in graph for node in edge[:2]}",
      "mutated_line": "distances = {node: float('inf') for edge in graph for node in edge[:0]}",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:0]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distances = {node: float('inf') for edge in graph for node in edge[:2]}",
      "mutated_line": "distances = {node: float('inf') for edge in graph for node in edge[:1]}",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:1]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distances = {node: float('inf') for edge in graph for node in edge[:2]}",
      "mutated_line": "distances = {node: float('inf') for edge in graph for node in edge[:-2]}",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:-2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if edge[0] == current_node:",
      "mutated_line": "if edge[1] == current_node:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[1] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if edge[0] == current_node:",
      "mutated_line": "if edge[-1] == current_node:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[-1] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if edge[0] == current_node:",
      "mutated_line": "if edge[1] == current_node:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[1] == current_node:\n                (neighbor, weight) = (edge[1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "neighbor, weight = edge[1], edge[2]",
      "mutated_line": "(neighbor, weight) = (edge[2], edge[2])",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[2], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "neighbor, weight = edge[1], edge[2]",
      "mutated_line": "(neighbor, weight) = (edge[0], edge[2])",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[0], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "neighbor, weight = edge[1], edge[2]",
      "mutated_line": "(neighbor, weight) = (edge[0], edge[2])",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[0], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "neighbor, weight = edge[1], edge[2]",
      "mutated_line": "(neighbor, weight) = (edge[-1], edge[2])",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[-1], edge[2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "neighbor, weight = edge[1], edge[2]",
      "mutated_line": "(neighbor, weight) = (edge[1], edge[3])",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[3])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "neighbor, weight = edge[1], edge[2]",
      "mutated_line": "(neighbor, weight) = (edge[1], edge[1])",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[1])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "neighbor, weight = edge[1], edge[2]",
      "mutated_line": "(neighbor, weight) = (edge[1], edge[0])",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[0])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "neighbor, weight = edge[1], edge[2]",
      "mutated_line": "(neighbor, weight) = (edge[1], edge[1])",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[1])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "neighbor, weight = edge[1], edge[2]",
      "mutated_line": "(neighbor, weight) = (edge[1], edge[-2])",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, source):\n    distances = {node: float('inf') for edge in graph for node in edge[:2]}\n    distances[source] = 0\n    queue = [(0, source)]\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for edge in graph:\n            if edge[0] == current_node:\n                (neighbor, weight) = (edge[1], edge[-2])\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n    return distances"
    }
  ]
}