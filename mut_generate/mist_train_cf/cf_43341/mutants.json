{
  "task_id": "cf_43341",
  "entry_point": "apply_operation",
  "mutant_count": 48,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if axis == 0:",
      "mutated_line": "if axis != 0:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis != 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if axis == 0:",
      "mutated_line": "if axis == 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 1:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if axis == 0:",
      "mutated_line": "if axis == -1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == -1:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if axis == 0:",
      "mutated_line": "if axis == 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 1:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif axis == 1:",
      "mutated_line": "elif axis != 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis != 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if i == nxp + 1:",
      "mutated_line": "if i != nxp + 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i != nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "out[i, :, :] = 1j * kx[i] * subState[i, :, :]",
      "mutated_line": "out[i, :, :] = 1j * kx[i] / subState[i, :, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] / subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "out[i, :, :] = 1j * kx[i] * subState[i, :, :]",
      "mutated_line": "out[i, :, :] = 1j * kx[i] + subState[i, :, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] + subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "out[i, :, :] = 1j * kx[i] * subState[i, :, :]",
      "mutated_line": "out[i, :, :] = (1j * kx[i]) ** subState[i, :, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = (1j * kx[i]) ** subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif axis == 1:",
      "mutated_line": "elif axis == 2:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 2:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif axis == 1:",
      "mutated_line": "elif axis == 0:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 0:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif axis == 1:",
      "mutated_line": "elif axis == 0:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 0:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif axis == 1:",
      "mutated_line": "elif axis == -1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == -1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif axis == 2:",
      "mutated_line": "elif axis != 2:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis != 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if i == nxp + 1:",
      "mutated_line": "if i == nxp - 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp - 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if i == nxp + 1:",
      "mutated_line": "if i == nxp * 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp * 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "out[i, :, :] = 1j * kx[i] * subState[i, :, :]",
      "mutated_line": "out[i, :, :] = 1j / kx[i] * subState[i, :, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j / kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "out[i, :, :] = 1j * kx[i] * subState[i, :, :]",
      "mutated_line": "out[i, :, :] = (1j + kx[i]) * subState[i, :, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = (1j + kx[i]) * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "out[i, :, :] = 1j * kx[i] * subState[i, :, :]",
      "mutated_line": "out[i, :, :] = 1j ** kx[i] * subState[i, :, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j ** kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "out[:, j, :] = 1j * ky[j] * subState[:, j, :]",
      "mutated_line": "out[:, j, :] = 1j * ky[j] / subState[:, j, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] / subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "out[:, j, :] = 1j * ky[j] * subState[:, j, :]",
      "mutated_line": "out[:, j, :] = 1j * ky[j] + subState[:, j, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] + subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "out[:, j, :] = 1j * ky[j] * subState[:, j, :]",
      "mutated_line": "out[:, j, :] = (1j * ky[j]) ** subState[:, j, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = (1j * ky[j]) ** subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif axis == 2:",
      "mutated_line": "elif axis == 3:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 3:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif axis == 2:",
      "mutated_line": "elif axis == 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 1:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif axis == 2:",
      "mutated_line": "elif axis == 0:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 0:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif axis == 2:",
      "mutated_line": "elif axis == 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 1:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif axis == 2:",
      "mutated_line": "elif axis == -2:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == -2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i == nxp + 1:",
      "mutated_line": "if i == nxp + 2:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 2:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i == nxp + 1:",
      "mutated_line": "if i == nxp + 0:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 0:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i == nxp + 1:",
      "mutated_line": "if i == nxp + 0:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 0:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i == nxp + 1:",
      "mutated_line": "if i == nxp + -1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + -1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "out[:, j, :] = 1j * ky[j] * subState[:, j, :]",
      "mutated_line": "out[:, j, :] = 1j / ky[j] * subState[:, j, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j / ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "out[:, j, :] = 1j * ky[j] * subState[:, j, :]",
      "mutated_line": "out[:, j, :] = (1j + ky[j]) * subState[:, j, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = (1j + ky[j]) * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "out[:, j, :] = 1j * ky[j] * subState[:, j, :]",
      "mutated_line": "out[:, j, :] = 1j ** ky[j] * subState[:, j, :]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j ** ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if k == nzp + 1:",
      "mutated_line": "if k != nzp + 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k != nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "out[:, :, k] = 1j * kz[k] * subState[:, :, k]",
      "mutated_line": "out[:, :, k] = 1j * kz[k] / subState[:, :, k]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] / subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "out[:, :, k] = 1j * kz[k] * subState[:, :, k]",
      "mutated_line": "out[:, :, k] = 1j * kz[k] + subState[:, :, k]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j * kz[k] + subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "out[:, :, k] = 1j * kz[k] * subState[:, :, k]",
      "mutated_line": "out[:, :, k] = (1j * kz[k]) ** subState[:, :, k]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = (1j * kz[k]) ** subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if k == nzp + 1:",
      "mutated_line": "if k == nzp - 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp - 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if k == nzp + 1:",
      "mutated_line": "if k == nzp * 1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp * 1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "out[:, :, k] = 1j * kz[k] * subState[:, :, k]",
      "mutated_line": "out[:, :, k] = 1j / kz[k] * subState[:, :, k]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j / kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "out[:, :, k] = 1j * kz[k] * subState[:, :, k]",
      "mutated_line": "out[:, :, k] = (1j + kz[k]) * subState[:, :, k]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = (1j + kz[k]) * subState[:, :, k]\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "out[:, :, k] = 1j * kz[k] * subState[:, :, k]",
      "mutated_line": "out[:, :, k] = 1j ** kz[k] * subState[:, :, k]",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 1:\n                continue\n            out[:, :, k] = 1j ** kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if k == nzp + 1:",
      "mutated_line": "if k == nzp + 2:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 2:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if k == nzp + 1:",
      "mutated_line": "if k == nzp + 0:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 0:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if k == nzp + 1:",
      "mutated_line": "if k == nzp + 0:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + 0:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if k == nzp + 1:",
      "mutated_line": "if k == nzp + -1:",
      "code": "import numpy as np\n\ndef apply_operation(subState, kx, ky, kz, axis, nxp, nzp):\n    \"\"\"\n    Apply a specific operation to the substate array based on the specified axis.\n\n    Args:\n    subState: 3D numpy array representing the substate\n    kx: 1D numpy array representing the kx values\n    ky: 1D numpy array representing the ky values\n    kz: 1D numpy array representing the kz values\n    axis: integer representing the axis along which the operation should be applied (0 for x, 1 for y, 2 for z)\n    nxp: integer representing a specific condition for the x-axis\n    nzp: integer representing a specific condition for the z-axis\n\n    Returns:\n    out: 3D numpy array representing the result of applying the operation to the substate array\n    \"\"\"\n    (nx, ny, nz) = subState.shape\n    out = np.zeros_like(subState, dtype=complex)\n    if axis == 0:\n        for i in range(nx):\n            if i == nxp + 1:\n                continue\n            out[i, :, :] = 1j * kx[i] * subState[i, :, :]\n    elif axis == 1:\n        for j in range(ny):\n            out[:, j, :] = 1j * ky[j] * subState[:, j, :]\n    elif axis == 2:\n        for k in range(nz):\n            if k == nzp + -1:\n                continue\n            out[:, :, k] = 1j * kz[k] * subState[:, :, k]\n    return out"
    }
  ]
}