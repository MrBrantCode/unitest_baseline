{
  "task_id": "cf_68906",
  "entry_point": "dijkstras",
  "mutant_count": 10,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "shortest_distances[start_node] = 0",
      "mutated_line": "shortest_distances[start_node] = 1",
      "code": "def dijkstras(graph, start_node):\n    shortest_distances = {node: float('inf') for node in graph}\n    shortest_distances[start_node] = 1\n    unvisited_nodes = list(graph.keys())\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: shortest_distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbour, distance) in graph[current_node].items():\n            if neighbour not in unvisited_nodes:\n                continue\n            new_distance = shortest_distances[current_node] + distance\n            if new_distance < shortest_distances[neighbour]:\n                shortest_distances[neighbour] = new_distance\n    return shortest_distances"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "shortest_distances[start_node] = 0",
      "mutated_line": "shortest_distances[start_node] = -1",
      "code": "def dijkstras(graph, start_node):\n    shortest_distances = {node: float('inf') for node in graph}\n    shortest_distances[start_node] = -1\n    unvisited_nodes = list(graph.keys())\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: shortest_distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbour, distance) in graph[current_node].items():\n            if neighbour not in unvisited_nodes:\n                continue\n            new_distance = shortest_distances[current_node] + distance\n            if new_distance < shortest_distances[neighbour]:\n                shortest_distances[neighbour] = new_distance\n    return shortest_distances"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "shortest_distances[start_node] = 0",
      "mutated_line": "shortest_distances[start_node] = 1",
      "code": "def dijkstras(graph, start_node):\n    shortest_distances = {node: float('inf') for node in graph}\n    shortest_distances[start_node] = 1\n    unvisited_nodes = list(graph.keys())\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: shortest_distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbour, distance) in graph[current_node].items():\n            if neighbour not in unvisited_nodes:\n                continue\n            new_distance = shortest_distances[current_node] + distance\n            if new_distance < shortest_distances[neighbour]:\n                shortest_distances[neighbour] = new_distance\n    return shortest_distances"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "shortest_distances = {node: float('inf') for node in graph}",
      "mutated_line": "shortest_distances = {node: float('') for node in graph}",
      "code": "def dijkstras(graph, start_node):\n    shortest_distances = {node: float('') for node in graph}\n    shortest_distances[start_node] = 0\n    unvisited_nodes = list(graph.keys())\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: shortest_distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbour, distance) in graph[current_node].items():\n            if neighbour not in unvisited_nodes:\n                continue\n            new_distance = shortest_distances[current_node] + distance\n            if new_distance < shortest_distances[neighbour]:\n                shortest_distances[neighbour] = new_distance\n    return shortest_distances"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if neighbour not in unvisited_nodes:",
      "mutated_line": "if neighbour in unvisited_nodes:",
      "code": "def dijkstras(graph, start_node):\n    shortest_distances = {node: float('inf') for node in graph}\n    shortest_distances[start_node] = 0\n    unvisited_nodes = list(graph.keys())\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: shortest_distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbour, distance) in graph[current_node].items():\n            if neighbour in unvisited_nodes:\n                continue\n            new_distance = shortest_distances[current_node] + distance\n            if new_distance < shortest_distances[neighbour]:\n                shortest_distances[neighbour] = new_distance\n    return shortest_distances"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "new_distance = shortest_distances[current_node] + distance",
      "mutated_line": "new_distance = shortest_distances[current_node] - distance",
      "code": "def dijkstras(graph, start_node):\n    shortest_distances = {node: float('inf') for node in graph}\n    shortest_distances[start_node] = 0\n    unvisited_nodes = list(graph.keys())\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: shortest_distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbour, distance) in graph[current_node].items():\n            if neighbour not in unvisited_nodes:\n                continue\n            new_distance = shortest_distances[current_node] - distance\n            if new_distance < shortest_distances[neighbour]:\n                shortest_distances[neighbour] = new_distance\n    return shortest_distances"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "new_distance = shortest_distances[current_node] + distance",
      "mutated_line": "new_distance = shortest_distances[current_node] * distance",
      "code": "def dijkstras(graph, start_node):\n    shortest_distances = {node: float('inf') for node in graph}\n    shortest_distances[start_node] = 0\n    unvisited_nodes = list(graph.keys())\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: shortest_distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbour, distance) in graph[current_node].items():\n            if neighbour not in unvisited_nodes:\n                continue\n            new_distance = shortest_distances[current_node] * distance\n            if new_distance < shortest_distances[neighbour]:\n                shortest_distances[neighbour] = new_distance\n    return shortest_distances"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if new_distance < shortest_distances[neighbour]:",
      "mutated_line": "if new_distance <= shortest_distances[neighbour]:",
      "code": "def dijkstras(graph, start_node):\n    shortest_distances = {node: float('inf') for node in graph}\n    shortest_distances[start_node] = 0\n    unvisited_nodes = list(graph.keys())\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: shortest_distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbour, distance) in graph[current_node].items():\n            if neighbour not in unvisited_nodes:\n                continue\n            new_distance = shortest_distances[current_node] + distance\n            if new_distance <= shortest_distances[neighbour]:\n                shortest_distances[neighbour] = new_distance\n    return shortest_distances"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if new_distance < shortest_distances[neighbour]:",
      "mutated_line": "if new_distance >= shortest_distances[neighbour]:",
      "code": "def dijkstras(graph, start_node):\n    shortest_distances = {node: float('inf') for node in graph}\n    shortest_distances[start_node] = 0\n    unvisited_nodes = list(graph.keys())\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: shortest_distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbour, distance) in graph[current_node].items():\n            if neighbour not in unvisited_nodes:\n                continue\n            new_distance = shortest_distances[current_node] + distance\n            if new_distance >= shortest_distances[neighbour]:\n                shortest_distances[neighbour] = new_distance\n    return shortest_distances"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if new_distance < shortest_distances[neighbour]:",
      "mutated_line": "if new_distance != shortest_distances[neighbour]:",
      "code": "def dijkstras(graph, start_node):\n    shortest_distances = {node: float('inf') for node in graph}\n    shortest_distances[start_node] = 0\n    unvisited_nodes = list(graph.keys())\n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: shortest_distances[node])\n        unvisited_nodes.remove(current_node)\n        for (neighbour, distance) in graph[current_node].items():\n            if neighbour not in unvisited_nodes:\n                continue\n            new_distance = shortest_distances[current_node] + distance\n            if new_distance != shortest_distances[neighbour]:\n                shortest_distances[neighbour] = new_distance\n    return shortest_distances"
    }
  ]
}