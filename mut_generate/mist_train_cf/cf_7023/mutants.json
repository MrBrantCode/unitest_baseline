{
  "task_id": "cf_7023",
  "entry_point": "bellman_ford",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "distances = [float('inf')] * num_vertices",
      "mutated_line": "distances = [float('inf')] / num_vertices",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] / num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "distances = [float('inf')] * num_vertices",
      "mutated_line": "distances = [float('inf')] + num_vertices",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] + num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "distances = [float('inf')] * num_vertices",
      "mutated_line": "distances = [float('inf')] ** num_vertices",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] ** num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = 1",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 1\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = -1",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = -1\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = 1",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 1\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for _ in range(num_vertices - 1):",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices + 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for _ in range(num_vertices - 1):",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices * 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "return 'Graph contains a negative weight cycle'",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') or distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for _ in range(num_vertices - 1):",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 2):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for _ in range(num_vertices - 1):",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 0):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for _ in range(num_vertices - 1):",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 0):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for _ in range(num_vertices - 1):",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - -1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "if distances[u] != float('inf') or distances[u] + w < distances[v]:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') or distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "return 'Graph contains a negative weight cycle'",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] == float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "return 'Graph contains a negative weight cycle'",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w <= distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "return 'Graph contains a negative weight cycle'",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w >= distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "return 'Graph contains a negative weight cycle'",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w != distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return \"Graph contains a negative weight cycle\"",
      "mutated_line": "return ''",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return ''\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "distances = [float('inf')] * num_vertices",
      "mutated_line": "distances = [float('')] * num_vertices",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "if distances[u] == float('inf') and distances[u] + w < distances[v]:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] == float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "if distances[u] != float('inf') and distances[u] + w <= distances[v]:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w <= distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "if distances[u] != float('inf') and distances[u] + w >= distances[v]:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w >= distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "if distances[u] != float('inf') and distances[u] + w != distances[v]:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w != distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "distances[v] = distances[u] + w",
      "mutated_line": "distances[v] = distances[u] - w",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] - w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "distances[v] = distances[u] + w",
      "mutated_line": "distances[v] = distances[u] * w",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] * w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "return 'Graph contains a negative weight cycle'",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] - w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "return 'Graph contains a negative weight cycle'",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] * w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "if distances[u] != float('inf') and distances[u] - w < distances[v]:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] - w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "if distances[u] != float('inf') and distances[u] * w < distances[v]:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] * w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "return 'Graph contains a negative weight cycle'",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if distances[u] != float('inf') and distances[u] + w < distances[v]:",
      "mutated_line": "if distances[u] != float('') and distances[u] + w < distances[v]:",
      "code": "def bellman_ford(edges, num_vertices, source):\n    \"\"\"\n    This function implements the Bellman-Ford algorithm to find the shortest path \n    from a source vertex to all other vertices in a weighted graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is represented as a tuple (u, v, w) \n                  where u is the source vertex, v is the destination vertex, and w is the weight of the edge.\n    num_vertices (int): The number of vertices in the graph.\n    source (int): The source vertex.\n\n    Returns:\n    list: A list of shortest distances from the source vertex to all other vertices. \n          If the graph contains a negative weight cycle, the function returns a message \n          indicating that the graph contains a negative weight cycle.\n    \"\"\"\n    distances = [float('inf')] * num_vertices\n    distances[source] = 0\n    for _ in range(num_vertices - 1):\n        for (u, v, w) in edges:\n            if distances[u] != float('') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n    for (u, v, w) in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            return 'Graph contains a negative weight cycle'\n    return distances"
    }
  ]
}