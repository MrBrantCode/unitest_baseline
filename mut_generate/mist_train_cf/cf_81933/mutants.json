{
  "task_id": "cf_81933",
  "entry_point": "smith_waterman",
  "mutant_count": 284,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=4, mismatch=-3, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=4, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=2, mismatch=-3, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=2, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=0, mismatch=-3, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=0, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=1, mismatch=-3, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=1, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=-3, mismatch=-3, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=-3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "UOI",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=+3, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=+3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "UOI",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=+2):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=+2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "align1 = \"\"",
      "mutated_line": "align2 = ''",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = 'MUTATED'\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "align2 = \"\"",
      "mutated_line": "align2 = 'MUTATED'",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = 'MUTATED'\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 or j > 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 or j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "align1 += a1",
      "mutated_line": "align1 -= a1",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 -= a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "align2 += a2",
      "mutated_line": "align2 -= a2",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 -= a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-4, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-4, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-2, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-2, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-0, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-0, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-1, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-1, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=--3, gap=-2):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=--3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-3):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-3):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-1):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-0):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-0):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-1):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):",
      "mutated_line": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=--2):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=--2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if alpha == beta:",
      "mutated_line": "if alpha != beta:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha != beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(seq1) + 1):",
      "mutated_line": "for i in range(1, len(seq1) + 1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(1, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(seq1) + 1):",
      "mutated_line": "for i in range(-1, len(seq1) + 1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(-1, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(seq1) + 1):",
      "mutated_line": "for i in range(1, len(seq1) + 1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(1, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(0, len(seq1) + 1):",
      "mutated_line": "for i in range(0, len(seq1) - 1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) - 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(0, len(seq1) + 1):",
      "mutated_line": "for i in range(0, len(seq1) * 1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) * 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[1]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[-1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[-1]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[1]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i >= 0 and j > 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i >= 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i <= 0 and j > 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i <= 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i != 0 and j > 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i != 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j >= 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j >= 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j <= 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j <= 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j != 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j != 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current != score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "print(\"Optimal alignment:\")",
      "mutated_line": "print('')",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "print(align1 + \"\\n\" + align2)",
      "mutated_line": "print(align1 + '\\n' - align2)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' - align2)"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "print(align1 + \"\\n\" + align2)",
      "mutated_line": "print((align1 + '\\n') * align2)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print((align1 + '\\n') * align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[1 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[1 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[-1 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[-1 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[1 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[1 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "elif alpha == '-' or beta == '-':",
      "mutated_line": "elif alpha == '-' and beta == '-':",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' and beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(seq1) + 1):",
      "mutated_line": "for i in range(0, len(seq1) + 2):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 2):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(seq1) + 1):",
      "mutated_line": "for i in range(0, len(seq1) + 0):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 0):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(seq1) + 1):",
      "mutated_line": "for i in range(0, len(seq1) + 0):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 0):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(seq1) + 1):",
      "mutated_line": "for i in range(0, len(seq1) + -1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + -1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(0, len(seq2) + 1):",
      "mutated_line": "for j in range(1, len(seq2) + 1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(1, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(0, len(seq2) + 1):",
      "mutated_line": "for j in range(-1, len(seq2) + 1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(-1, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(0, len(seq2) + 1):",
      "mutated_line": "for j in range(1, len(seq2) + 1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(1, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(0, len(seq2) + 1):",
      "mutated_line": "for j in range(0, len(seq2) - 1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) - 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(0, len(seq2) + 1):",
      "mutated_line": "for j in range(0, len(seq2) * 1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) * 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if i == 0 and j == 0:",
      "mutated_line": "if i == 0 or j == 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 or j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 1 and j > 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 1 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > -1 and j > 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > -1 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 1 and j > 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 1 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j > 1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 1:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j > -1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > -1:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while i > 0 and j > 0:",
      "mutated_line": "while i > 0 and j > 1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 1:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i - 1][j + 1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j + 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i - 1][j * 1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j * 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "score_left = score[i][j - 1]",
      "mutated_line": "score_left = score[i][j + 1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j + 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "score_left = score[i][j - 1]",
      "mutated_line": "score_left = score[i][j * 1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j * 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag - match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag * match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif score_current == score_up + gap:",
      "mutated_line": "elif score_current != score_up + gap:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current != score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "i -= 1",
      "mutated_line": "i += 1",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i += 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "UOI",
      "lineno": 55,
      "original_line": "align1 = align1[::-1]",
      "mutated_line": "align1 = align1[::+1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::+1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "UOI",
      "lineno": 56,
      "original_line": "align2 = align2[::-1]",
      "mutated_line": "align2 = align2[::+1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::+1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "print(align1 + \"\\n\" + align2)",
      "mutated_line": "print(align1 - '\\n' + align2)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 - '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "print(align1 + \"\\n\" + align2)",
      "mutated_line": "print(align1 * '\\n' + align2)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 * '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) - 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) - 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) * 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) * 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif alpha == '-' or beta == '-':",
      "mutated_line": "elif alpha != '-' or beta == '-':",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha != '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif alpha == '-' or beta == '-':",
      "mutated_line": "elif alpha == '-' or beta != '-':",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta != '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(0, len(seq2) + 1):",
      "mutated_line": "for j in range(0, len(seq2) + 2):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 2):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(0, len(seq2) + 1):",
      "mutated_line": "for j in range(0, len(seq2) + 0):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 0):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(0, len(seq2) + 1):",
      "mutated_line": "for j in range(0, len(seq2) + 0):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 0):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(0, len(seq2) + 1):",
      "mutated_line": "for j in range(0, len(seq2) + -1):",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + -1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if i == 0 and j == 0:",
      "mutated_line": "if i != 0 and j == 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i != 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if i == 0 and j == 0:",
      "mutated_line": "if i == 0 and j != 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j != 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "score[i][j] = 0",
      "mutated_line": "score[i][j] = 1",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 1\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "score[i][j] = 0",
      "mutated_line": "score[i][j] = -1",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = -1\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "score[i][j] = 0",
      "mutated_line": "score[i][j] = 1",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 1\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif i == 0:",
      "mutated_line": "elif i != 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i != 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))",
      "mutated_line": "align2 = ''",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print(''.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i + 1][j - 1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i + 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i * 1][j - 1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i * 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i - 1][j - 2]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 2]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i - 1][j - 0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 0]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i - 1][j - 0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 0]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i - 1][j - -1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - -1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "score_left = score[i][j - 1]",
      "mutated_line": "score_left = score[i][j - 2]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 2]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "score_left = score[i][j - 1]",
      "mutated_line": "score_left = score[i][j - 0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 0]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "score_left = score[i][j - 1]",
      "mutated_line": "score_left = score[i][j - 0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 0]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "score_left = score[i][j - 1]",
      "mutated_line": "score_left = score[i][j - -1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - -1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "score_up = score[i - 1][j]",
      "mutated_line": "score_up = score[i + 1][j]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i + 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "score_up = score[i - 1][j]",
      "mutated_line": "score_up = score[i * 1][j]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i * 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i + 1, j - 1)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i + 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i * 1, j - 1)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i * 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j + 1)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j + 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j * 1)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j * 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "elif score_current == score_up + gap:",
      "mutated_line": "elif score_current == score_up - gap:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up - gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "elif score_current == score_up + gap:",
      "mutated_line": "elif score_current == score_up * gap:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up * gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "i -= 1",
      "mutated_line": "i -= 2",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 2\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 0\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 0\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "i -= 1",
      "mutated_line": "i -= -1",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= -1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "elif score_current == score_left + gap:",
      "mutated_line": "elif score_current != score_left + gap:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current != score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j += 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "align1 = align1[::-1]",
      "mutated_line": "align1 = align1[::-2]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-2]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "align1 = align1[::-1]",
      "mutated_line": "align1 = align1[::-0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-0]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "align1 = align1[::-1]",
      "mutated_line": "align1 = align1[::-0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-0]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "align1 = align1[::-1]",
      "mutated_line": "align1 = align1[::--1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::--1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "align2 = align2[::-1]",
      "mutated_line": "align2 = align2[::-2]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-2]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "align2 = align2[::-1]",
      "mutated_line": "align2 = align2[::-0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-0]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "align2 = align2[::-1]",
      "mutated_line": "align2 = align2[::-0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-0]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "align2 = align2[::-1]",
      "mutated_line": "align2 = align2[::--1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::--1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "print(align1 + \"\\n\" + align2)",
      "mutated_line": "print(align1 + '' + align2)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) - 1)] for i in range(len(seq1) + 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) - 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) * 1)] for i in range(len(seq1) + 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) * 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 2)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 2)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 0)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 0)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 0)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 0)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + -1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + -1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif alpha == '-' or beta == '-':",
      "mutated_line": "elif alpha == '' or beta == '-':",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif alpha == '-' or beta == '-':",
      "mutated_line": "elif alpha == '-' or beta == '':",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if i == 0 and j == 0:",
      "mutated_line": "if i == 1 and j == 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 1 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if i == 0 and j == 0:",
      "mutated_line": "if i == -1 and j == 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == -1 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if i == 0 and j == 0:",
      "mutated_line": "if i == 1 and j == 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 1 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if i == 0 and j == 0:",
      "mutated_line": "if i == 0 and j == 1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 1:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if i == 0 and j == 0:",
      "mutated_line": "if i == 0 and j == -1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == -1:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if i == 0 and j == 0:",
      "mutated_line": "if i == 0 and j == 1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 1:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif i == 0:",
      "mutated_line": "elif i == 1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 1:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif i == 0:",
      "mutated_line": "elif i == -1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == -1:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif i == 0:",
      "mutated_line": "elif i == 1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 1:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif j == 0:",
      "mutated_line": "elif j != 0:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j != 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[+1]), key=lambda x: x[1])[0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[+1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i - 2][j - 1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 2][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i - 0][j - 1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 0][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i - 0][j - 1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 0][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "score_diag = score[i - 1][j - 1]",
      "mutated_line": "score_diag = score[i - -1][j - 1]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - -1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "score_up = score[i - 1][j]",
      "mutated_line": "score_up = score[i - 2][j]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 2][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "score_up = score[i - 1][j]",
      "mutated_line": "score_up = score[i - 0][j]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 0][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "score_up = score[i - 1][j]",
      "mutated_line": "score_up = score[i - 0][j]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 0][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "score_up = score[i - 1][j]",
      "mutated_line": "score_up = score[i - -1][j]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - -1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i + 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i + 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i * 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i * 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j + 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j + 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j * 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j * 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 2, j - 1)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 2, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 0, j - 1)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 0, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 0, j - 1)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 0, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - -1, j - 1)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - -1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j - 2)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 2)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j - 0)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 0)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j - 0)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 0)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "i, j = i - 1, j - 1",
      "mutated_line": "(i, j) = (i - 1, j - -1)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - -1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "a1, a2 = seq1[i - 1], '-'",
      "mutated_line": "(a1, a2) = (seq1[i - 1], '')",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "elif score_current == score_left + gap:",
      "mutated_line": "elif score_current == score_left - gap:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left - gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "elif score_current == score_left + gap:",
      "mutated_line": "elif score_current == score_left * gap:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left * gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 2\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 0\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 0\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= -1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) + 2)] for i in range(len(seq1) + 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 2)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) + 0)] for i in range(len(seq1) + 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 0)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) + 0)] for i in range(len(seq1) + 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 0)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]",
      "mutated_line": "score = [[0 for j in range(len(seq2) + -1)] for i in range(len(seq1) + 1)]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + -1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(1, score[i][j - 1] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(1, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(-1, score[i][j - 1] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(-1, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(1, score[i][j - 1] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(1, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i][j - 1] - gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] - gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i][j - 1] * gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] * gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif j == 0:",
      "mutated_line": "elif j == 1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 1:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif j == 0:",
      "mutated_line": "elif j == -1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == -1:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif j == 0:",
      "mutated_line": "elif j == 1:",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 1:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] - match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] - match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] * match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] * match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "delete = score[i - 1][j] + gap",
      "mutated_line": "delete = score[i - 1][j] - gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] - gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "delete = score[i - 1][j] + gap",
      "mutated_line": "delete = score[i - 1][j] * gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] * gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "insert = score[i][j - 1] + gap",
      "mutated_line": "insert = score[i][j - 1] - gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] - gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "insert = score[i][j - 1] + gap",
      "mutated_line": "insert = score[i][j - 1] * gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] * gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))",
      "mutated_line": "align2 = ''",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join(['MUTATED'.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[-2]), key=lambda x: x[1])[0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-2]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[-0]), key=lambda x: x[1])[0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-0]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[-0]), key=lambda x: x[1])[0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-0]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[--1]), key=lambda x: x[1])[0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[--1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[-1]), key=lambda x: x[2])[0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[2])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[-1]), key=lambda x: x[0])[0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[0])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[-1]), key=lambda x: x[0])[0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[0])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = max(enumerate(score[-1]), key=lambda x: x[1])[0]",
      "mutated_line": "i = max(enumerate(score[-1]), key=lambda x: x[-1])[0]",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[-1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i + 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i * 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j + 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j * 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i - 2], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 2], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i - 0], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 0], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i - 0], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 0], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i - -1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - -1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 2])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 2])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 0])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 0])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 0])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 0])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a1, a2 = seq1[i - 1], seq2[j - 1]",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - -1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - -1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "a1, a2 = seq1[i - 1], '-'",
      "mutated_line": "(a1, a2) = (seq1[i + 1], '-')",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i + 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "a1, a2 = seq1[i - 1], '-'",
      "mutated_line": "(a1, a2) = (seq1[i * 1], '-')",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i * 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "a1, a2 = '-', seq2[j - 1]",
      "mutated_line": "(a1, a2) = ('', seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(1, score[i - 1][j] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(1, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(-1, score[i - 1][j] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(-1, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(1, score[i - 1][j] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(1, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i - 1][j] - gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] - gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i - 1][j] * gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] * gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "score[i][j] = max(0, diag, delete, insert)",
      "mutated_line": "score[i][j] = max(1, diag, delete, insert)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(1, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "score[i][j] = max(0, diag, delete, insert)",
      "mutated_line": "score[i][j] = max(-1, diag, delete, insert)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(-1, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "score[i][j] = max(0, diag, delete, insert)",
      "mutated_line": "score[i][j] = max(1, diag, delete, insert)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(1, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 2], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 0], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 0], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - -1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 2]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 0]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 0]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):",
      "mutated_line": "(a1, a2) = (seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - -1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "a1, a2 = seq1[i - 1], '-'",
      "mutated_line": "(a1, a2) = (seq1[i - 2], '-')",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 2], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "a1, a2 = seq1[i - 1], '-'",
      "mutated_line": "(a1, a2) = (seq1[i - 0], '-')",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 0], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "a1, a2 = seq1[i - 1], '-'",
      "mutated_line": "(a1, a2) = (seq1[i - 0], '-')",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 0], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "a1, a2 = seq1[i - 1], '-'",
      "mutated_line": "(a1, a2) = (seq1[i - -1], '-')",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - -1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "a1, a2 = '-', seq2[j - 1]",
      "mutated_line": "(a1, a2) = ('-', seq2[j + 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j + 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "a1, a2 = '-', seq2[j - 1]",
      "mutated_line": "(a1, a2) = ('-', seq2[j * 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j * 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i][j + 1] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j + 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i][j * 1] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j * 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j + 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j + 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j * 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j * 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "insert = score[i][j - 1] + gap",
      "mutated_line": "insert = score[i][j + 1] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j + 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "insert = score[i][j - 1] + gap",
      "mutated_line": "insert = score[i][j * 1] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j * 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))",
      "mutated_line": "align2 = ''",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join([''.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "a1, a2 = '-', seq2[j - 1]",
      "mutated_line": "(a1, a2) = ('-', seq2[j - 2])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 2])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "a1, a2 = '-', seq2[j - 1]",
      "mutated_line": "(a1, a2) = ('-', seq2[j - 0])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 0])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "a1, a2 = '-', seq2[j - 1]",
      "mutated_line": "(a1, a2) = ('-', seq2[j - 0])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 0])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "a1, a2 = '-', seq2[j - 1]",
      "mutated_line": "(a1, a2) = ('-', seq2[j - -1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - -1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i][j - 2] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 2] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i][j - 0] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 0] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i][j - 0] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 0] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "score[i][j] = max(0, score[i][j - 1] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i][j - -1] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - -1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i + 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i + 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i * 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i * 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 2] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 2] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 0] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 0] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 0] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 0] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - -1] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - -1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i + 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i + 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i * 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i * 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j + 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j + 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j * 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j * 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "delete = score[i - 1][j] + gap",
      "mutated_line": "delete = score[i + 1][j] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i + 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "delete = score[i - 1][j] + gap",
      "mutated_line": "delete = score[i * 1][j] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i * 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "insert = score[i][j - 1] + gap",
      "mutated_line": "insert = score[i][j - 2] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 2] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "insert = score[i][j - 1] + gap",
      "mutated_line": "insert = score[i][j - 0] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 0] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "insert = score[i][j - 1] + gap",
      "mutated_line": "insert = score[i][j - 0] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 0] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "insert = score[i][j - 1] + gap",
      "mutated_line": "insert = score[i][j - -1] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - -1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i + 1][j] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i + 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i * 1][j] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i * 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 2][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 2][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 0][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 0][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 0][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 0][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - -1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - -1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 2], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 2], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 0], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 0], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 0], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 0], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - -1], seq2[j - 1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - -1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 2])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 2])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 0])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 0])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 0])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 0])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])",
      "mutated_line": "diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - -1])",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - -1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "delete = score[i - 1][j] + gap",
      "mutated_line": "delete = score[i - 2][j] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 2][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "delete = score[i - 1][j] + gap",
      "mutated_line": "delete = score[i - 0][j] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 0][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "delete = score[i - 1][j] + gap",
      "mutated_line": "delete = score[i - 0][j] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 0][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "delete = score[i - 1][j] + gap",
      "mutated_line": "delete = score[i - -1][j] + gap",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - -1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i - 2][j] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 2][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i - 0][j] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 0][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i - 0][j] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - 0][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "score[i][j] = max(0, score[i - 1][j] + gap)",
      "mutated_line": "score[i][j] = max(0, score[i - -1][j] + gap)",
      "code": "def smith_waterman(seq1, seq2, match=3, mismatch=-3, gap=-2):\n    score = [[0 for j in range(len(seq2) + 1)] for i in range(len(seq1) + 1)]\n\n    def match_score(alpha, beta):\n        if alpha == beta:\n            return match\n        elif alpha == '-' or beta == '-':\n            return gap\n        else:\n            return mismatch\n    for i in range(0, len(seq1) + 1):\n        for j in range(0, len(seq2) + 1):\n            if i == 0 and j == 0:\n                score[i][j] = 0\n            elif i == 0:\n                score[i][j] = max(0, score[i][j - 1] + gap)\n            elif j == 0:\n                score[i][j] = max(0, score[i - -1][j] + gap)\n            else:\n                diag = score[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])\n                delete = score[i - 1][j] + gap\n                insert = score[i][j - 1] + gap\n                score[i][j] = max(0, diag, delete, insert)\n    print('\\n'.join([''.join(['{:4}'.format(item) for item in row]) for row in score]))\n    align1 = ''\n    align2 = ''\n    j = len(seq2)\n    i = max(enumerate(score[-1]), key=lambda x: x[1])[0]\n    while i > 0 and j > 0:\n        score_current = score[i][j]\n        score_diag = score[i - 1][j - 1]\n        score_left = score[i][j - 1]\n        score_up = score[i - 1][j]\n        if score_current == score_diag + match_score(seq1[i - 1], seq2[j - 1]):\n            (a1, a2) = (seq1[i - 1], seq2[j - 1])\n            (i, j) = (i - 1, j - 1)\n        elif score_current == score_up + gap:\n            (a1, a2) = (seq1[i - 1], '-')\n            i -= 1\n        elif score_current == score_left + gap:\n            (a1, a2) = ('-', seq2[j - 1])\n            j -= 1\n        align1 += a1\n        align2 += a2\n    align1 = align1[::-1]\n    align2 = align2[::-1]\n    print('Optimal alignment:')\n    print(align1 + '\\n' + align2)"
    }
  ]
}