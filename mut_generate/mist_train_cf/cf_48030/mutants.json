{
  "task_id": "cf_48030",
  "entry_point": "max_quartet_degree",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [0] / (n + 1)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] / (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [0] + (n + 1)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] + (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [0] ** (n + 1)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] ** (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "degrees[u] += 1",
      "mutated_line": "degrees[u] -= 1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] -= 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "degrees[v] += 1",
      "mutated_line": "degrees[v] -= 1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] -= 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "max_degree = -1",
      "mutated_line": "max_degree = +1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = +1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [0] * (n - 1)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n - 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [0] * (n * 1)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n * 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degrees[u] += 1",
      "mutated_line": "degrees[u] += 2",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 2\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degrees[u] += 1",
      "mutated_line": "degrees[u] += 0",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 0\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degrees[u] += 1",
      "mutated_line": "degrees[u] += 0",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 0\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degrees[u] += 1",
      "mutated_line": "degrees[u] += -1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += -1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "degrees[v] += 1",
      "mutated_line": "degrees[v] += 2",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 2\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "degrees[v] += 1",
      "mutated_line": "degrees[v] += 0",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 0\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "degrees[v] += 1",
      "mutated_line": "degrees[v] += 0",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 0\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "degrees[v] += 1",
      "mutated_line": "degrees[v] += -1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += -1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_degree = -1",
      "mutated_line": "max_degree = -2",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -2\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_degree = -1",
      "mutated_line": "max_degree = -0",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -0\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_degree = -1",
      "mutated_line": "max_degree = -0",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -0\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_degree = -1",
      "mutated_line": "max_degree = --1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = --1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(2, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(0, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(0, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(-1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n - 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n * 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree >= 0 else -1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree >= 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree <= 0 else -1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree <= 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree != 0 else -1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree != 0 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree > 0 else +1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else +1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [1] * (n + 1)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [1] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [-1] * (n + 1)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [-1] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [1] * (n + 1)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [1] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [0] * (n + 2)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 2)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [0] * (n + 0)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 0)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [0] * (n + 0)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 0)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "degrees = [0] * (n + 1)",
      "mutated_line": "degrees = [0] * (n + -1)",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + -1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 2):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 0):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 0):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + -1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if degrees[i] + degrees[j] - len(common) > max_degree:",
      "mutated_line": "if degrees[i] + degrees[j] - len(common) >= max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) >= max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if degrees[i] + degrees[j] - len(common) > max_degree:",
      "mutated_line": "if degrees[i] + degrees[j] - len(common) <= max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) <= max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if degrees[i] + degrees[j] - len(common) > max_degree:",
      "mutated_line": "if degrees[i] + degrees[j] - len(common) != max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) != max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree > 1 else -1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree > -1 else -1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > -1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree > 1 else -1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree > 0 else -2",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree > 0 else -0",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree > 0 else -0",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max_degree if max_degree > 0 else -1",
      "mutated_line": "return max_degree if max_degree > 0 else --1",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else --1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n - 1)]",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n - 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n * 1)]",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n * 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if degrees[i] + degrees[j] - len(common) > max_degree:",
      "mutated_line": "if degrees[i] + degrees[j] + len(common) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] + len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if degrees[i] + degrees[j] - len(common) > max_degree:",
      "mutated_line": "if (degrees[i] + degrees[j]) * len(common) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if (degrees[i] + degrees[j]) * len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + 2)]",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 2)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + 0)]",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 0)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + 0)]",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 0)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + -1)]",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + -1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if degrees[i] + degrees[j] - len(common) > max_degree:",
      "mutated_line": "if degrees[i] - degrees[j] - len(common) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] - degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if degrees[i] + degrees[j] - len(common) > max_degree:",
      "mutated_line": "if degrees[i] * degrees[j] - len(common) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] * degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if k in common:",
      "mutated_line": "if k not in common:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k not in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) >= max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) >= max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) <= max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) <= max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) != max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) != max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] + len({i, j, k, l}) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] + len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if (degrees[i] + degrees[j] + degrees[k] + degrees[l]) * len({i, j, k, l}) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if (degrees[i] + degrees[j] + degrees[k] + degrees[l]) * len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l})",
      "mutated_line": "max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] + len({i, j, k, l})",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] + len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l})",
      "mutated_line": "max_degree = (degrees[i] + degrees[j] + degrees[k] + degrees[l]) * len({i, j, k, l})",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = (degrees[i] + degrees[j] + degrees[k] + degrees[l]) * len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if degrees[i] + degrees[j] + degrees[k] - degrees[l] - len({i, j, k, l}) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] - degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if (degrees[i] + degrees[j] + degrees[k]) * degrees[l] - len({i, j, k, l}) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if (degrees[i] + degrees[j] + degrees[k]) * degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l})",
      "mutated_line": "max_degree = degrees[i] + degrees[j] + degrees[k] - degrees[l] - len({i, j, k, l})",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] - degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l})",
      "mutated_line": "max_degree = (degrees[i] + degrees[j] + degrees[k]) * degrees[l] - len({i, j, k, l})",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = (degrees[i] + degrees[j] + degrees[k]) * degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if degrees[i] + degrees[j] - degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] - degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if (degrees[i] + degrees[j]) * degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if (degrees[i] + degrees[j]) * degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l})",
      "mutated_line": "max_degree = degrees[i] + degrees[j] - degrees[k] + degrees[l] - len({i, j, k, l})",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] - degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l})",
      "mutated_line": "max_degree = (degrees[i] + degrees[j]) * degrees[k] + degrees[l] - len({i, j, k, l})",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = (degrees[i] + degrees[j]) * degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if degrees[i] - degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] - degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l}) > max_degree:",
      "mutated_line": "if degrees[i] * degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] * degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l})",
      "mutated_line": "max_degree = degrees[i] - degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] - degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "max_degree = degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i,j,k,l})",
      "mutated_line": "max_degree = degrees[i] * degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})",
      "code": "def max_quartet_degree(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n    max_degree = -1\n    for i in range(1, n + 1):\n        graph[i].sort(key=lambda j: degrees[j])\n        common = {j for j in graph[i]}\n        for j in reversed(graph[i]):\n            if degrees[i] + degrees[j] - len(common) > max_degree:\n                for k in graph[j]:\n                    if k in common:\n                        for l in common:\n                            if degrees[i] + degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l}) > max_degree:\n                                max_degree = degrees[i] * degrees[j] + degrees[k] + degrees[l] - len({i, j, k, l})\n                common.remove(j)\n    return max_degree if max_degree > 0 else -1"
    }
  ]
}