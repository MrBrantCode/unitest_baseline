{
  "task_id": "cf_43115",
  "entry_point": "determine_overlapping_intervals",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current[0] <= previous[1]:  # Check for overlap",
      "mutated_line": "if current[0] < previous[1]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] < previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current[0] <= previous[1]:  # Check for overlap",
      "mutated_line": "if current[0] > previous[1]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] > previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current[0] <= previous[1]:  # Check for overlap",
      "mutated_line": "if current[0] == previous[1]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] == previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "merged = [intervals[0]]",
      "mutated_line": "merged = [intervals[1]]",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[1]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "merged = [intervals[0]]",
      "mutated_line": "merged = [intervals[-1]]",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[-1]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "merged = [intervals[0]]",
      "mutated_line": "merged = [intervals[1]]",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[1]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for current in intervals[1:]:",
      "mutated_line": "for current in intervals[2:]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[2:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for current in intervals[1:]:",
      "mutated_line": "for current in intervals[0:]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[0:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for current in intervals[1:]:",
      "mutated_line": "for current in intervals[0:]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[0:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for current in intervals[1:]:",
      "mutated_line": "for current in intervals[-1:]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[-1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "previous = merged[-1]",
      "mutated_line": "previous = merged[+1]",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[+1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previous = merged[-1]",
      "mutated_line": "previous = merged[-2]",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-2]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previous = merged[-1]",
      "mutated_line": "previous = merged[-0]",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-0]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previous = merged[-1]",
      "mutated_line": "previous = merged[-0]",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-0]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previous = merged[-1]",
      "mutated_line": "previous = merged[--1]",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[--1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current[0] <= previous[1]:  # Check for overlap",
      "mutated_line": "if current[1] <= previous[1]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[1] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current[0] <= previous[1]:  # Check for overlap",
      "mutated_line": "if current[-1] <= previous[1]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[-1] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current[0] <= previous[1]:  # Check for overlap",
      "mutated_line": "if current[1] <= previous[1]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[1] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current[0] <= previous[1]:  # Check for overlap",
      "mutated_line": "if current[0] <= previous[2]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[2]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current[0] <= previous[1]:  # Check for overlap",
      "mutated_line": "if current[0] <= previous[0]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[0]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current[0] <= previous[1]:  # Check for overlap",
      "mutated_line": "if current[0] <= previous[0]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[0]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current[0] <= previous[1]:  # Check for overlap",
      "mutated_line": "if current[0] <= previous[-1]:",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[-1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[+1] = (previous[0], max(previous[1], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[+1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: x[0])  # Sort intervals based on start time",
      "mutated_line": "intervals.sort(key=lambda x: x[1])",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[1])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: x[0])  # Sort intervals based on start time",
      "mutated_line": "intervals.sort(key=lambda x: x[-1])",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[-1])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: x[0])  # Sort intervals based on start time",
      "mutated_line": "intervals.sort(key=lambda x: x[1])",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[1])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-2] = (previous[0], max(previous[1], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-2] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-0] = (previous[0], max(previous[1], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-0] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-0] = (previous[0], max(previous[1], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-0] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[--1] = (previous[0], max(previous[1], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[--1] = (previous[0], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[1], max(previous[1], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[1], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[-1], max(previous[1], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[-1], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[1], max(previous[1], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[1], max(previous[1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[0], max(previous[2], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[2], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[0], max(previous[0], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[0], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[0], max(previous[0], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[0], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[0], max(previous[-1], current[1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[-1], current[1]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[0], max(previous[1], current[2]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[2]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[0], max(previous[1], current[0]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[0]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[0], max(previous[1], current[0]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[0]))\n        else:\n            merged.append(current)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "merged[-1] = (previous[0], max(previous[1], current[1]))  # Merge overlapping intervals",
      "mutated_line": "merged[-1] = (previous[0], max(previous[1], current[-1]))",
      "code": "def determine_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            merged[-1] = (previous[0], max(previous[1], current[-1]))\n        else:\n            merged.append(current)\n    return merged"
    }
  ]
}