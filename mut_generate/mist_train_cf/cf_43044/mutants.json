{
  "task_id": "cf_43044",
  "entry_point": "coordinate_descent",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if new_ind is not None:",
      "mutated_line": "if new_ind is None:",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "overvalue = np.abs(iterand) > bound",
      "mutated_line": "overvalue = np.abs(iterand) >= bound",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) >= bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "overvalue = np.abs(iterand) > bound",
      "mutated_line": "overvalue = np.abs(iterand) <= bound",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) <= bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "overvalue = np.abs(iterand) > bound",
      "mutated_line": "overvalue = np.abs(iterand) != bound",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) != bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if overvalue.sum() > 0:",
      "mutated_line": "if overvalue.sum() >= 0:",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() >= 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if overvalue.sum() > 0:",
      "mutated_line": "if overvalue.sum() <= 0:",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() <= 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if overvalue.sum() > 0:",
      "mutated_line": "if overvalue.sum() != 0:",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() != 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tmp[active_indices] = 1.",
      "mutated_line": "tmp[active_indices] = 2.0",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 2.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tmp[active_indices] = 1.",
      "mutated_line": "tmp[active_indices] = 0.0",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 0.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tmp[active_indices] = 1.",
      "mutated_line": "tmp[active_indices] = 0",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tmp[active_indices] = 1.",
      "mutated_line": "tmp[active_indices] = -1.0",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = -1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) * np.linalg.norm(column, 2) ** 2",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) * np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) // np.linalg.norm(column, 2) ** 2",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) // np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if overvalue.sum() > 0:",
      "mutated_line": "if overvalue.sum() > 1:",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 1:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if overvalue.sum() > 0:",
      "mutated_line": "if overvalue.sum() > -1:",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > -1:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if overvalue.sum() > 0:",
      "mutated_line": "if overvalue.sum() > 1:",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 1:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "iterand[overvalue] = np.sign(iterand[overvalue]) * bound",
      "mutated_line": "iterand[overvalue] = np.sign(iterand[overvalue]) / bound",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) / bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "iterand[overvalue] = np.sign(iterand[overvalue]) * bound",
      "mutated_line": "iterand[overvalue] = np.sign(iterand[overvalue]) + bound",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) + bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "iterand[overvalue] = np.sign(iterand[overvalue]) * bound",
      "mutated_line": "iterand[overvalue] = np.sign(iterand[overvalue]) ** bound",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) ** bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return {'iterand': iterand, 'positions': new_positions}",
      "mutated_line": "return {'': iterand, 'positions': new_positions}",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return {'iterand': iterand, 'positions': new_positions}",
      "mutated_line": "return {'iterand': iterand, '': new_positions}",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, '': new_positions}"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) * 2)",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) * 2)\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) + 2)",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) + 2)\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 3",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 3\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 1",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 1\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 0",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 0\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 1",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** 1\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** -2",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 2) ** -2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 3) ** 2",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 3) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 1) ** 2",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 1) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 0) ** 2",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 0) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 1) ** 2",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, 1) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "iterand[active_indices] = np.dot(data, column) / (np.linalg.norm(column, 2) ** 2)",
      "mutated_line": "iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, -2) ** 2",
      "code": "def coordinate_descent(iterand, active_indices, new_positions, data, dim, bound, new_ind, last_weight, forwardOp):\n    if new_ind is not None:\n        last_weight = iterand[new_ind]\n    else:\n        tmp = np.zeros(dim)\n        tmp[active_indices] = 1.0\n        column = forwardOp(tmp)\n        iterand[active_indices] = np.dot(data, column) / np.linalg.norm(column, -2) ** 2\n        last_weight = iterand[active_indices]\n    overvalue = np.abs(iterand) > bound\n    if overvalue.sum() > 0:\n        iterand[overvalue] = np.sign(iterand[overvalue]) * bound\n    return {'iterand': iterand, 'positions': new_positions}"
    }
  ]
}