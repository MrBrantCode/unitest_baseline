{
  "task_id": "cf_84291",
  "entry_point": "maxNumber",
  "mutant_count": 43,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "drop = len(nums) - k",
      "mutated_line": "drop = len(nums) + k",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) + k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "drop = len(nums) - k",
      "mutated_line": "drop = len(nums) * k",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) * k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "while a or b:",
      "mutated_line": "while a and b:",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a and b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "while drop and out and out[-1] < num:",
      "mutated_line": "while drop or out or out[-1] < num:",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop or out or out[-1] < num:\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "drop -= 1",
      "mutated_line": "drop += 1",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop += 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while drop and out and out[-1] < num:",
      "mutated_line": "while drop and out and (out[-1] <= num):",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] <= num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while drop and out and out[-1] < num:",
      "mutated_line": "while drop and out and (out[-1] >= num):",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] >= num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while drop and out and out[-1] < num:",
      "mutated_line": "while drop and out and (out[-1] != num):",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] != num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "drop -= 1",
      "mutated_line": "drop -= 2",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 2\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "drop -= 1",
      "mutated_line": "drop -= 0",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 0\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "drop -= 1",
      "mutated_line": "drop -= 0",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 0\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "drop -= 1",
      "mutated_line": "drop -= -1",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= -1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "bigger = a if a > b else b",
      "mutated_line": "bigger = a if a >= b else b",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a >= b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "bigger = a if a > b else b",
      "mutated_line": "bigger = a if a <= b else b",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a <= b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "bigger = a if a > b else b",
      "mutated_line": "bigger = a if a != b else b",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a != b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "bigger.pop(0)",
      "mutated_line": "bigger.pop(1)",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(1)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "bigger.pop(0)",
      "mutated_line": "bigger.pop(-1)",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(-1)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "bigger.pop(0)",
      "mutated_line": "bigger.pop(1)",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(1)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if i <= len(nums1) and k-i <= len(nums2))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) or k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) or k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans.append(bigger[0])",
      "mutated_line": "ans.append(bigger[1])",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[1])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans.append(bigger[0])",
      "mutated_line": "ans.append(bigger[-1])",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[-1])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans.append(bigger[0])",
      "mutated_line": "ans.append(bigger[1])",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[1])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return max(merge(pick_max(nums1, i), pick_max(nums2, k-i))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k + i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k + i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return max(merge(pick_max(nums1, i), pick_max(nums2, k-i))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k * i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k * i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(k+1)",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k - 1) if i <= len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k - 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(k+1)",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k * 1) if i <= len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k * 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i <= len(nums1) and k-i <= len(nums2))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i < len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i < len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i <= len(nums1) and k-i <= len(nums2))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i > len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i > len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i <= len(nums1) and k-i <= len(nums2))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i == len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i == len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i <= len(nums1) and k-i <= len(nums2))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i < len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i < len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i <= len(nums1) and k-i <= len(nums2))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i > len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i > len(nums2)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i <= len(nums1) and k-i <= len(nums2))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i == len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i == len(nums2)))"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "while drop and out and out[-1] < num:",
      "mutated_line": "while drop and out and (out[+1] < num):",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[+1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(k+1)",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 2) if i <= len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 2) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(k+1)",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 0) if i <= len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 0) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(k+1)",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 0) if i <= len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 0) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(k+1)",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + -1) if i <= len(nums1) and k - i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + -1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if i <= len(nums1) and k-i <= len(nums2))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k + i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k + i <= len(nums2)))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if i <= len(nums1) and k-i <= len(nums2))",
      "mutated_line": "return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k * i <= len(nums2)))",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k * i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while drop and out and out[-1] < num:",
      "mutated_line": "while drop and out and (out[-2] < num):",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-2] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while drop and out and out[-1] < num:",
      "mutated_line": "while drop and out and (out[-0] < num):",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-0] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while drop and out and out[-1] < num:",
      "mutated_line": "while drop and out and (out[-0] < num):",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[-0] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while drop and out and out[-1] < num:",
      "mutated_line": "while drop and out and (out[--1] < num):",
      "code": "def maxNumber(nums1, nums2, k):\n\n    def pick_max(nums, k):\n        drop = len(nums) - k\n        out = []\n        for num in nums:\n            while drop and out and (out[--1] < num):\n                out.pop()\n                drop -= 1\n            out.append(num)\n        return out[:k]\n\n    def merge(a, b):\n        ans = []\n        while a or b:\n            bigger = a if a > b else b\n            ans.append(bigger[0])\n            bigger.pop(0)\n        return ans\n    return max((merge(pick_max(nums1, i), pick_max(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2)))"
    }
  ]
}