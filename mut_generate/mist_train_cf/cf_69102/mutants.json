{
  "task_id": "cf_69102",
  "entry_point": "merge_sort",
  "mutant_count": 122,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def merge_sort(nums):\n    \"\"\"\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(nums) <= 1:",
      "mutated_line": "if len(nums) < 1:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) < 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(nums) <= 1:",
      "mutated_line": "if len(nums) > 1:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) > 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(nums) <= 1:",
      "mutated_line": "if len(nums) == 1:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) == 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "mid = len(nums) // 2",
      "mutated_line": "mid = len(nums) / 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) / 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "mid = len(nums) // 2",
      "mutated_line": "mid = len(nums) * 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) * 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "while left and right:",
      "mutated_line": "while left or right:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left or right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i - 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i - 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i * 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i * 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i - 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i - 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i * 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i * 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if left < n and nums[left] > nums[largest]:",
      "mutated_line": "if left < n or nums[left] > nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n or nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if right < n and nums[right] > nums[largest]:",
      "mutated_line": "if right < n or nums[right] > nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n or nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if largest != i:",
      "mutated_line": "if largest == i:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest == i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "\"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(nums) <= 1:",
      "mutated_line": "if len(nums) <= 2:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 2:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(nums) <= 1:",
      "mutated_line": "if len(nums) <= 0:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 0:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(nums) <= 1:",
      "mutated_line": "if len(nums) <= 0:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 0:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(nums) <= 1:",
      "mutated_line": "if len(nums) <= -1:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= -1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mid = len(nums) // 2",
      "mutated_line": "mid = len(nums) // 3",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 3\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mid = len(nums) // 2",
      "mutated_line": "mid = len(nums) // 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 1\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mid = len(nums) // 2",
      "mutated_line": "mid = len(nums) // 0",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 0\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mid = len(nums) // 2",
      "mutated_line": "mid = len(nums) // 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 1\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mid = len(nums) // 2",
      "mutated_line": "mid = len(nums) // -2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // -2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] <= right[0]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] >= right[0]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] >= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] != right[0]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] != right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 / i + 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 / i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 + i + 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 + i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 ** i + 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 ** i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i + 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 2\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i + 0",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 0\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i + 0",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 0\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i + -1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + -1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 / i + 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 / i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 + i + 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 + i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 ** i + 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 ** i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i + 3",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 3\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i + 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 1\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i + 0",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 0\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i + 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 1\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i + -2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + -2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and nums[left] > nums[largest]:",
      "mutated_line": "if left <= n and nums[left] > nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left <= n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and nums[left] > nums[largest]:",
      "mutated_line": "if left >= n and nums[left] > nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left >= n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and nums[left] > nums[largest]:",
      "mutated_line": "if left != n and nums[left] > nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left != n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and nums[left] > nums[largest]:",
      "mutated_line": "if left < n and nums[left] >= nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] >= nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and nums[left] > nums[largest]:",
      "mutated_line": "if left < n and nums[left] <= nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] <= nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and nums[left] > nums[largest]:",
      "mutated_line": "if left < n and nums[left] != nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] != nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and nums[right] > nums[largest]:",
      "mutated_line": "if right <= n and nums[right] > nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right <= n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and nums[right] > nums[largest]:",
      "mutated_line": "if right >= n and nums[right] > nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right >= n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and nums[right] > nums[largest]:",
      "mutated_line": "if right != n and nums[right] > nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right != n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and nums[right] > nums[largest]:",
      "mutated_line": "if right < n and nums[right] >= nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] >= nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and nums[right] > nums[largest]:",
      "mutated_line": "if right < n and nums[right] <= nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] <= nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and nums[right] > nums[largest]:",
      "mutated_line": "if right < n and nums[right] != nums[largest]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] != nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 + 1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 + 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 * 1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 * 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, +1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, +1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -1, +1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, +1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n + 1, 0, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n + 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n * 1, 0, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n * 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 1, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, -1, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 1, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, +1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, +1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 3 * i + 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 3 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 1 * i + 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 1 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 0 * i + 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 0 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 1 * i + 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 1 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = -2 * i + 1",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = -2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 3 * i + 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 3 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 1 * i + 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 1 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 0 * i + 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 0 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 1 * i + 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 1 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = -2 * i + 2",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = -2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n / 2 - 1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n / 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n * 2 - 1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n * 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 2, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 2, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 0, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 0, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 0, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 0, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - -1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - -1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -2, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -2, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -0, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -0, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -0, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -0, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, --1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, --1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -1, -2):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -2):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -1, -0):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -0):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -1, -0):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -0):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -1, --1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, --1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 2, 0, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 2, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 0, 0, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 0, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 0, 0, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 0, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - -1, 0, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - -1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -2):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -2):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -0):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -0):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -0):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -0):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, --1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, --1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "heapify(nums, i, 0)",
      "mutated_line": "heapify(nums, i, 1)",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 1)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "heapify(nums, i, 0)",
      "mutated_line": "heapify(nums, i, -1)",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, -1)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "heapify(nums, i, 0)",
      "mutated_line": "heapify(nums, i, 1)",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 1)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[1] < right[0]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[1] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[-1] < right[0]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[-1] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[1] < right[0]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[1] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] < right[1]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[1]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] < right[-1]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[-1]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] < right[1]:",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[1]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 3 - 1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 3 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 1 - 1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 1 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 0 - 1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 0 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 1 - 1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 1 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // -2 - 1, -1, -1):",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // -2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "nums[0], nums[i] = nums[i], nums[0]",
      "mutated_line": "(nums[1], nums[i]) = (nums[i], nums[0])",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[1], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "nums[0], nums[i] = nums[i], nums[0]",
      "mutated_line": "(nums[-1], nums[i]) = (nums[i], nums[0])",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[-1], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "nums[0], nums[i] = nums[i], nums[0]",
      "mutated_line": "(nums[1], nums[i]) = (nums[i], nums[0])",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[1], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "nums[0], nums[i] = nums[i], nums[0]",
      "mutated_line": "(nums[0], nums[i]) = (nums[i], nums[1])",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[1])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "nums[0], nums[i] = nums[i], nums[0]",
      "mutated_line": "(nums[0], nums[i]) = (nums[i], nums[-1])",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[-1])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "nums[0], nums[i] = nums[i], nums[0]",
      "mutated_line": "(nums[0], nums[i]) = (nums[i], nums[1])",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[1])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result.append(left.pop(0))",
      "mutated_line": "result.append(left.pop(1))",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(1))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result.append(left.pop(0))",
      "mutated_line": "result.append(left.pop(-1))",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(-1))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result.append(left.pop(0))",
      "mutated_line": "result.append(left.pop(1))",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(1))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "result.append(right.pop(0))",
      "mutated_line": "result.append(right.pop(1))",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(1))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "result.append(right.pop(0))",
      "mutated_line": "result.append(right.pop(-1))",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(-1))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "result.append(right.pop(0))",
      "mutated_line": "result.append(right.pop(1))",
      "code": "def merge_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Merge Sort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(1))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef heapify(nums, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and nums[left] > nums[largest]:\n        largest = left\n    if right < n and nums[right] > nums[largest]:\n        largest = right\n    if largest != i:\n        (nums[i], nums[largest]) = (nums[largest], nums[i])\n        heapify(nums, n, largest)\n\ndef heap_sort(nums):\n    \"\"\"Sorts an arbitrary number of n numerical entities in ascending order using the Heap Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n    for i in range(n - 1, 0, -1):\n        (nums[0], nums[i]) = (nums[i], nums[0])\n        heapify(nums, i, 0)\n    return nums"
    }
  ]
}