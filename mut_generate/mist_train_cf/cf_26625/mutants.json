{
  "task_id": "cf_26625",
  "entry_point": "extract_features",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "Chans_XY = 0",
      "mutated_line": "Chans_XY = 1",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 1\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "Chans_XY = 0",
      "mutated_line": "Chans_XY = -1",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = -1\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "Chans_XY = 0",
      "mutated_line": "Chans_XY = 1",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 1\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for chans in val_chans - 1:",
      "mutated_line": "for chans in val_chans + 1:",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans + 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for chans in val_chans - 1:",
      "mutated_line": "for chans in val_chans * 1:",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans * 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_dez = np.zeros((N_trials, N_chans * N_class / n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class / n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_dez = np.zeros((N_trials, N_chans * N_class + n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class + n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_dez = np.zeros((N_trials, (N_chans * N_class) ** n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, (N_chans * N_class) ** n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_onze = np.zeros((N_trials, N_chans * N_class / n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class / n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_onze = np.zeros((N_trials, N_chans * N_class + n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class + n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_onze = np.zeros((N_trials, (N_chans * N_class) ** n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, (N_chans * N_class) ** n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_doze = np.zeros((N_trials, N_chans * N_class / n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class / n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_doze = np.zeros((N_trials, N_chans * N_class + n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class + n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_doze = np.zeros((N_trials, (N_chans * N_class) ** n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, (N_chans * N_class) ** n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_treze = np.zeros((N_trials, N_chans * N_class / n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class / n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_treze = np.zeros((N_trials, N_chans * N_class + n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class + n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_treze = np.zeros((N_trials, (N_chans * N_class) ** n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, (N_chans * N_class) ** n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for chans in val_chans - 1:",
      "mutated_line": "for chans in val_chans - 2:",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 2:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for chans in val_chans - 1:",
      "mutated_line": "for chans in val_chans - 0:",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 0:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for chans in val_chans - 1:",
      "mutated_line": "for chans in val_chans - 0:",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 0:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for chans in val_chans - 1:",
      "mutated_line": "for chans in val_chans - -1:",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - -1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_dez = np.zeros((N_trials, N_chans / N_class * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans / N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_dez = np.zeros((N_trials, (N_chans + N_class) * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, (N_chans + N_class) * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_dez = np.zeros((N_trials, N_chans ** N_class * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans ** N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_onze = np.zeros((N_trials, N_chans / N_class * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans / N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_onze = np.zeros((N_trials, (N_chans + N_class) * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, (N_chans + N_class) * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_onze = np.zeros((N_trials, N_chans ** N_class * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans ** N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_doze = np.zeros((N_trials, N_chans / N_class * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans / N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_doze = np.zeros((N_trials, (N_chans + N_class) * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, (N_chans + N_class) * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_doze = np.zeros((N_trials, N_chans ** N_class * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans ** N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_treze = np.zeros((N_trials, N_chans / N_class * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans / N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_treze = np.zeros((N_trials, (N_chans + N_class) * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, (N_chans + N_class) * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))",
      "mutated_line": "F_treze = np.zeros((N_trials, N_chans ** N_class * n_harmonicas))",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans ** N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]",
      "mutated_line": "F_dez[trial, Chans_XY - np.array(range(n_features))] = a[N_pos[range(n_features)]]",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY - np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]",
      "mutated_line": "F_dez[trial, Chans_XY * np.array(range(n_features))] = a[N_pos[range(n_features)]]",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY * np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]",
      "mutated_line": "F_onze[trial, Chans_XY - np.array(range(n_features))] = b[N_pos[range(n_features)]]",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY - np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]",
      "mutated_line": "F_onze[trial, Chans_XY * np.array(range(n_features))] = b[N_pos[range(n_features)]]",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY * np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]",
      "mutated_line": "F_doze[trial, Chans_XY - np.array(range(n_features))] = c[N_pos[range(n_features)]]",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY - np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]",
      "mutated_line": "F_doze[trial, Chans_XY * np.array(range(n_features))] = c[N_pos[range(n_features)]]",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY * np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]",
      "mutated_line": "F_treze[trial, Chans_XY - np.array(range(n_features))] = d[N_pos[range(n_features)]]",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY - np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "F_treze[trial, Chans_XY + np.array(range(n_features))] = d[N_pos[range(n_features)]]",
      "mutated_line": "F_treze[trial, Chans_XY * np.array(range(n_features))] = d[N_pos[range(n_features)]]",
      "code": "import numpy as np\n\ndef extract_features(data, N_trials, N_chans, N_class, n_harmonicas, val_chans, N_pos, n_features):\n    F_dez = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_onze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_doze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    F_treze = np.zeros((N_trials, N_chans * N_class * n_harmonicas))\n    for trial in range(N_trials):\n        Chans_XY = 0\n        for chans in val_chans - 1:\n            a = abs(np.fft.fft(data[:, chans, trial]))\n            b = abs(np.fft.fft(data[:, chans, trial]))\n            c = abs(np.fft.fft(data[:, chans, trial]))\n            d = abs(np.fft.fft(data[:, chans, trial]))\n            F_dez[trial, Chans_XY + np.array(range(n_features))] = a[N_pos[range(n_features)]]\n            F_onze[trial, Chans_XY + np.array(range(n_features))] = b[N_pos[range(n_features)]]\n            F_doze[trial, Chans_XY + np.array(range(n_features))] = c[N_pos[range(n_features)]]\n            F_treze[trial, Chans_XY * np.array(range(n_features))] = d[N_pos[range(n_features)]]\n    return (F_dez, F_onze, F_doze, F_treze)"
    }
  ]
}