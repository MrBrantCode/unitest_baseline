{
  "task_id": "cf_7589",
  "entry_point": "calculate_distance",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total_distance = 0",
      "mutated_line": "total_distance = 1",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 1\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total_distance = 0",
      "mutated_line": "total_distance = -1",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = -1\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total_distance = 0",
      "mutated_line": "total_distance = 1",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 1\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time_interval = 0.5",
      "mutated_line": "time_interval = 1.5",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 1.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time_interval = 0.5",
      "mutated_line": "time_interval = -0.5",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = -0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time_interval = 0.5",
      "mutated_line": "time_interval = 0",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time_interval = 0.5",
      "mutated_line": "time_interval = 1",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 1\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time_interval = 0.5",
      "mutated_line": "time_interval = -0.5",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = -0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "total_distance += distance",
      "mutated_line": "total_distance -= distance",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance -= distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "current_velocity += acceleration * time_interval",
      "mutated_line": "current_velocity -= acceleration * time_interval",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity -= acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "remaining_time = t % time_interval",
      "mutated_line": "remaining_time = t * time_interval",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t * time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "remaining_time = t % time_interval",
      "mutated_line": "remaining_time = t + time_interval",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t + time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if remaining_time > 0:",
      "mutated_line": "if remaining_time >= 0:",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time >= 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if remaining_time > 0:",
      "mutated_line": "if remaining_time <= 0:",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time <= 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if remaining_time > 0:",
      "mutated_line": "if remaining_time != 0:",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time != 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "total_distance += distance",
      "mutated_line": "total_distance -= distance",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance -= distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval - 0.5 * acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval - 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval * (0.5 * acceleration * time_interval ** 2)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval * (0.5 * acceleration * time_interval ** 2)\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "current_velocity += acceleration * time_interval",
      "mutated_line": "current_velocity += acceleration / time_interval",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration / time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "current_velocity += acceleration * time_interval",
      "mutated_line": "current_velocity += acceleration + time_interval",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration + time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "current_velocity += acceleration * time_interval",
      "mutated_line": "current_velocity += acceleration ** time_interval",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration ** time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if remaining_time > 0:",
      "mutated_line": "if remaining_time > 1:",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 1:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if remaining_time > 0:",
      "mutated_line": "if remaining_time > -1:",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > -1:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if remaining_time > 0:",
      "mutated_line": "if remaining_time > 1:",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 1:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time - 0.5 * acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time - 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time * (0.5 * acceleration * remaining_time ** 2)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time * (0.5 * acceleration * remaining_time ** 2)\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return round(total_distance, 2)",
      "mutated_line": "return round(total_distance, 3)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 3)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return round(total_distance, 2)",
      "mutated_line": "return round(total_distance, 1)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return round(total_distance, 2)",
      "mutated_line": "return round(total_distance, 0)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return round(total_distance, 2)",
      "mutated_line": "return round(total_distance, 1)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return round(total_distance, 2)",
      "mutated_line": "return round(total_distance, -2)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, -2)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for _ in range(int(t // time_interval)):",
      "mutated_line": "for _ in range(int(t / time_interval)):",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t / time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for _ in range(int(t // time_interval)):",
      "mutated_line": "for _ in range(int(t * time_interval)):",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t * time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "acceleration = accelerations[_ % len(accelerations)]",
      "mutated_line": "acceleration = accelerations[_ * len(accelerations)]",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ * len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "acceleration = accelerations[_ % len(accelerations)]",
      "mutated_line": "acceleration = accelerations[_ + len(accelerations)]",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ + len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity / time_interval + 0.5 * acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity / time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity + time_interval + 0.5 * acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity + time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity ** time_interval + 0.5 * acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity ** time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0.5 * acceleration / time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration / time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + (0.5 * acceleration + time_interval ** 2)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + (0.5 * acceleration + time_interval ** 2)\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + (0.5 * acceleration) ** time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + (0.5 * acceleration) ** time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "acceleration = accelerations[int((t // time_interval)) % len(accelerations)]",
      "mutated_line": "acceleration = accelerations[int(t // time_interval) * len(accelerations)]",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) * len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "acceleration = accelerations[int((t // time_interval)) % len(accelerations)]",
      "mutated_line": "acceleration = accelerations[int(t // time_interval) + len(accelerations)]",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) + len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity / remaining_time + 0.5 * acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity / remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity + remaining_time + 0.5 * acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity + remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity ** remaining_time + 0.5 * acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity ** remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0.5 * acceleration / remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration / remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + (0.5 * acceleration + remaining_time ** 2)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + (0.5 * acceleration + remaining_time ** 2)\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + (0.5 * acceleration) ** remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + (0.5 * acceleration) ** remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0.5 / acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 / acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + (0.5 + acceleration) * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + (0.5 + acceleration) * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0.5 ** acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 ** acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0.5 * acceleration * (time_interval * 2)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * (time_interval * 2)\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0.5 * acceleration * (time_interval + 2)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * (time_interval + 2)\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0.5 / acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 / acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + (0.5 + acceleration) * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + (0.5 + acceleration) * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0.5 ** acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 ** acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0.5 * acceleration * (remaining_time * 2)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * (remaining_time * 2)\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0.5 * acceleration * (remaining_time + 2)",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * (remaining_time + 2)\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 1.5 * acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 1.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + -0.5 * acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + -0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0 * acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 1 * acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 1 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + -0.5 * acceleration * time_interval ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + -0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 3",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 3\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 1",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 1\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 0",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 0\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 1",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 1\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distance = (current_velocity * time_interval) + (0.5 * acceleration * (time_interval ** 2))",
      "mutated_line": "distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** -2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** -2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "acceleration = accelerations[int((t // time_interval)) % len(accelerations)]",
      "mutated_line": "acceleration = accelerations[int(t / time_interval) % len(accelerations)]",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t / time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "acceleration = accelerations[int((t // time_interval)) % len(accelerations)]",
      "mutated_line": "acceleration = accelerations[int(t * time_interval) % len(accelerations)]",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t * time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 1.5 * acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 1.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + -0.5 * acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + -0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0 * acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 1 * acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 1 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + -0.5 * acceleration * remaining_time ** 2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + -0.5 * acceleration * remaining_time ** 2\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 3",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 3\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 1",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 1\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 0",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 0\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 1",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** 1\n        total_distance += distance\n    return round(total_distance, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = (current_velocity * remaining_time) + (0.5 * acceleration * (remaining_time ** 2))",
      "mutated_line": "distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** -2",
      "code": "def calculate_distance(u, accelerations, t):\n    \"\"\"\n    Calculate the total distance traveled by an object given its initial velocity, \n    time interval, and changing acceleration.\n\n    Args:\n        u (float): Initial velocity in m/s\n        accelerations (list): List of accelerations in m/s^2\n        t (float): Time interval in seconds\n\n    Returns:\n        float: Total distance traveled in meters\n    \"\"\"\n    total_distance = 0\n    current_velocity = u\n    time_interval = 0.5\n    for _ in range(int(t // time_interval)):\n        acceleration = accelerations[_ % len(accelerations)]\n        distance = current_velocity * time_interval + 0.5 * acceleration * time_interval ** 2\n        total_distance += distance\n        current_velocity += acceleration * time_interval\n    remaining_time = t % time_interval\n    if remaining_time > 0:\n        acceleration = accelerations[int(t // time_interval) % len(accelerations)]\n        distance = current_velocity * remaining_time + 0.5 * acceleration * remaining_time ** -2\n        total_distance += distance\n    return round(total_distance, 2)"
    }
  ]
}