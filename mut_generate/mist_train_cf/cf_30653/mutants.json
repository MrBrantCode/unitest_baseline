{
  "task_id": "cf_30653",
  "entry_point": "find_closest_collectible",
  "mutant_count": 54,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "closest_distance = float('inf')",
      "mutated_line": "closest_distance = float('')",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if distance < closest_distance:",
      "mutated_line": "if distance <= closest_distance:",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance <= closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if distance < closest_distance:",
      "mutated_line": "if distance >= closest_distance:",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance >= closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if distance < closest_distance:",
      "mutated_line": "if distance != closest_distance:",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance != closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "collectible_position = collectible[0]",
      "mutated_line": "collectible_position = collectible[1]",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[1]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "collectible_position = collectible[0]",
      "mutated_line": "collectible_position = collectible[-1]",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[-1]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "collectible_position = collectible[0]",
      "mutated_line": "collectible_position = collectible[1]",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[1]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 - (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 - (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt(((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2) * (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt(((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2) * (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 - (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 - (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 * (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 * (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) * 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) * 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z + 2))",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z + 2))\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "closest_collectible = collectible[1]",
      "mutated_line": "closest_collectible = collectible[2]",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[2]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "closest_collectible = collectible[1]",
      "mutated_line": "closest_collectible = collectible[0]",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[0]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "closest_collectible = collectible[1]",
      "mutated_line": "closest_collectible = collectible[0]",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[0]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "closest_collectible = collectible[1]",
      "mutated_line": "closest_collectible = collectible[-1]",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[-1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) * 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) * 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt(player_position[0] - collectible_position.x + 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt(player_position[0] - collectible_position.x + 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) * 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) * 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y + 2) + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y + 2) + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] + collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] + collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] * collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] * collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 3)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 3)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 1)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 1)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 0)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 0)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 1)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 1)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** -2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** -2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] + collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] + collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] * collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] * collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 3 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 3 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 1 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 1 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 0 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 0 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 1 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 1 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** -2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** -2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] + collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] + collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] * collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] * collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 3 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 3 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 1 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 1 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 0 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 0 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 1 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 1 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** -2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** -2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[3] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[3] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[1] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[1] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[0] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[0] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[1] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[1] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(player_position[2] - collectible_position.z) ** 2)",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[-2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[-2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[1] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[1] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[-1] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[-1] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[1] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[1] - collectible_position.x) ** 2 + (player_position[1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[2] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[2] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[0] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[0] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[0] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[0] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(player_position[1] - collectible_position.y) ** 2 +",
      "mutated_line": "distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[-1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)",
      "code": "import math\n\ndef find_closest_collectible(player_position, collectibles):\n    closest_distance = float('inf')\n    closest_collectible = None\n    for collectible in collectibles:\n        collectible_position = collectible[0]\n        distance = math.sqrt((player_position[0] - collectible_position.x) ** 2 + (player_position[-1] - collectible_position.y) ** 2 + (player_position[2] - collectible_position.z) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_collectible = collectible[1]\n    return closest_collectible"
    }
  ]
}