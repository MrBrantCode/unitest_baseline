{
  "task_id": "cf_68339",
  "entry_point": "divide_and_discover",
  "mutant_count": 157,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if not matrix or not matrix[0]:",
      "mutated_line": "if not matrix and (not matrix[0]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix and (not matrix[0]):\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] / cols for _ in range(rows)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] / cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] + cols for _ in range(rows)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] + cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] ** cols for _ in range(rows)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] ** cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 and row >= rows and (col < 0) and (col >= cols) and visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 and row >= rows and (col < 0) and (col >= cols) and visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited[row][col] = True",
      "mutated_line": "visited[row][col] = False",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = False\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(sequence) == rows * cols:",
      "mutated_line": "if len(sequence) != rows * cols:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) != rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows or 0 <= next_col < cols or (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows or 0 <= next_col < cols or (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(-1, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (1, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 2), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (1, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, -1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (2, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (2, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, 0), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (-1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, -1), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (-1, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, +1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, +1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (+1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (+1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, -1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(1, 0, 0, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(1, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(-1, 0, 0, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(-1, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(1, 0, 0, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(1, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(0, 1, 0, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 1, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(0, -1, 0, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, -1, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(0, 1, 0, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 1, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(0, 0, 1, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 1, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(0, 0, -1, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, -1, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(0, 0, 1, 1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 1, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(0, 0, 0, 2)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 2)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(0, 0, 0, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 0)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(0, 0, 0, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 0)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [(0, 0, 0, 1)]",
      "mutated_line": "stack = [(0, 0, 0, -1)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, -1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row <= 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row <= 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row >= 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row >= 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row != 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row != 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row > rows or col < 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row > rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row < rows or col < 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row < rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row == rows or col < 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row == rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row >= rows or col <= 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col <= 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row >= rows or col >= 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col >= 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row >= rows or col != 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col != 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row >= rows or col < 0 or (col > cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col > cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row >= rows or col < 0 or (col < cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col < cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row >= rows or col < 0 or (col == cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col == cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if len(sequence) == rows * cols:",
      "mutated_line": "if len(sequence) == rows / cols:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows / cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if len(sequence) == rows * cols:",
      "mutated_line": "if len(sequence) == rows + cols:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows + cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if len(sequence) == rows * cols:",
      "mutated_line": "if len(sequence) == rows ** cols:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows ** cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row - directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row * (directions[dir_idx][0] * step), col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col - directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col * (directions[dir_idx][1] * step))\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 < next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 < next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 > next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 > next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 == next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 == next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and 0 < next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 < next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and 0 > next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 > next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and 0 == next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 == next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx + 1) * 4",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) * 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = dir_idx + 1 + 4",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = dir_idx + 1 + 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows or 0 <= next_col < cols or (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows or 0 <= next_col < cols or (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if not matrix or not matrix[0]:",
      "mutated_line": "if not matrix or not matrix[1]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[1]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if not matrix or not matrix[0]:",
      "mutated_line": "if not matrix or not matrix[-1]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[-1]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if not matrix or not matrix[0]:",
      "mutated_line": "if not matrix or not matrix[1]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[1]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(matrix), len(matrix[0])",
      "mutated_line": "(rows, cols) = (len(matrix), len(matrix[1]))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[1]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(matrix), len(matrix[0])",
      "mutated_line": "(rows, cols) = (len(matrix), len(matrix[-1]))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[-1]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(matrix), len(matrix[0])",
      "mutated_line": "(rows, cols) = (len(matrix), len(matrix[1]))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[1]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -2), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -2), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, --1), (-1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, --1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-2, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-2, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (--1, 0)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (--1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[True] * cols for _ in range(rows)]",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[True] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 1 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 1 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < -1 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < -1 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 1 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 1 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row >= rows or col < 1 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 1 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row >= rows or col < -1 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < -1 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:",
      "mutated_line": "if row < 0 or row >= rows or col < 1 or (col >= cols) or visited[row][col]:",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 1 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] / step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + (directions[dir_idx][0] + step), col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] ** step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] / step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + (directions[dir_idx][1] + step))\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] ** step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if -1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if -1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and 1 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 1 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and -1 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and -1 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and 1 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 1 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx - 1) % 4",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx - 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = dir_idx * 1 % 4",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = dir_idx * 1 % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx + 1) % 5",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 5\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx + 1) % 3",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 3\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx + 1) % 0",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 0\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx + 1) % 1",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 1\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx + 1) % -4",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % -4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row - directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row - directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row * (directions[dir_idx][0] * step), col + directions[dir_idx][1] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row * (directions[dir_idx][0] * step), col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] * step, col - directions[dir_idx][1] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col - directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] * step, col * (directions[dir_idx][1] * step))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col * (directions[dir_idx][1] * step))\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 < next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 < next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 > next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 > next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 == next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 == next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and 0 < next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 < next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and 0 > next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 > next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and 0 == next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 == next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx + 2) % 4",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 2) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx + 0) % 4",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 0) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx + 0) % 4",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 0) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dir_idx = (dir_idx + 1) % 4",
      "mutated_line": "dir_idx = (dir_idx + -1) % 4",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + -1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] / step, col + directions[dir_idx][1] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] / step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + (directions[dir_idx][0] + step), col + directions[dir_idx][1] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + (directions[dir_idx][0] + step), col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] ** step, col + directions[dir_idx][1] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] ** step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] / step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] / step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] * step, col + (directions[dir_idx][1] + step))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + (directions[dir_idx][1] + step))\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] ** step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] ** step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if -1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if -1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 1 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and 1 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 1 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and -1 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and -1 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:",
      "mutated_line": "if 0 <= next_row < rows and 1 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 1 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][1] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][-1] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][1] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][2] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][0] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][0] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][-1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "stack.append((row, col, dir_idx, step + 1))",
      "mutated_line": "stack.append((row, col, dir_idx, step - 1))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step - 1))\n    return sequence"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "stack.append((row, col, dir_idx, step + 1))",
      "mutated_line": "stack.append((row, col, dir_idx, step * 1))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step * 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][1] * step, col + directions[dir_idx][1] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][1] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][-1] * step, col + directions[dir_idx][1] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][-1] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][1] * step, col + directions[dir_idx][1] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][1] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][2] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][2] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][0] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][0] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][0] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][0] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_row, next_col = row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step",
      "mutated_line": "(next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][-1] * step)",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][-1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 1))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "stack.append((row, col, dir_idx, step + 1))",
      "mutated_line": "stack.append((row, col, dir_idx, step + 2))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 2))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "stack.append((row, col, dir_idx, step + 1))",
      "mutated_line": "stack.append((row, col, dir_idx, step + 0))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 0))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "stack.append((row, col, dir_idx, step + 1))",
      "mutated_line": "stack.append((row, col, dir_idx, step + 0))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + 0))\n    return sequence"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "stack.append((row, col, dir_idx, step + 1))",
      "mutated_line": "stack.append((row, col, dir_idx, step + -1))",
      "code": "def divide_and_discover(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    sequence = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0, 0, 1)]\n    while stack:\n        (row, col, dir_idx, step) = stack.pop()\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or visited[row][col]:\n            continue\n        visited[row][col] = True\n        sequence.append(matrix[row][col])\n        if len(sequence) == rows * cols:\n            break\n        (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n        if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n            stack.append((next_row, next_col, dir_idx, step))\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            (next_row, next_col) = (row + directions[dir_idx][0] * step, col + directions[dir_idx][1] * step)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (not visited[next_row][next_col]):\n                stack.append((next_row, next_col, dir_idx, step))\n            else:\n                stack.append((row, col, dir_idx, step + -1))\n    return sequence"
    }
  ]
}