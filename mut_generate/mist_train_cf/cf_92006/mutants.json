{
  "task_id": "cf_92006",
  "entry_point": "entrance",
  "mutant_count": 40,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "self.size += 1",
      "mutated_line": "self.size -= 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size -= 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "self.size -= 1",
      "mutated_line": "self.size += 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size += 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.size = 0",
      "mutated_line": "self.size = 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 1\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.size = 0",
      "mutated_line": "self.size = -1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = -1\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.size = 0",
      "mutated_line": "self.size = 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 1\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.size += 1",
      "mutated_line": "self.size += 2",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 2\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.size += 1",
      "mutated_line": "self.size += 0",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 0\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.size += 1",
      "mutated_line": "self.size += 0",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 0\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.size += 1",
      "mutated_line": "self.size += -1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += -1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if not self.min_stack or data <= self.min_stack[-1]:",
      "mutated_line": "if not self.min_stack and data <= self.min_stack[-1]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack and data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.size -= 1",
      "mutated_line": "self.size -= 2",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 2\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.size -= 1",
      "mutated_line": "self.size -= 0",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 0\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.size -= 1",
      "mutated_line": "self.size -= 0",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 0\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.size -= 1",
      "mutated_line": "self.size -= -1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= -1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if popped == self.min_stack[-1]:",
      "mutated_line": "if popped != self.min_stack[-1]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped != self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "return self.size == 0",
      "mutated_line": "return self.size != 0",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size != 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "self.size = 0",
      "mutated_line": "self.size = 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 1\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "self.size = 0",
      "mutated_line": "self.size = -1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = -1\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "self.size = 0",
      "mutated_line": "self.size = 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 1\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not self.min_stack or data <= self.min_stack[-1]:",
      "mutated_line": "if not self.min_stack or data < self.min_stack[-1]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data < self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not self.min_stack or data <= self.min_stack[-1]:",
      "mutated_line": "if not self.min_stack or data > self.min_stack[-1]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data > self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not self.min_stack or data <= self.min_stack[-1]:",
      "mutated_line": "if not self.min_stack or data == self.min_stack[-1]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data == self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return self.size == 0",
      "mutated_line": "return self.size == 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 1\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return self.size == 0",
      "mutated_line": "return self.size == -1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == -1\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return self.size == 0",
      "mutated_line": "return self.size == 1",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 1\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "UOI",
      "lineno": 57,
      "original_line": "return self.min_stack[-1]",
      "mutated_line": "return self.min_stack[+1]",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[+1]\n    return Stack()"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "if popped == self.min_stack[-1]:",
      "mutated_line": "if popped == self.min_stack[+1]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[+1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return self.min_stack[-1]",
      "mutated_line": "return self.min_stack[-2]",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-2]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return self.min_stack[-1]",
      "mutated_line": "return self.min_stack[-0]",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-0]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return self.min_stack[-1]",
      "mutated_line": "return self.min_stack[-0]",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-0]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return self.min_stack[-1]",
      "mutated_line": "return self.min_stack[--1]",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[--1]\n    return Stack()"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "if not self.min_stack or data <= self.min_stack[-1]:",
      "mutated_line": "if not self.min_stack or data <= self.min_stack[+1]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[+1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if popped == self.min_stack[-1]:",
      "mutated_line": "if popped == self.min_stack[-2]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-2]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if popped == self.min_stack[-1]:",
      "mutated_line": "if popped == self.min_stack[-0]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-0]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if popped == self.min_stack[-1]:",
      "mutated_line": "if popped == self.min_stack[-0]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-0]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if popped == self.min_stack[-1]:",
      "mutated_line": "if popped == self.min_stack[--1]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[--1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not self.min_stack or data <= self.min_stack[-1]:",
      "mutated_line": "if not self.min_stack or data <= self.min_stack[-2]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-2]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not self.min_stack or data <= self.min_stack[-1]:",
      "mutated_line": "if not self.min_stack or data <= self.min_stack[-0]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-0]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not self.min_stack or data <= self.min_stack[-1]:",
      "mutated_line": "if not self.min_stack or data <= self.min_stack[-0]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[-0]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not self.min_stack or data <= self.min_stack[-1]:",
      "mutated_line": "if not self.min_stack or data <= self.min_stack[--1]:",
      "code": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef entrance(data):\n\n    class Stack:\n\n        def __init__(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def push(self, data):\n            new_node = Node(data)\n            new_node.next = self.head\n            self.head = new_node\n            self.size += 1\n            if not self.min_stack or data <= self.min_stack[--1]:\n                self.min_stack.append(data)\n\n        def pop(self):\n            if self.is_empty():\n                return None\n            popped = self.head.data\n            self.head = self.head.next\n            self.size -= 1\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n            return popped\n\n        def peek(self):\n            if self.is_empty():\n                return None\n            return self.head.data\n\n        def is_empty(self):\n            return self.size == 0\n\n        def get_size(self):\n            return self.size\n\n        def clear(self):\n            self.head = None\n            self.size = 0\n            self.min_stack = []\n\n        def get_min(self):\n            if self.is_empty():\n                return None\n            return self.min_stack[-1]\n    return Stack()"
    }
  ]
}