{
  "task_id": "cf_51065",
  "entry_point": "max_overlapping_and_remaining_intervals",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "remaining = len(intervals) - removed",
      "mutated_line": "remaining = len(intervals) + removed",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) + removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "remaining = len(intervals) - removed",
      "mutated_line": "remaining = len(intervals) * removed",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) * removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "max_overlapping = active_intervals = 0",
      "mutated_line": "max_overlapping = active_intervals = 1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 1\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "max_overlapping = active_intervals = 0",
      "mutated_line": "max_overlapping = active_intervals = -1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = -1\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "max_overlapping = active_intervals = 0",
      "mutated_line": "max_overlapping = active_intervals = 1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 1\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 1\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = 0",
      "mutated_line": "j = -1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = -1\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 1\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "max_end, removed = -1, 0",
      "mutated_line": "(max_end, removed) = (+1, 0)",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (+1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_end, removed = -1, 0",
      "mutated_line": "(max_end, removed) = (-1, 1)",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 1)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_end, removed = -1, 0",
      "mutated_line": "(max_end, removed) = (-1, -1)",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, -1)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_end, removed = -1, 0",
      "mutated_line": "(max_end, removed) = (-1, 1)",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 1)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if end <= max_end:",
      "mutated_line": "if end < max_end:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end < max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if end <= max_end:",
      "mutated_line": "if end > max_end:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end > max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if end <= max_end:",
      "mutated_line": "if end == max_end:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end == max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "removed += 1",
      "mutated_line": "removed -= 1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed -= 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) or intervals[j][0] < intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) or intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "active_intervals += 1",
      "mutated_line": "active_intervals -= 1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j -= 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) or intervals[j][0] >= intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) or intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "active_intervals -= 1",
      "mutated_line": "active_intervals += 1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals += 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j -= 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_end, removed = -1, 0",
      "mutated_line": "(max_end, removed) = (-2, 0)",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-2, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_end, removed = -1, 0",
      "mutated_line": "(max_end, removed) = (-0, 0)",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-0, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_end, removed = -1, 0",
      "mutated_line": "(max_end, removed) = (-0, 0)",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-0, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_end, removed = -1, 0",
      "mutated_line": "(max_end, removed) = (--1, 0)",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (--1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "removed += 1",
      "mutated_line": "removed += 2",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 2\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "removed += 1",
      "mutated_line": "removed += 0",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 0\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "removed += 1",
      "mutated_line": "removed += 0",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 0\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "removed += 1",
      "mutated_line": "removed += -1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += -1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j <= len(intervals) and intervals[j][0] < intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j <= len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j >= len(intervals) and intervals[j][0] < intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j >= len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j != len(intervals) and intervals[j][0] < intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j != len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] <= intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] <= intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] != intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] != intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "active_intervals += 1",
      "mutated_line": "active_intervals += 2",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 2\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "active_intervals += 1",
      "mutated_line": "active_intervals += 0",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 0\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "active_intervals += 1",
      "mutated_line": "active_intervals += 0",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 0\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "active_intervals += 1",
      "mutated_line": "active_intervals += -1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += -1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 2\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 0\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 0\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += -1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j <= len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j <= len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j >= len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j >= len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j != len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j != len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] > intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] > intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] == intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] == intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "active_intervals -= 1",
      "mutated_line": "active_intervals -= 2",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 2\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "active_intervals -= 1",
      "mutated_line": "active_intervals -= 0",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 0\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "active_intervals -= 1",
      "mutated_line": "active_intervals -= 0",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 0\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "active_intervals -= 1",
      "mutated_line": "active_intervals -= -1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= -1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 2\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 0\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 0\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += -1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "UOI",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], +x[1]))",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], +x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][1] < intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][1] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][-1] < intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][-1] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][1] < intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][1] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] < intervals[i][2]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][2]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] < intervals[i][0]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][0]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] < intervals[i][0]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][0]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while j < len(intervals) and intervals[j][0] < intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] < intervals[i][-1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][-1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][1] >= intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][1] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][-1] >= intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][-1] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][1] >= intervals[i][1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][1] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][2]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][2]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][0]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][0]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][0]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][0]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][1]:",
      "mutated_line": "while j < len(intervals) and intervals[j][0] >= intervals[i][-1]:",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][-1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[1], -x[1]))",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[1], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[-1], -x[1]))",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[-1], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[1], -x[1]))",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[1], -x[1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], -x[2]))",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[2]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], -x[0]))",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[0]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], -x[0]))",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[0]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], -x[-1]))",
      "code": "def max_overlapping_and_remaining_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[-1]))\n    (max_end, removed) = (-1, 0)\n    for (start, end) in intervals:\n        if end <= max_end:\n            removed += 1\n        else:\n            max_end = end\n    remaining = len(intervals) - removed\n    intervals.sort()\n    max_overlapping = active_intervals = 0\n    j = 0\n    for i in range(len(intervals)):\n        while j < len(intervals) and intervals[j][0] < intervals[i][1]:\n            active_intervals += 1\n            j += 1\n        max_overlapping = max(max_overlapping, active_intervals)\n        while j < len(intervals) and intervals[j][0] >= intervals[i][1]:\n            active_intervals -= 1\n            j += 1\n    return (remaining, max_overlapping)"
    }
  ]
}