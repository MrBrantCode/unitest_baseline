{
  "task_id": "cf_13338",
  "entry_point": "count_valid_permutations",
  "mutant_count": 32,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "counter = 0",
      "mutated_line": "counter = 1",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 1\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "counter = 0",
      "mutated_line": "counter = -1",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = -1\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "counter = 0",
      "mutated_line": "counter = 1",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 1\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(permutation) == n:",
      "mutated_line": "if len(permutation) != n:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) != n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "counter += 1",
      "mutated_line": "counter -= 1",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter -= 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "elements = list(range(1, n+1))",
      "mutated_line": "elements = list(range(2, n + 1))",
      "code": "def count_valid_permutations(n):\n    elements = list(range(2, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "elements = list(range(1, n+1))",
      "mutated_line": "elements = list(range(0, n + 1))",
      "code": "def count_valid_permutations(n):\n    elements = list(range(0, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "elements = list(range(1, n+1))",
      "mutated_line": "elements = list(range(0, n + 1))",
      "code": "def count_valid_permutations(n):\n    elements = list(range(0, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "elements = list(range(1, n+1))",
      "mutated_line": "elements = list(range(-1, n + 1))",
      "code": "def count_valid_permutations(n):\n    elements = list(range(-1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "elements = list(range(1, n+1))",
      "mutated_line": "elements = list(range(1, n - 1))",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n - 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "elements = list(range(1, n+1))",
      "mutated_line": "elements = list(range(1, n * 1))",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n * 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "counter += 1",
      "mutated_line": "counter += 2",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 2\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "counter += 1",
      "mutated_line": "counter += 0",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 0\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "counter += 1",
      "mutated_line": "counter += 0",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 0\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "counter += 1",
      "mutated_line": "counter += -1",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += -1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 0 and element > permutation[-1]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 and element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "elements = list(range(1, n+1))",
      "mutated_line": "elements = list(range(1, n + 2))",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 2))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "elements = list(range(1, n+1))",
      "mutated_line": "elements = list(range(1, n + 0))",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 0))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "elements = list(range(1, n+1))",
      "mutated_line": "elements = list(range(1, n + 0))",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 0))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "elements = list(range(1, n+1))",
      "mutated_line": "elements = list(range(1, n + -1))",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + -1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) != 0 or element > permutation[-1]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) != 0 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 0 or element >= permutation[-1]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element >= permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 0 or element <= permutation[-1]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element <= permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 0 or element != permutation[-1]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element != permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 1 or element > permutation[-1]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 1 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == -1 or element > permutation[-1]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == -1 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 1 or element > permutation[-1]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 1 or element > permutation[-1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 0 or element > permutation[+1]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[+1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 0 or element > permutation[-2]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-2]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 0 or element > permutation[-0]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-0]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 0 or element > permutation[-0]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[-0]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(permutation) == 0 or element > permutation[-1]:",
      "mutated_line": "if len(permutation) == 0 or element > permutation[--1]:",
      "code": "def count_valid_permutations(n):\n    elements = list(range(1, n + 1))\n    permutation = []\n    unused_elements = elements.copy()\n    counter = 0\n\n    def backtrack(permutation, unused_elements):\n        if len(permutation) == n:\n            nonlocal counter\n            counter += 1\n            return\n        for element in unused_elements:\n            if len(permutation) == 0 or element > permutation[--1]:\n                new_permutation = permutation.copy()\n                new_permutation.append(element)\n                new_unused_elements = unused_elements.copy()\n                new_unused_elements.remove(element)\n                backtrack(new_permutation, new_unused_elements)\n    backtrack(permutation, unused_elements)\n    return counter"
    }
  ]
}