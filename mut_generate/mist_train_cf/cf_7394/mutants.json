{
  "task_id": "cf_7394",
  "entry_point": "shortest_path",
  "mutant_count": 216,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 and source[0] >= rows and (source[1] < 0) and (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 and source[0] >= rows and (source[1] < 0) and (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 and destination[0] >= rows and (destination[1] < 0) and (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 and destination[0] >= rows and (destination[1] < 0) and (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 and grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 and grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] <= 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] <= 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] >= 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] >= 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] != 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] != 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] > rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] > rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] < rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] < rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] == rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] == rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] <= 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] <= 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] >= 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] >= 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] != 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] != 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] > cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] > cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] < cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] < cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] == cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] == cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] <= 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] <= 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] >= 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] >= 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] != 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] != 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] > rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] > rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] < rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] < rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] == rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] == rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] <= 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] <= 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] >= 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] >= 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] != 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] != 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] > cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] > cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] < cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] < cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] == cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] == cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] != 1 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] != 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] != 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] != 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] / cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] / cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] + cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] + cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] ** cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] ** cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if row == destination[0] and col == destination[1]:",
      "mutated_line": "if row == destination[0] or col == destination[1]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] or col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if grid[row][col] == 1 or visited[row][col]:",
      "mutated_line": "if grid[row][col] == 1 and visited[row][col]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 and visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "visited[row][col] = True",
      "mutated_line": "visited[row][col] = False",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = False\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cols = len(grid[0])",
      "mutated_line": "cols = len(grid[1])",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[1])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cols = len(grid[0])",
      "mutated_line": "cols = len(grid[-1])",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[-1])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cols = len(grid[0])",
      "mutated_line": "cols = len(grid[1])",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[1])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < -1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < -1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 1 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 1 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < -1 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < -1 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 1 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 1 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 1 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 1 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < -1 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < -1 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 1 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 1 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 1 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 1 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < -1 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < -1 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 1 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 1 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 2 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 2 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 0 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 0 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 0 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 0 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == -1 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == -1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 2:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 2:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 0:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 0:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 0:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 0:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == -1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == -1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(1, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(-1, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(-1, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(1, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 2), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 2), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 0), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 0), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, -1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, -1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (2, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (2, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (0, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (0, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (-1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (-1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 1), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, -1), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 1), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (1, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (-1, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (1, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, +1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, +1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (+1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (+1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 1), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, -1), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, -1), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 1), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 2), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 2), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 0), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 0), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 0), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 0), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, -1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (+1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (+1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 2), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 2), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 0), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 0), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 0), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 0), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (2, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (2, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (0, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (0, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (0, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (0, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (-1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (-1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, +1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, +1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (+1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (+1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, +1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, +1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if row == destination[0] and col == destination[1]:",
      "mutated_line": "if row != destination[0] and col == destination[1]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row != destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if row == destination[0] and col == destination[1]:",
      "mutated_line": "if row == destination[0] and col != destination[1]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col != destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return path + [(row, col)]",
      "mutated_line": "return path - [(row, col)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path - [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return path + [(row, col)]",
      "mutated_line": "return path * [(row, col)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path * [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if grid[row][col] == 1 or visited[row][col]:",
      "mutated_line": "if grid[row][col] != 1 or visited[row][col]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] != 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "new_row = row + direction[0]",
      "mutated_line": "new_row = row - direction[0]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row - direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "new_row = row + direction[0]",
      "mutated_line": "new_row = row * direction[0]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row * direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col - direction[1]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col - direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col * direction[1]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col * direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 0 <= new_row < rows or 0 <= new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows or 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[-1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[-1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[1] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[1] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[-1] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[-1] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[1] >= rows or source[1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[1] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[2] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[2] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[0] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[0] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[0] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[0] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[-1] < 0 or (source[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[-1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[2] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[2] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[0] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[0] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[0] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[0] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or source[1] >= cols:",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[-1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[-1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[1] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[1] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[-1] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[-1] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[1] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[1] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[1] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[1] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[-1] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[-1] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[1] >= rows or destination[1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[1] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[2] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[2] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[0] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[0] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[0] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[0] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[-1] < 0 or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[-1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[2] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[2] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[0] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[0] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[0] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[0] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or destination[1] >= cols:",
      "mutated_line": "if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[-1] >= cols):",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[-1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -2), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -2), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -0), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -0), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, --1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, --1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-2, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-2, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-0, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-0, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (--1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (--1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-2, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-2, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-0, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-0, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-0, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-0, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (--1, 1), (1, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (--1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -2), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -2), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -0), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -0), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -0), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -0), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, --1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, --1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-2, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-2, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-0, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-0, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-0, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-0, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (--1, -1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (--1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -2)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -0)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -0)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -0)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -0)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, --1)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, --1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[True] * cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[True] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((source[0], source[1], []))  # Each queue element contains (row, col, path)",
      "mutated_line": "queue.append((source[1], source[1], []))",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[1], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((source[0], source[1], []))  # Each queue element contains (row, col, path)",
      "mutated_line": "queue.append((source[-1], source[1], []))",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[-1], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((source[0], source[1], []))  # Each queue element contains (row, col, path)",
      "mutated_line": "queue.append((source[1], source[1], []))",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[1], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((source[0], source[1], []))  # Each queue element contains (row, col, path)",
      "mutated_line": "queue.append((source[0], source[2], []))",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[2], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((source[0], source[1], []))  # Each queue element contains (row, col, path)",
      "mutated_line": "queue.append((source[0], source[0], []))",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[0], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((source[0], source[1], []))  # Each queue element contains (row, col, path)",
      "mutated_line": "queue.append((source[0], source[0], []))",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[0], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((source[0], source[1], []))  # Each queue element contains (row, col, path)",
      "mutated_line": "queue.append((source[0], source[-1], []))",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[-1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if grid[row][col] == 1 or visited[row][col]:",
      "mutated_line": "if grid[row][col] == 2 or visited[row][col]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 2 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if grid[row][col] == 1 or visited[row][col]:",
      "mutated_line": "if grid[row][col] == 0 or visited[row][col]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 0 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if grid[row][col] == 1 or visited[row][col]:",
      "mutated_line": "if grid[row][col] == 0 or visited[row][col]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 0 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if grid[row][col] == 1 or visited[row][col]:",
      "mutated_line": "if grid[row][col] == -1 or visited[row][col]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == -1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 0 < new_row < rows and 0 <= new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 < new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 0 > new_row < rows and 0 <= new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 > new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 0 == new_row < rows and 0 <= new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 == new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 0 <= new_row < rows and 0 < new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 < new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 0 <= new_row < rows and 0 > new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 > new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 0 <= new_row < rows and 0 == new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 == new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[2]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[2]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[0]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[0]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[0]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[0]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[-1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[-1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[2]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[2]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[0]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[0]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[0]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[0]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[-1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[-1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if row == destination[0] and col == destination[1]:",
      "mutated_line": "if row == destination[1] and col == destination[1]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[1] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if row == destination[0] and col == destination[1]:",
      "mutated_line": "if row == destination[-1] and col == destination[1]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[-1] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if row == destination[0] and col == destination[1]:",
      "mutated_line": "if row == destination[1] and col == destination[1]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[1] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if row == destination[0] and col == destination[1]:",
      "mutated_line": "if row == destination[0] and col == destination[2]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[2]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if row == destination[0] and col == destination[1]:",
      "mutated_line": "if row == destination[0] and col == destination[0]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[0]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if row == destination[0] and col == destination[1]:",
      "mutated_line": "if row == destination[0] and col == destination[0]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[0]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if row == destination[0] and col == destination[1]:",
      "mutated_line": "if row == destination[0] and col == destination[-1]:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[-1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_row = row + direction[0]",
      "mutated_line": "new_row = row + direction[1]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[1]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_row = row + direction[0]",
      "mutated_line": "new_row = row + direction[-1]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[-1]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_row = row + direction[0]",
      "mutated_line": "new_row = row + direction[1]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[1]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col + direction[2]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[2]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col + direction[0]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[0]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col + direction[0]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[0]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col + direction[-1]",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[-1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 1 <= new_row < rows and 0 <= new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 1 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if -1 <= new_row < rows and 0 <= new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if -1 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 1 <= new_row < rows and 0 <= new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 1 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 0 <= new_row < rows and 1 <= new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 1 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 0 <= new_row < rows and -1 <= new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and -1 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols:",
      "mutated_line": "if 0 <= new_row < rows and 1 <= new_col < cols:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 1 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[1]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[1]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[-1]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[-1]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[1]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[1]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[1]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[1]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[-1]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[-1]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:",
      "mutated_line": "if grid[source[0]][source[1]] == 1 or grid[destination[1]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[1]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path + [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "queue.append((new_row, new_col, path + [(row, col)]))",
      "mutated_line": "queue.append((new_row, new_col, path - [(row, col)]))",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path - [(row, col)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "queue.append((new_row, new_col, path + [(row, col)]))",
      "mutated_line": "queue.append((new_row, new_col, path * [(row, col)]))",
      "code": "from collections import deque\n\ndef shortest_path(grid, source, destination):\n    rows = len(grid)\n    cols = len(grid[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols):\n        return []\n    if destination[0] < 0 or destination[0] >= rows or destination[1] < 0 or (destination[1] >= cols):\n        return []\n    if grid[source[0]][source[1]] == 1 or grid[destination[0]][destination[1]] == 1:\n        return []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    queue.append((source[0], source[1], []))\n    while queue:\n        (row, col, path) = queue.popleft()\n        if row == destination[0] and col == destination[1]:\n            return path + [(row, col)]\n        if grid[row][col] == 1 or visited[row][col]:\n            continue\n        visited[row][col] = True\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                queue.append((new_row, new_col, path * [(row, col)]))\n    return []"
    }
  ]
}