{
  "task_id": "cf_17558",
  "entry_point": "is_valid_bst",
  "mutant_count": 60,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "is_balanced = True",
      "mutated_line": "is_balanced = False",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = False\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "while stack or root:",
      "mutated_line": "while stack and root:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack and root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "min_value = float('inf')",
      "mutated_line": "min_value = float('')",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "max_value = float('-inf')",
      "mutated_line": "max_value = float('')",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if node is None:",
      "mutated_line": "if node is not None:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is not None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if left_height == -1:",
      "mutated_line": "if left_height != -1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height != -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if right_height == -1:",
      "mutated_line": "if right_height != -1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height != -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if abs(left_height - right_height) > 1:",
      "mutated_line": "if abs(left_height - right_height) >= 1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) >= 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if abs(left_height - right_height) > 1:",
      "mutated_line": "if abs(left_height - right_height) <= 1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) <= 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if abs(left_height - right_height) > 1:",
      "mutated_line": "if abs(left_height - right_height) != 1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) != 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return max(left_height, right_height) + 1",
      "mutated_line": "return max(left_height, right_height) - 1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) - 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return max(left_height, right_height) + 1",
      "mutated_line": "return max(left_height, right_height) * 1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) * 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "if prev and root.value <= prev.value:",
      "mutated_line": "return (False, min_value, max_value, False)",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev or root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return True, min_value, max_value, is_balanced",
      "mutated_line": "return (False, min_value, max_value, is_balanced)",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (False, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 1\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return -1\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 1\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "if left_height == -1:",
      "mutated_line": "if left_height == +1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == +1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "is_balanced = False",
      "mutated_line": "is_balanced = True",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = True\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return +1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "if right_height == -1:",
      "mutated_line": "if right_height == +1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == +1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "is_balanced = False",
      "mutated_line": "is_balanced = True",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = True\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return +1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if abs(left_height - right_height) > 1:",
      "mutated_line": "if abs(left_height - right_height) > 2:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 2:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if abs(left_height - right_height) > 1:",
      "mutated_line": "if abs(left_height - right_height) > 0:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 0:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if abs(left_height - right_height) > 1:",
      "mutated_line": "if abs(left_height - right_height) > 0:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 0:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if abs(left_height - right_height) > 1:",
      "mutated_line": "if abs(left_height - right_height) > -1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > -1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "is_balanced = False",
      "mutated_line": "is_balanced = True",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = True\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return +1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(left_height, right_height) + 1",
      "mutated_line": "return max(left_height, right_height) + 2",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 2\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(left_height, right_height) + 1",
      "mutated_line": "return max(left_height, right_height) + 0",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 0\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(left_height, right_height) + 1",
      "mutated_line": "return max(left_height, right_height) + 0",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 0\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(left_height, right_height) + 1",
      "mutated_line": "return max(left_height, right_height) + -1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + -1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if prev and root.value <= prev.value:",
      "mutated_line": "return (False, min_value, max_value, False)",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value < prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if prev and root.value <= prev.value:",
      "mutated_line": "return (False, min_value, max_value, False)",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value > prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if prev and root.value <= prev.value:",
      "mutated_line": "return (False, min_value, max_value, False)",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value == prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if left_height == -1:",
      "mutated_line": "if left_height == -2:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -2:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if left_height == -1:",
      "mutated_line": "if left_height == -0:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -0:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if left_height == -1:",
      "mutated_line": "if left_height == -0:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -0:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if left_height == -1:",
      "mutated_line": "if left_height == --1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == --1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -2\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -0\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -0\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return --1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if right_height == -1:",
      "mutated_line": "if right_height == -2:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -2:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if right_height == -1:",
      "mutated_line": "if right_height == -0:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -0:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if right_height == -1:",
      "mutated_line": "if right_height == -0:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -0:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if right_height == -1:",
      "mutated_line": "if right_height == --1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == --1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -2\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -0\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -0\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return --1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if abs(left_height - right_height) > 1:",
      "mutated_line": "if abs(left_height + right_height) > 1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height + right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if abs(left_height - right_height) > 1:",
      "mutated_line": "if abs(left_height * right_height) > 1:",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height * right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -2\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -0\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -0\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return --1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return False, min_value, max_value, False",
      "mutated_line": "return (True, min_value, max_value, False)",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (True, min_value, max_value, False)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return False, min_value, max_value, False",
      "mutated_line": "return (False, min_value, max_value, True)",
      "code": "class TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    stack = []\n    prev = None\n    min_value = float('inf')\n    max_value = float('-inf')\n    is_balanced = True\n\n    def height(node):\n        nonlocal is_balanced\n        if node is None:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            is_balanced = False\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            is_balanced = False\n            return -1\n        if abs(left_height - right_height) > 1:\n            is_balanced = False\n            return -1\n        return max(left_height, right_height) + 1\n    height(root)\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and root.value <= prev.value:\n            return (False, min_value, max_value, True)\n        min_value = min(min_value, root.value)\n        max_value = max(max_value, root.value)\n        prev = root\n        root = root.right\n    return (True, min_value, max_value, is_balanced)"
    }
  ]
}