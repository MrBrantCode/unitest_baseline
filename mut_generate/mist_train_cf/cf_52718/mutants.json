{
  "task_id": "cf_52718",
  "entry_point": "find_negative_cycles",
  "mutant_count": 19,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "distance = [[float('inf')] * len(graph) for _ in range(len(graph))]",
      "mutated_line": "distance = [[float('inf')] / len(graph) for _ in range(len(graph))]",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] / len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "distance = [[float('inf')] * len(graph) for _ in range(len(graph))]",
      "mutated_line": "distance = [[float('inf')] + len(graph) for _ in range(len(graph))]",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] + len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "distance = [[float('inf')] * len(graph) for _ in range(len(graph))]",
      "mutated_line": "distance = [[float('inf')] ** len(graph) for _ in range(len(graph))]",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] ** len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if distance[i][i] < 0:",
      "mutated_line": "if distance[i][i] <= 0:",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] <= 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if distance[i][i] < 0:",
      "mutated_line": "if distance[i][i] >= 0:",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] >= 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if distance[i][i] < 0:",
      "mutated_line": "if distance[i][i] != 0:",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] != 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if distance[i][i] < 0:",
      "mutated_line": "if distance[i][i] < 1:",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 1:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if distance[i][i] < 0:",
      "mutated_line": "if distance[i][i] < -1:",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < -1:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if distance[i][i] < 0:",
      "mutated_line": "if distance[i][i] < 1:",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 1:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "start = cycle[0]",
      "mutated_line": "start = cycle[1]",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[1]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "start = cycle[0]",
      "mutated_line": "start = cycle[-1]",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[-1]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "start = cycle[0]",
      "mutated_line": "start = cycle[1]",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[1]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if distance[start][k] + distance[k][start] == distance[start][start]:",
      "mutated_line": "if distance[start][k] + distance[k][start] != distance[start][start]:",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] != distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if distance[start][k] + distance[k][start] == distance[start][start]:",
      "mutated_line": "if distance[start][k] - distance[k][start] == distance[start][start]:",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] - distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if distance[start][k] + distance[k][start] == distance[start][start]:",
      "mutated_line": "if distance[start][k] * distance[k][start] == distance[start][start]:",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] * distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "distance = [[float('inf')] * len(graph) for _ in range(len(graph))]",
      "mutated_line": "distance = [[float('')] * len(graph) for _ in range(len(graph))]",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])",
      "mutated_line": "distance[i][j] = min(distance[i][j], distance[i][k] - distance[k][j])",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] - distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])",
      "mutated_line": "distance[i][j] = min(distance[i][j], distance[i][k] * distance[k][j])",
      "code": "import sys\n\ndef find_negative_cycles(graph):\n    \"\"\"\n    Finds all negative cycles in a weighted graph represented as an adjacency matrix.\n\n    Args:\n    graph (list of lists): A 2D array where graph[i][j] is the weight of the edge from node i to node j.\n    \n    Returns:\n    list: A list of lists, where each sublist contains a negative cycle in the graph.\n    \"\"\"\n    distance = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            distance[i][j] = graph[i][j]\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance[i][j] = min(distance[i][j], distance[i][k] * distance[k][j])\n    negative_cycles = []\n    for i in range(len(graph)):\n        if distance[i][i] < 0:\n            negative_cycles.append([i])\n    for cycle in negative_cycles:\n        start = cycle[0]\n        for k in range(len(graph)):\n            if distance[start][k] + distance[k][start] == distance[start][start]:\n                cycle.append(k)\n                cycle.append(start)\n                break\n    return negative_cycles"
    }
  ]
}