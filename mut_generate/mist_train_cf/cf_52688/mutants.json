{
  "task_id": "cf_52688",
  "entry_point": "complex_computation",
  "mutant_count": 19,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) >= 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) >= 2 else 0\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) <= 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) <= 2 else 0\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) != 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) != 2 else 0\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 1",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 1\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else -1",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else -1\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 1",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 1\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 3 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 3 else 0\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 1 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 1 else 0\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 0 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 0 else 0\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 1 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 1 else 0\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > -2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > -2 else 0\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x / y, lst[2:]) if len(lst) > 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x / y, lst[2:]) if len(lst) > 2 else 0\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x + y, lst[2:]) if len(lst) > 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x + y, lst[2:]) if len(lst) > 2 else 0\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x ** y, lst[2:]) if len(lst) > 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x ** y, lst[2:]) if len(lst) > 2 else 0\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[3:]) if len(lst) > 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[3:]) if len(lst) > 2 else 0\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[1:]) if len(lst) > 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[1:]) if len(lst) > 2 else 0\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[0:]) if len(lst) > 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[0:]) if len(lst) > 2 else 0\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[1:]) if len(lst) > 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[1:]) if len(lst) > 2 else 0\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "product = reduce(lambda x, y: x * y, lst[2:]) if len(lst) > 2 else 0",
      "mutated_line": "product = reduce(lambda x, y: x * y, lst[-2:]) if len(lst) > 2 else 0",
      "code": "from math import floor\nfrom functools import reduce\n\ndef complex_computation(lst):\n    lst = [floor(abs(i)) for i in lst]\n    lst.sort()\n    product = reduce(lambda x, y: x * y, lst[-2:]) if len(lst) > 2 else 0\n    return product"
    }
  ]
}