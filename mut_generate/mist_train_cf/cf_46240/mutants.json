{
  "task_id": "cf_46240",
  "entry_point": "longestIncreasingPath",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if not matrix or not matrix[0]:",
      "mutated_line": "if not matrix and (not matrix[0]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix and (not matrix[0]):\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if lookup[i][j] != -1:",
      "mutated_line": "if lookup[i][j] == -1:",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] == -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "longest = 0",
      "mutated_line": "longest = 1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 1\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "longest = 0",
      "mutated_line": "longest = -1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = -1\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "longest = 0",
      "mutated_line": "longest = 1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 1\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "lookup[i][j] = longest + 1  # update the lookup table",
      "mutated_line": "lookup[i][j] = longest - 1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest - 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "lookup[i][j] = longest + 1  # update the lookup table",
      "mutated_line": "lookup[i][j] = longest * 1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest * 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 1\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return -1\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 1\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "lookup = [[-1]*n for _ in range(m)]",
      "mutated_line": "lookup = [[-1] / n for _ in range(m)]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] / n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "lookup = [[-1]*n for _ in range(m)]",
      "mutated_line": "lookup = [[-1] + n for _ in range(m)]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] + n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "lookup = [[-1]*n for _ in range(m)]",
      "mutated_line": "lookup = [[-1] ** n for _ in range(m)]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] ** n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return max(dfs(*chk) for chk in checkpoints) if checkpoints else 0",
      "mutated_line": "return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return max(dfs(*chk) for chk in checkpoints) if checkpoints else 0",
      "mutated_line": "return max((dfs(*chk) for chk in checkpoints)) if checkpoints else -1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return max(dfs(*chk) for chk in checkpoints) if checkpoints else 0",
      "mutated_line": "return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 1"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "if lookup[i][j] != -1:",
      "mutated_line": "if lookup[i][j] != +1:",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != +1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [1, 1, 0, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [1, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [-1, 1, 0, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [-1, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [1, 1, 0, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [1, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 2, 0, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 2, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 0, 0, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 0, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 0, 0, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 0, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, -1, 0, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, -1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 1, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 1, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, -1, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, -1, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 1, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 1, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 0, +1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, +1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [2, 0, -1, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [2, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [0, 0, -1, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [0, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [0, 0, -1, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [0, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [-1, 0, -1, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [-1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, 1, -1, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 1, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, -1, -1, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, -1, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, 1, -1, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 1, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, 0, +1, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, +1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, 0, -1, 1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 1]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, 0, -1, -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, -1]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, 0, -1, 1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 1]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(5):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(5):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(3):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(3):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(0):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(0):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(1):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(1):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(-4):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(-4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 <= x < m or 0 <= y < n or matrix[i][j] < matrix[x][y]:",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m or 0 <= y < n or matrix[i][j] < matrix[x][y]:\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lookup[i][j] = longest + 1  # update the lookup table",
      "mutated_line": "lookup[i][j] = longest + 2",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 2\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lookup[i][j] = longest + 1  # update the lookup table",
      "mutated_line": "lookup[i][j] = longest + 0",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 0\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lookup[i][j] = longest + 1  # update the lookup table",
      "mutated_line": "lookup[i][j] = longest + 0",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 0\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lookup[i][j] = longest + 1  # update the lookup table",
      "mutated_line": "lookup[i][j] = longest + -1",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + -1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]",
      "mutated_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] != -2]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] != -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if lookup[i][j] != -1:",
      "mutated_line": "if lookup[i][j] != -2:",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -2:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if lookup[i][j] != -1:",
      "mutated_line": "if lookup[i][j] != -0:",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -0:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if lookup[i][j] != -1:",
      "mutated_line": "if lookup[i][j] != -0:",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -0:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if lookup[i][j] != -1:",
      "mutated_line": "if lookup[i][j] != --1:",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != --1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 0, -2]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -2]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 0, -0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -0]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 0, -0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -0]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, 1, 0, -1]",
      "mutated_line": "dx = [0, 1, 0, --1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, --1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, 0, -2, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -2, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, 0, -0, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -0, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, 0, -0, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -0, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [1, 0, -1, 0]",
      "mutated_line": "dy = [1, 0, --1, 0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, --1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x, y = i + dx[k], j + dy[k]",
      "mutated_line": "(x, y) = (i - dx[k], j + dy[k])",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i - dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x, y = i + dx[k], j + dy[k]",
      "mutated_line": "(x, y) = (i * dx[k], j + dy[k])",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i * dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x, y = i + dx[k], j + dy[k]",
      "mutated_line": "(x, y) = (i + dx[k], j - dy[k])",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j - dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x, y = i + dx[k], j + dy[k]",
      "mutated_line": "(x, y) = (i + dx[k], j * dy[k])",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j * dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 < x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 < x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 > x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 > x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 == x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 == x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 <= x < m and 0 < y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 < y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 <= x < m and 0 > y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 > y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 <= x < m and 0 == y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 == y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 <= x < m and 0 <= y < n and (matrix[i][j] <= matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] <= matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 <= x < m and 0 <= y < n and (matrix[i][j] >= matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] >= matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 <= x < m and 0 <= y < n and (matrix[i][j] != matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] != matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not matrix or not matrix[0]:",
      "mutated_line": "if not matrix or not matrix[1]:",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[1]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not matrix or not matrix[0]:",
      "mutated_line": "if not matrix or not matrix[-1]:",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[-1]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not matrix or not matrix[0]:",
      "mutated_line": "if not matrix or not matrix[1]:",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[1]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m, n = len(matrix), len(matrix[0])",
      "mutated_line": "(m, n) = (len(matrix), len(matrix[1]))",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[1]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m, n = len(matrix), len(matrix[0])",
      "mutated_line": "(m, n) = (len(matrix), len(matrix[-1]))",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[-1]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m, n = len(matrix), len(matrix[0])",
      "mutated_line": "(m, n) = (len(matrix), len(matrix[1]))",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[1]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "lookup = [[-1]*n for _ in range(m)]",
      "mutated_line": "lookup = [[+1] * n for _ in range(m)]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[+1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]",
      "mutated_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == +2]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == +2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 1 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 1 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if -1 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if -1 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 1 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 1 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 <= x < m and 1 <= y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 1 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 <= x < m and -1 <= y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and -1 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if 0 <= x < m and 0 <= y < n and matrix[i][j] < matrix[x][y]:",
      "mutated_line": "if 0 <= x < m and 1 <= y < n and (matrix[i][j] < matrix[x][y]):",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 1 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lookup = [[-1]*n for _ in range(m)]",
      "mutated_line": "lookup = [[-2] * n for _ in range(m)]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-2] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lookup = [[-1]*n for _ in range(m)]",
      "mutated_line": "lookup = [[-0] * n for _ in range(m)]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-0] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lookup = [[-1]*n for _ in range(m)]",
      "mutated_line": "lookup = [[-0] * n for _ in range(m)]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-0] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "lookup = [[-1]*n for _ in range(m)]",
      "mutated_line": "lookup = [[--1] * n for _ in range(m)]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[--1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]",
      "mutated_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -3]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -3]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]",
      "mutated_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -1]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]",
      "mutated_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -0]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -0]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]",
      "mutated_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -1]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -1]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == -2]",
      "mutated_line": "checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == --2]",
      "code": "def longestIncreasingPath(matrix):\n\n    def dfs(i, j):\n        if lookup[i][j] != -1:\n            return lookup[i][j]\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        longest = 0\n        for k in range(4):\n            (x, y) = (i + dx[k], j + dy[k])\n            if 0 <= x < m and 0 <= y < n and (matrix[i][j] < matrix[x][y]):\n                longest = max(longest, dfs(x, y))\n        lookup[i][j] = longest + 1\n        return lookup[i][j]\n    if not matrix or not matrix[0]:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    lookup = [[-1] * n for _ in range(m)]\n    checkpoints = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == --2]\n    return max((dfs(*chk) for chk in checkpoints)) if checkpoints else 0"
    }
  ]
}