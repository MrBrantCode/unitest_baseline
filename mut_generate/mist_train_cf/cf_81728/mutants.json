{
  "task_id": "cf_81728",
  "entry_point": "pseudo_inverse",
  "mutant_count": 7,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef pseudo_inverse(matrix, threshold):\n    \"\"\"\"\"\"\n    (eigenvalues, eigenvectors) = np.linalg.eigh(matrix)\n    eigenvalues = np.maximum(eigenvalues, threshold)\n    inverse_eigenvalues = 1 / eigenvalues\n    pseudo_inverse_matrix = eigenvectors @ np.diag(inverse_eigenvalues) @ eigenvectors.T\n    return pseudo_inverse_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "inverse_eigenvalues = 1 / eigenvalues",
      "mutated_line": "inverse_eigenvalues = 1 * eigenvalues",
      "code": "import numpy as np\n\ndef pseudo_inverse(matrix, threshold):\n    \"\"\"\n    Calculate the pseudo inverse of a square symmetric covariance matrix using eigenvalue decomposition and regularization.\n\n    Parameters:\n    matrix (numpy array): The covariance matrix.\n    threshold (float): The minimum eigenvalue for regularization.\n\n    Returns:\n    numpy array: The pseudo inverse of the matrix.\n    \"\"\"\n    (eigenvalues, eigenvectors) = np.linalg.eigh(matrix)\n    eigenvalues = np.maximum(eigenvalues, threshold)\n    inverse_eigenvalues = 1 * eigenvalues\n    pseudo_inverse_matrix = eigenvectors @ np.diag(inverse_eigenvalues) @ eigenvectors.T\n    return pseudo_inverse_matrix"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "inverse_eigenvalues = 1 / eigenvalues",
      "mutated_line": "inverse_eigenvalues = 1 // eigenvalues",
      "code": "import numpy as np\n\ndef pseudo_inverse(matrix, threshold):\n    \"\"\"\n    Calculate the pseudo inverse of a square symmetric covariance matrix using eigenvalue decomposition and regularization.\n\n    Parameters:\n    matrix (numpy array): The covariance matrix.\n    threshold (float): The minimum eigenvalue for regularization.\n\n    Returns:\n    numpy array: The pseudo inverse of the matrix.\n    \"\"\"\n    (eigenvalues, eigenvectors) = np.linalg.eigh(matrix)\n    eigenvalues = np.maximum(eigenvalues, threshold)\n    inverse_eigenvalues = 1 // eigenvalues\n    pseudo_inverse_matrix = eigenvectors @ np.diag(inverse_eigenvalues) @ eigenvectors.T\n    return pseudo_inverse_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "inverse_eigenvalues = 1 / eigenvalues",
      "mutated_line": "inverse_eigenvalues = 2 / eigenvalues",
      "code": "import numpy as np\n\ndef pseudo_inverse(matrix, threshold):\n    \"\"\"\n    Calculate the pseudo inverse of a square symmetric covariance matrix using eigenvalue decomposition and regularization.\n\n    Parameters:\n    matrix (numpy array): The covariance matrix.\n    threshold (float): The minimum eigenvalue for regularization.\n\n    Returns:\n    numpy array: The pseudo inverse of the matrix.\n    \"\"\"\n    (eigenvalues, eigenvectors) = np.linalg.eigh(matrix)\n    eigenvalues = np.maximum(eigenvalues, threshold)\n    inverse_eigenvalues = 2 / eigenvalues\n    pseudo_inverse_matrix = eigenvectors @ np.diag(inverse_eigenvalues) @ eigenvectors.T\n    return pseudo_inverse_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "inverse_eigenvalues = 1 / eigenvalues",
      "mutated_line": "inverse_eigenvalues = 0 / eigenvalues",
      "code": "import numpy as np\n\ndef pseudo_inverse(matrix, threshold):\n    \"\"\"\n    Calculate the pseudo inverse of a square symmetric covariance matrix using eigenvalue decomposition and regularization.\n\n    Parameters:\n    matrix (numpy array): The covariance matrix.\n    threshold (float): The minimum eigenvalue for regularization.\n\n    Returns:\n    numpy array: The pseudo inverse of the matrix.\n    \"\"\"\n    (eigenvalues, eigenvectors) = np.linalg.eigh(matrix)\n    eigenvalues = np.maximum(eigenvalues, threshold)\n    inverse_eigenvalues = 0 / eigenvalues\n    pseudo_inverse_matrix = eigenvectors @ np.diag(inverse_eigenvalues) @ eigenvectors.T\n    return pseudo_inverse_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "inverse_eigenvalues = 1 / eigenvalues",
      "mutated_line": "inverse_eigenvalues = 0 / eigenvalues",
      "code": "import numpy as np\n\ndef pseudo_inverse(matrix, threshold):\n    \"\"\"\n    Calculate the pseudo inverse of a square symmetric covariance matrix using eigenvalue decomposition and regularization.\n\n    Parameters:\n    matrix (numpy array): The covariance matrix.\n    threshold (float): The minimum eigenvalue for regularization.\n\n    Returns:\n    numpy array: The pseudo inverse of the matrix.\n    \"\"\"\n    (eigenvalues, eigenvectors) = np.linalg.eigh(matrix)\n    eigenvalues = np.maximum(eigenvalues, threshold)\n    inverse_eigenvalues = 0 / eigenvalues\n    pseudo_inverse_matrix = eigenvectors @ np.diag(inverse_eigenvalues) @ eigenvectors.T\n    return pseudo_inverse_matrix"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "inverse_eigenvalues = 1 / eigenvalues",
      "mutated_line": "inverse_eigenvalues = -1 / eigenvalues",
      "code": "import numpy as np\n\ndef pseudo_inverse(matrix, threshold):\n    \"\"\"\n    Calculate the pseudo inverse of a square symmetric covariance matrix using eigenvalue decomposition and regularization.\n\n    Parameters:\n    matrix (numpy array): The covariance matrix.\n    threshold (float): The minimum eigenvalue for regularization.\n\n    Returns:\n    numpy array: The pseudo inverse of the matrix.\n    \"\"\"\n    (eigenvalues, eigenvectors) = np.linalg.eigh(matrix)\n    eigenvalues = np.maximum(eigenvalues, threshold)\n    inverse_eigenvalues = -1 / eigenvalues\n    pseudo_inverse_matrix = eigenvectors @ np.diag(inverse_eigenvalues) @ eigenvectors.T\n    return pseudo_inverse_matrix"
    }
  ]
}