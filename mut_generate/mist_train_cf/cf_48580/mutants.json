{
  "task_id": "cf_48580",
  "entry_point": "rounded_avg_custom_base",
  "mutant_count": 135,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 <= base <= 10 and n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 and n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 / med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 + med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = (med * (med - 1) / 2) ** med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "if sum_seq > limit:",
      "mutated_line": "if sum_seq >= limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq >= limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "if sum_seq > limit:",
      "mutated_line": "if sum_seq <= limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq <= limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "if sum_seq > limit:",
      "mutated_line": "if sum_seq != limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq != limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 <= base <= 10 or n >= m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n >= m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 <= base <= 10 or n <= m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n <= m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 <= base <= 10 or n != m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n != m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return +1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = 2  #1 and n are always divisors",
      "mutated_line": "i = 2",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 3\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = 2  #1 and n are always divisors",
      "mutated_line": "i = 2",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 1\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = 2  #1 and n are always divisors",
      "mutated_line": "i = 2",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 0\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = 2  #1 and n are always divisors",
      "mutated_line": "i = 2",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 1\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = 2  #1 and n are always divisors",
      "mutated_line": "i = 2",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = -2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 2",
      "mutated_line": "while i * i <= n:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 3\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 2",
      "mutated_line": "while i * i <= n:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 1\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 2",
      "mutated_line": "while i * i <= n:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 0\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 2",
      "mutated_line": "while i * i <= n:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 1\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 2",
      "mutated_line": "while i * i <= n:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = -2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i * i <= n:",
      "mutated_line": "if n % i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i < n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i * i <= n:",
      "mutated_line": "if n % i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i > n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i * i <= n:",
      "mutated_line": "if n % i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i == n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "convertString = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
      "mutated_line": "result = ''",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = ''\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = \"\"",
      "mutated_line": "while n > 0:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = 'MUTATED'\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while n > 0:",
      "mutated_line": "while n >= 0:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n >= 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while n > 0:",
      "mutated_line": "while n <= 0:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n <= 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while n > 0:",
      "mutated_line": "while n != 0:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n != 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "midpoint = 0.5 * n",
      "mutated_line": "midpoint = 0.5 / n",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 / n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "midpoint = 0.5 * n",
      "mutated_line": "midpoint = 0.5 + n",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 + n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "midpoint = 0.5 * n",
      "mutated_line": "midpoint = 0.5 ** n",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 ** n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "accum += weight",
      "mutated_line": "accum -= weight",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum -= weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "weights = [count / counts_sum for count in counts]",
      "mutated_line": "weights = [count * counts_sum for count in counts]",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count * counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "weights = [count / counts_sum for count in counts]",
      "mutated_line": "weights = [count // counts_sum for count in counts]",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count // counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) * 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) // 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "UOI",
      "lineno": 57,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return +1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 < base <= 10 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 < base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 > base <= 10 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 > base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 == base <= 10 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 == base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -2\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -0\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -0\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return --1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "while i * i <= n:",
      "mutated_line": "if n % i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i / i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "while i * i <= n:",
      "mutated_line": "if n % i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i + i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "while i * i <= n:",
      "mutated_line": "if n % i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i ** i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if n % i:",
      "mutated_line": "if n * i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n * i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if n % i:",
      "mutated_line": "if n + i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n + i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "else:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i -= 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "n /= i",
      "mutated_line": "n *= i",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n *= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 1:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while n > 0:",
      "mutated_line": "while n > -1:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > -1:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 1:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "result = convertString[n % base] + result",
      "mutated_line": "result = convertString[n % base] - result",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] - result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "result = convertString[n % base] + result",
      "mutated_line": "result = convertString[n % base] * result",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] * result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "n = n // base",
      "mutated_line": "n = n / base",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n / base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "n = n // base",
      "mutated_line": "n = n * base",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n * base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "midpoint = 0.5 * n",
      "mutated_line": "midpoint = 1.5 * n",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 1.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "midpoint = 0.5 * n",
      "mutated_line": "midpoint = -0.5 * n",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = -0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "midpoint = 0.5 * n",
      "mutated_line": "midpoint = 0 * n",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "midpoint = 0.5 * n",
      "mutated_line": "midpoint = 1 * n",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 1 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "midpoint = 0.5 * n",
      "mutated_line": "midpoint = -0.5 * n",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = -0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "accum = weights[0]",
      "mutated_line": "accum = weights[1]",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[1]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "accum = weights[0]",
      "mutated_line": "accum = weights[-1]",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[-1]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "accum = weights[0]",
      "mutated_line": "accum = weights[1]",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[1]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if accum < midpoint <= (accum + weight):",
      "mutated_line": "if accum <= midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum <= midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if accum < midpoint <= (accum + weight):",
      "mutated_line": "if accum >= midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum >= midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if accum < midpoint <= (accum + weight):",
      "mutated_line": "if accum != midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum != midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "nums = list(range(n, m + 1))",
      "mutated_line": "nums = list(range(n, m - 1))",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m - 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "nums = list(range(n, m + 1))",
      "mutated_line": "nums = list(range(n, m * 1))",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m * 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med / (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = (med + (med - 1)) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med ** (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 3 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 1 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 0 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 1 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / -2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -2\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -0\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -0\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return --1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 3 <= base <= 10 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 3 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 1 <= base <= 10 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 1 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 0 <= base <= 10 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 0 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 1 <= base <= 10 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 1 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not -2 <= base <= 10 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not -2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 <= base <= 11 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 11 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 <= base <= 9 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 9 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 <= base <= 0 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 0 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 <= base <= 1 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 1 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if not (2 <= base <= 10) or n > m:",
      "mutated_line": "if not 2 <= base <= -10 or n > m:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= -10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "else:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 2\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "else:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 0\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "else:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 0\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "else:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += -1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n == i * i:",
      "mutated_line": "if n != i * i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n != i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count -= 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "count += 2",
      "mutated_line": "count -= 2",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count -= 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i, weight in enumerate(weights[1:], start=1):",
      "mutated_line": "if accum < midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=2):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i, weight in enumerate(weights[1:], start=1):",
      "mutated_line": "if accum < midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=0):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i, weight in enumerate(weights[1:], start=1):",
      "mutated_line": "if accum < midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=0):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i, weight in enumerate(weights[1:], start=1):",
      "mutated_line": "if accum < midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=-1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if accum < midpoint <= (accum + weight):",
      "mutated_line": "if accum < midpoint <= accum - weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum - weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if accum < midpoint <= (accum + weight):",
      "mutated_line": "if accum < midpoint <= accum * weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum * weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nums = list(range(n, m + 1))",
      "mutated_line": "nums = list(range(n, m + 2))",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 2))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nums = list(range(n, m + 1))",
      "mutated_line": "nums = list(range(n, m + 0))",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 0))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nums = list(range(n, m + 1))",
      "mutated_line": "nums = list(range(n, m + 0))",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 0))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nums = list(range(n, m + 1))",
      "mutated_line": "nums = list(range(n, m + -1))",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + -1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med + 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med * 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if n == i * i:",
      "mutated_line": "if n == i / i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i / i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if n == i * i:",
      "mutated_line": "if n == i + i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i + i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if n == i * i:",
      "mutated_line": "if n == i ** i:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i ** i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 2\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 0\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 0\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += -1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count += 2",
      "mutated_line": "count += 3",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 3\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count += 2",
      "mutated_line": "count += 1",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 1\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count += 2",
      "mutated_line": "count += 0",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 0\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count += 2",
      "mutated_line": "count += 1",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 1\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count += 2",
      "mutated_line": "count += -2",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += -2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "result = convertString[n % base] + result",
      "mutated_line": "result = convertString[n * base] + result",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n * base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "result = convertString[n % base] + result",
      "mutated_line": "result = convertString[n + base] + result",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n + base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i, weight in enumerate(weights[1:], start=1):",
      "mutated_line": "if accum < midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[2:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i, weight in enumerate(weights[1:], start=1):",
      "mutated_line": "if accum < midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[0:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i, weight in enumerate(weights[1:], start=1):",
      "mutated_line": "if accum < midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[0:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i, weight in enumerate(weights[1:], start=1):",
      "mutated_line": "if accum < midpoint <= accum + weight:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[-1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 2) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 0) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - 0) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "sum_seq = (med * (med - 1)) / 2 * med",
      "mutated_line": "if sum_seq > limit:",
      "code": "def rounded_avg_custom_base(n, m, base, limit):\n    if not 2 <= base <= 10 or n > m:\n        return -1\n\n    def divisor_count(n):\n        count = 2\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if n == i * i:\n                    count += 1\n                else:\n                    count += 2\n                n /= i\n        return count\n\n    def base_convert(n, base):\n        convertString = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while n > 0:\n            result = convertString[n % base] + result\n            n = n // base\n        return result\n\n    def weighted_median(sorted_nums, weights):\n        n = sum(weights)\n        midpoint = 0.5 * n\n        accum = weights[0]\n        for (i, weight) in enumerate(weights[1:], start=1):\n            if accum < midpoint <= accum + weight:\n                return sorted_nums[i]\n            accum += weight\n    nums = list(range(n, m + 1))\n    counts = [divisor_count(num) for num in nums]\n    counts_sum = sum(counts)\n    weights = [count / counts_sum for count in counts]\n    med = weighted_median(nums, weights)\n    sum_seq = med * (med - -1) / 2 * med\n    if sum_seq > limit:\n        return -1\n    return base_convert(int(sum_seq), base)"
    }
  ]
}