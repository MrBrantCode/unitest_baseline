{
  "task_id": "cf_1762",
  "entry_point": "find_longest_palindrome",
  "mutant_count": 112,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "modified_string = '#' + '#'.join(string) + '#'",
      "mutated_line": "modified_string = '#' + '#'.join(string) - '#'",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) - '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "modified_string = '#' + '#'.join(string) + '#'",
      "mutated_line": "modified_string = ('#' + '#'.join(string)) * '#'",
      "code": "def find_longest_palindrome(string):\n    modified_string = ('#' + '#'.join(string)) * '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [0] / n",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] / n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [0] + n",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] + n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [0] ** n",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] ** n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "C = 0",
      "mutated_line": "C = 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 1\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "C = 0",
      "mutated_line": "C = -1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = -1\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "C = 0",
      "mutated_line": "C = 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 1\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "R = 0",
      "mutated_line": "R = 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 1\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "R = 0",
      "mutated_line": "R = -1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = -1\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "R = 0",
      "mutated_line": "R = 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 1\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "start_index = (center_index - max_length) // 2",
      "mutated_line": "start_index = (center_index - max_length) / 2",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) / 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "start_index = (center_index - max_length) // 2",
      "mutated_line": "start_index = (center_index - max_length) * 2",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) * 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "end_index = start_index + max_length - 1",
      "mutated_line": "end_index = start_index + max_length + 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length + 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "end_index = start_index + max_length - 1",
      "mutated_line": "end_index = (start_index + max_length) * 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = (start_index + max_length) * 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "modified_string = '#' + '#'.join(string) + '#'",
      "mutated_line": "modified_string = '#' - '#'.join(string) + '#'",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' - '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "modified_string = '#' + '#'.join(string) + '#'",
      "mutated_line": "modified_string = '#' * '#'.join(string) + '#'",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' * '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "modified_string = '#' + '#'.join(string) + '#'",
      "mutated_line": "modified_string = '#' + '#'.join(string) + ''",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + ''\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "j = 2 * C - i",
      "mutated_line": "j = 2 * C + i",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C + i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "j = 2 * C - i",
      "mutated_line": "j = 2 * C * i",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C * i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i < R:",
      "mutated_line": "if i <= R:",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i <= R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i < R:",
      "mutated_line": "if i >= R:",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i >= R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i < R:",
      "mutated_line": "if i != R:",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i != R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n or i - P[i] - 1 >= 0 or modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n or i - P[i] - 1 >= 0 or modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "P[i] += 1",
      "mutated_line": "P[i] -= 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] -= 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if i + P[i] > R:",
      "mutated_line": "if i + P[i] >= R:",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] >= R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if i + P[i] > R:",
      "mutated_line": "if i + P[i] <= R:",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] <= R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if i + P[i] > R:",
      "mutated_line": "if i + P[i] != R:",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] != R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "start_index = (center_index - max_length) // 2",
      "mutated_line": "start_index = (center_index + max_length) // 2",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index + max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "start_index = (center_index - max_length) // 2",
      "mutated_line": "start_index = center_index * max_length // 2",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = center_index * max_length // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "start_index = (center_index - max_length) // 2",
      "mutated_line": "start_index = (center_index - max_length) // 3",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 3\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "start_index = (center_index - max_length) // 2",
      "mutated_line": "start_index = (center_index - max_length) // 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 1\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "start_index = (center_index - max_length) // 2",
      "mutated_line": "start_index = (center_index - max_length) // 0",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 0\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "start_index = (center_index - max_length) // 2",
      "mutated_line": "start_index = (center_index - max_length) // 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 1\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "start_index = (center_index - max_length) // 2",
      "mutated_line": "start_index = (center_index - max_length) // -2",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // -2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "end_index = start_index + max_length - 1",
      "mutated_line": "end_index = start_index - max_length - 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index - max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "end_index = start_index + max_length - 1",
      "mutated_line": "end_index = start_index * max_length - 1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index * max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "end_index = start_index + max_length - 1",
      "mutated_line": "end_index = start_index + max_length - 2",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 2\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "end_index = start_index + max_length - 1",
      "mutated_line": "end_index = start_index + max_length - 0",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 0\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "end_index = start_index + max_length - 1",
      "mutated_line": "end_index = start_index + max_length - 0",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 0\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "end_index = start_index + max_length - 1",
      "mutated_line": "end_index = start_index + max_length - -1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - -1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "modified_string = '#' + '#'.join(string) + '#'",
      "mutated_line": "modified_string = '' + '#'.join(string) + '#'",
      "code": "def find_longest_palindrome(string):\n    modified_string = '' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [1] * n",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [1] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [-1] * n",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [-1] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [1] * n",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [1] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "j = 2 * C - i",
      "mutated_line": "j = 2 / C - i",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 / C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "j = 2 * C - i",
      "mutated_line": "j = 2 + C - i",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 + C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "j = 2 * C - i",
      "mutated_line": "j = 2 ** C - i",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 ** C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 <= n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 <= n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 >= n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 >= n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 != n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 != n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 > 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 > 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 < 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 < 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 == 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 == 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] != modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] != modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "P[i] += 1",
      "mutated_line": "P[i] += 2",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 2\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "P[i] += 1",
      "mutated_line": "P[i] += 0",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 0\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "P[i] += 1",
      "mutated_line": "P[i] += 0",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 0\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "P[i] += 1",
      "mutated_line": "P[i] += -1",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += -1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if i + P[i] > R:",
      "mutated_line": "if i - P[i] > R:",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i - P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if i + P[i] > R:",
      "mutated_line": "if i * P[i] > R:",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i * P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "R = i + P[i]",
      "mutated_line": "R = i - P[i]",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i - P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "R = i + P[i]",
      "mutated_line": "R = i * P[i]",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i * P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return string[start_index:end_index+1]",
      "mutated_line": "return string[start_index:end_index - 1]",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return string[start_index:end_index+1]",
      "mutated_line": "return string[start_index:end_index * 1]",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index * 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = 2 * C - i",
      "mutated_line": "j = 3 * C - i",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 3 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = 2 * C - i",
      "mutated_line": "j = 1 * C - i",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 1 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = 2 * C - i",
      "mutated_line": "j = 0 * C - i",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 0 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = 2 * C - i",
      "mutated_line": "j = 1 * C - i",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 1 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = 2 * C - i",
      "mutated_line": "j = -2 * C - i",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = -2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "P[i] = min(R - i, P[j])",
      "mutated_line": "P[i] = min(R + i, P[j])",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R + i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "P[i] = min(R - i, P[j])",
      "mutated_line": "P[i] = min(R * i, P[j])",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R * i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] - 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] - 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while (i + P[i]) * 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while (i + P[i]) * 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] + 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] + 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and (i - P[i]) * 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and (i - P[i]) * 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 1 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 1 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= -1 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= -1 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 1 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 1 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return string[start_index:end_index+1]",
      "mutated_line": "return string[start_index:end_index + 2]",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 2]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return string[start_index:end_index+1]",
      "mutated_line": "return string[start_index:end_index + 0]",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return string[start_index:end_index+1]",
      "mutated_line": "return string[start_index:end_index + 0]",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return string[start_index:end_index+1]",
      "mutated_line": "return string[start_index:end_index + -1]",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + -1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "modified_string = '#' + '#'.join(string) + '#'",
      "mutated_line": "modified_string = '#' + ''.join(string) + '#'",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + ''.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i - P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i - P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i * P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i * P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 2 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 2 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 0 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 0 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 0 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 0 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + -1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + -1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i + P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i + P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i * P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i * P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 2 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 2 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 0 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 0 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 0 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 0 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - -1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - -1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] - 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] - 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[(i + P[i]) * 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[(i + P[i]) * 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] + 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] + 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[(i - P[i]) * 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[(i - P[i]) * 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i - P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i - P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i * P[i] + 1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i * P[i] + 1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 2] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 2] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 0] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 0] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 0] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 0] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + -1] == modified_string[i - P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + -1] == modified_string[i - P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i + P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i + P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i * P[i] - 1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i * P[i] - 1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 2]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 2]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 0]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 0]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 0]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - 0]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and modified_string[i + P[i] + 1] == modified_string[i - P[i] - 1]:",
      "mutated_line": "while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - -1]):",
      "code": "def find_longest_palindrome(string):\n    modified_string = '#' + '#'.join(string) + '#'\n    n = len(modified_string)\n    P = [0] * n\n    C = 0\n    R = 0\n    for i in range(n):\n        j = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[j])\n        while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and (modified_string[i + P[i] + 1] == modified_string[i - P[i] - -1]):\n            P[i] += 1\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    max_length = max(P)\n    center_index = P.index(max_length)\n    start_index = (center_index - max_length) // 2\n    end_index = start_index + max_length - 1\n    return string[start_index:end_index + 1]"
    }
  ]
}