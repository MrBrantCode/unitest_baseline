{
  "task_id": "cf_48515",
  "entry_point": "find_nearest",
  "mutant_count": 39,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(queue) > k: heapq.heappop(queue)",
      "mutated_line": "if len(queue) >= k:",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) >= k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(queue) > k: heapq.heappop(queue)",
      "mutated_line": "if len(queue) <= k:",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) <= k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(queue) > k: heapq.heappop(queue)",
      "mutated_line": "if len(queue) != k:",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) != k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "diff = abs(num - target)",
      "mutated_line": "diff = abs(num + target)",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num + target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "diff = abs(num - target)",
      "mutated_line": "diff = abs(num * target)",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num * target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num <= target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num <= target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num >= target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num >= target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num != target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num != target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 1 if num < target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 1 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = -1 if num < target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = -1 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 1 if num < target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 1 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num < target else 2",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 2\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num < target else 0",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 0\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num < target else 0",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 0\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num < target else -1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else -1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "diff = abs(num - target)",
      "mutated_line": "diff = abs(num + target)",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num + target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "diff = abs(num - target)",
      "mutated_line": "diff = abs(num * target)",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num * target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num <= target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num <= target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num >= target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num >= target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num != target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num != target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 1 if num < target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 1 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = -1 if num < target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = -1 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 1 if num < target else 1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 1 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num < target else 2",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 2\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num < target else 0",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 0\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num < target else 0",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 0\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "direction = 0 if num < target else 1",
      "mutated_line": "direction = 0 if num < target else -1",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else -1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])",
      "mutated_line": "return sorted([heapq.heappop(queue)[3] for _ in range(min(k, len(queue)))])",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[3] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])",
      "mutated_line": "return sorted([heapq.heappop(queue)[1] for _ in range(min(k, len(queue)))])",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[1] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])",
      "mutated_line": "return sorted([heapq.heappop(queue)[0] for _ in range(min(k, len(queue)))])",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[0] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])",
      "mutated_line": "return sorted([heapq.heappop(queue)[1] for _ in range(min(k, len(queue)))])",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[1] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])",
      "mutated_line": "return sorted([heapq.heappop(queue)[-2] for _ in range(min(k, len(queue)))])",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[-2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "heapq.heappush(queue, (-diff, -direction, num))",
      "mutated_line": "heapq.heappush(queue, (+diff, -direction, num))",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (+diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "heapq.heappush(queue, (-diff, -direction, num))",
      "mutated_line": "heapq.heappush(queue, (-diff, +direction, num))",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, +direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])",
      "mutated_line": "heapq.heappop(queue)",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[3] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])",
      "mutated_line": "heapq.heappop(queue)",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[1] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])",
      "mutated_line": "heapq.heappop(queue)",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[0] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])",
      "mutated_line": "heapq.heappop(queue)",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[1] for _ in range(len(queue))])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return sorted([heapq.heappop(queue)[2] for _ in range(len(queue))])",
      "mutated_line": "heapq.heappop(queue)",
      "code": "import heapq\n\ndef find_nearest(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (diff, direction, num))\n    return sorted([heapq.heappop(queue)[2] for _ in range(min(k, len(queue)))])\n\ndef find_nearest_optimized(nums, target, k):\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        direction = 0 if num < target else 1\n        heapq.heappush(queue, (-diff, -direction, num))\n        if len(queue) > k:\n            heapq.heappop(queue)\n    return sorted([heapq.heappop(queue)[-2] for _ in range(len(queue))])"
    }
  ]
}