{
  "task_id": "cf_71041",
  "entry_point": "minimumMoves",
  "mutant_count": 223,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return +1"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) or (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) or (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][1], visited[0][1]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][1], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][-1], visited[0][1]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][-1], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][1], visited[0][1]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][1], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][2]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][2]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][0]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][0]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][0]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][0]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][-1]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][-1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([2, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([2, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([0, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([0, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([0, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([0, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([-1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([-1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 2], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 2], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 0], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 0], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 0], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 0], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, -1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, -1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 1], [2, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [2, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 1], [0, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [0, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 1], [0, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [0, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 1], [-1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [-1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 1], [1, 2])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 2])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 1], [1, 0])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 0])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 1], [1, 0])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 0])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[0][1]) = ([1, 1], [1, -1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, -1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) != (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) != (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) != (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) != (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n or 0 <= nx2 < n or 0 <= ny1 < n or (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n or 0 <= nx2 < n or 0 <= ny1 < n or (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(2):",
      "mutated_line": "for i in range(3):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(3):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(2):",
      "mutated_line": "for i in range(1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(1):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(2):",
      "mutated_line": "for i in range(0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(0):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(2):",
      "mutated_line": "for i in range(1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(1):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(2):",
      "mutated_line": "for i in range(-2):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(-2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n or 0 <= ny2 < n or grid[nx2][ny2] <= 1 or (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n or 0 <= ny2 < n or grid[nx2][ny2] <= 1 or (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [[[0, 0] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "visited = [[[1, 0] for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[1, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [[[0, 0] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "visited = [[[-1, 0] for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[-1, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [[[0, 0] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "visited = [[[1, 0] for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[1, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [[[0, 0] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "visited = [[[0, 1] for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 1] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [[[0, 0] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "visited = [[[0, -1] for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, -1] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [[[0, 0] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "visited = [[[0, 1] for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 1] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 0, 1), 1, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 1, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 0, 1), -1, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), -1, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 0, 1), 1, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 1, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 0, 1), 0, 1]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 1]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 0, 1), 0, -1]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, -1]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 0, 1), 0, 1]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 1]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[1][0], visited[0][1]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[1][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[-1][0], visited[0][1]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[-1][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[1][0], visited[0][1]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[1][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[1][1]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[1][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[-1][1]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[-1][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[0][0], visited[0][1] = [1, 1], [1,1]",
      "mutated_line": "(visited[0][0], visited[1][1]) = ([1, 1], [1, 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[1][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (1, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(1, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(-1, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (1, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(1, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 2), (1, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 2), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (1, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 0), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (1, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 0), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (1, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, -1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (2, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (2, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (0, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (0, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (-1, 0)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (-1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (1, 1)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 1)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (1, -1)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, -1)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (dx, dy) in [(0, 1), (1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (1, 1)]:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 1)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx1, ny1, nx2, ny2 = x1 + dx, y1 + dy, x2 + dx, y2 + dy",
      "mutated_line": "(nx1, ny1, nx2, ny2) = (x1 - dx, y1 + dy, x2 + dx, y2 + dy)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 - dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx1, ny1, nx2, ny2 = x1 + dx, y1 + dy, x2 + dx, y2 + dy",
      "mutated_line": "(nx1, ny1, nx2, ny2) = (x1 * dx, y1 + dy, x2 + dx, y2 + dy)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 * dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx1, ny1, nx2, ny2 = x1 + dx, y1 + dy, x2 + dx, y2 + dy",
      "mutated_line": "(nx1, ny1, nx2, ny2) = (x1 + dx, y1 - dy, x2 + dx, y2 + dy)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 - dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx1, ny1, nx2, ny2 = x1 + dx, y1 + dy, x2 + dx, y2 + dy",
      "mutated_line": "(nx1, ny1, nx2, ny2) = (x1 + dx, y1 * dy, x2 + dx, y2 + dy)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 * dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx1, ny1, nx2, ny2 = x1 + dx, y1 + dy, x2 + dx, y2 + dy",
      "mutated_line": "(nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 - dx, y2 + dy)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 - dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx1, ny1, nx2, ny2 = x1 + dx, y1 + dy, x2 + dx, y2 + dy",
      "mutated_line": "(nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 * dx, y2 + dy)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 * dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx1, ny1, nx2, ny2 = x1 + dx, y1 + dy, x2 + dx, y2 + dy",
      "mutated_line": "(nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 - dy)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 - dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx1, ny1, nx2, ny2 = x1 + dx, y1 + dy, x2 + dx, y2 + dy",
      "mutated_line": "(nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 * dy)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 * dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 < nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 < nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 > nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 > nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 == nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 == nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 < nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 < nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 > nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 > nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 == nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 == nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (0 < ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 < ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (0 > ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 > ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (0 == ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 == ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 < ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 < ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 > ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 > ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 == ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 == ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 or visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 or visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state != 0 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state != 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 < nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 < nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 > nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 > nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 == nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 == nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 < ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 < ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 > ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 > ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 == ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 == ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] < 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] < 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] > 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] > 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] == 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] == 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] != 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] != 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[nx2][ny2][nstate] = 1",
      "mutated_line": "visited[nx2][ny2][nstate] = 2",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[nx2][ny2][nstate] = 1",
      "mutated_line": "visited[nx2][ny2][nstate] = 0",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[nx2][ny2][nstate] = 1",
      "mutated_line": "visited[nx2][ny2][nstate] = 0",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[nx2][ny2][nstate] = 1",
      "mutated_line": "visited[nx2][ny2][nstate] = -1",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = -1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(1, 0, 0, 1), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(1, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(-1, 0, 0, 1), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(-1, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(1, 0, 0, 1), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(1, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 1, 0, 1), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 1, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, -1, 0, 1), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, -1, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 1, 0, 1), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 1, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 1, 1), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 1, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, -1, 1), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, -1, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 1, 1), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 1, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 0, 2), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 2), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 0, 0), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 0), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 0, 0), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 0), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q = deque([[(0, 0, 0, 1), 0, 0]])",
      "mutated_line": "q = deque([[(0, 0, 0, -1), 0, 0]])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, -1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n + 1, n - 2) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n + 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n * 1, n - 2) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n * 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n + 2) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n + 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n * 2) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n * 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n + 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n + 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n * 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n * 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n + 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n + 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n * 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n * 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 1 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 1 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if -1 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if -1 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 1 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 1 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 1 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 1 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and -1 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and -1 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 1 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 1 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (1 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (1 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (-1 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (-1 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (1 <= ny1 < n) and (0 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (1 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (1 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (1 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (-1 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (-1 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= nx1 < n and 0 <= nx2 < n and 0 <= ny1 < n and 0 <= ny2 < n:",
      "mutated_line": "if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (1 <= ny2 < n):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (1 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 or grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 or grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] != 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] != 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited[nx1][ny1][state] = 1",
      "mutated_line": "visited[nx1][ny1][state] = 2",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 2\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited[nx1][ny1][state] = 1",
      "mutated_line": "visited[nx1][ny1][state] = 0",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 0\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited[nx1][ny1][state] = 1",
      "mutated_line": "visited[nx1][ny1][state] = 0",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 0\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited[nx1][ny1][state] = 1",
      "mutated_line": "visited[nx1][ny1][state] = -1",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = -1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 1 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 1 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == -1 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == -1 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 1 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 1 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 - dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 - dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 * dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 * dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 + state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 + state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 * state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 * state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 - dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 - dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 * dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 * dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 + state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 + state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 * state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 * state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 1 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 1 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if -1 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if -1 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 1 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 1 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 1 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 1 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and -1 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and -1 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 1 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 1 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 2) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 2) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 0) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 0) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 0) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 0) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= -1) and (visited[nx2][ny2][nstate] == 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= -1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 1):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == -1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == -1):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] <= 1 and visited[nx2][ny2][nstate] == 0:",
      "mutated_line": "if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 1):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 2, n - 2) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 2, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 0, n - 2) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 0, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 0, n - 2) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 0, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - -1, n - 2) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - -1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 3) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 3) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 1) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 1) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 0) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 0) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 1) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 1) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - -2) and (x2, y2) == (n - 1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - -2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 2, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 2, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 0, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 0, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 0, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 0, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - -1, n - 1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - -1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 2):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 2):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 0):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 0):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 0):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (x1, y1) == (n-1, n-2) and (x2, y2) == (n-1, n-1):",
      "mutated_line": "if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - -1):",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - -1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] < 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] < 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] > 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] > 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] == 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] == 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] < 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] < 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] > 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] > 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] == 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] == 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 1:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 1:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == -1:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == -1:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 1:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 1:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 2 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 2 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 0 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 0 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 0 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 0 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, -1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, -1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 2 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 2 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 0 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 0 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 0 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 0 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nx2, ny2, nstate = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)",
      "mutated_line": "(nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, -1 - state)",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, -1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "q.append([(x1, y1, nx2, ny2), nstate, steps+1])",
      "mutated_line": "q.append([(x1, y1, nx2, ny2), nstate, steps - 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps - 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "q.append([(x1, y1, nx2, ny2), nstate, steps+1])",
      "mutated_line": "q.append([(x1, y1, nx2, ny2), nstate, steps * 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps * 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 2 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 2 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 0 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 0 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 0 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 0 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= -1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= -1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 2) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 2) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 0) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 0) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 0) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 0) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1 ) and visited[nx1][ny1][state] == 0:",
      "mutated_line": "if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= -1) and visited[nx1][ny1][state] == 0:",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= -1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "q.append([(nx1, ny1, nx2, ny2), state, steps+1])",
      "mutated_line": "q.append([(nx1, ny1, nx2, ny2), state, steps - 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps - 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "q.append([(nx1, ny1, nx2, ny2), state, steps+1])",
      "mutated_line": "q.append([(nx1, ny1, nx2, ny2), state, steps * 1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps * 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([(x1, y1, nx2, ny2), nstate, steps+1])",
      "mutated_line": "q.append([(x1, y1, nx2, ny2), nstate, steps + 2])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 2])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([(x1, y1, nx2, ny2), nstate, steps+1])",
      "mutated_line": "q.append([(x1, y1, nx2, ny2), nstate, steps + 0])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 0])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([(x1, y1, nx2, ny2), nstate, steps+1])",
      "mutated_line": "q.append([(x1, y1, nx2, ny2), nstate, steps + 0])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 0])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "q.append([(x1, y1, nx2, ny2), nstate, steps+1])",
      "mutated_line": "q.append([(x1, y1, nx2, ny2), nstate, steps + -1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + -1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q.append([(nx1, ny1, nx2, ny2), state, steps+1])",
      "mutated_line": "q.append([(nx1, ny1, nx2, ny2), state, steps + 2])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 2])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q.append([(nx1, ny1, nx2, ny2), state, steps+1])",
      "mutated_line": "q.append([(nx1, ny1, nx2, ny2), state, steps + 0])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 0])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q.append([(nx1, ny1, nx2, ny2), state, steps+1])",
      "mutated_line": "q.append([(nx1, ny1, nx2, ny2), state, steps + 0])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + 0])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q.append([(nx1, ny1, nx2, ny2), state, steps+1])",
      "mutated_line": "q.append([(nx1, ny1, nx2, ny2), state, steps + -1])",
      "code": "from collections import deque\n\ndef minimumMoves(grid):\n    n = len(grid)\n    visited = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    q = deque([[(0, 0, 0, 1), 0, 0]])\n    (visited[0][0], visited[0][1]) = ([1, 1], [1, 1])\n    while q:\n        (pos, state, steps) = q.popleft()\n        (x1, y1, x2, y2) = pos\n        if (x1, y1) == (n - 1, n - 2) and (x2, y2) == (n - 1, n - 1):\n            return steps\n        for (dx, dy) in [(0, 1), (1, 0)]:\n            (nx1, ny1, nx2, ny2) = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)\n            if 0 <= nx1 < n and 0 <= nx2 < n and (0 <= ny1 < n) and (0 <= ny2 < n):\n                if (grid[nx1][ny1] <= 1 and grid[nx2][ny2] <= 1) and visited[nx1][ny1][state] == 0:\n                    q.append([(nx1, ny1, nx2, ny2), state, steps + -1])\n                    visited[nx1][ny1][state] = 1\n        for i in range(2):\n            (nx2, ny2, nstate) = (x1 + dx, y1, 1 - state) if state == 0 else (x2, y2 + dy, 1 - state)\n            if 0 <= nx2 < n and 0 <= ny2 < n and (grid[nx2][ny2] <= 1) and (visited[nx2][ny2][nstate] == 0):\n                q.append([(x1, y1, nx2, ny2), nstate, steps + 1])\n                visited[nx2][ny2][nstate] = 1\n    return -1"
    }
  ]
}