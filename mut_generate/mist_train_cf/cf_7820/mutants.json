{
  "task_id": "cf_7820",
  "entry_point": "process_names",
  "mutant_count": 27,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def process_names(names):\n    \"\"\"\"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if len(names) <= 1000:",
      "mutated_line": "if len(names) < 1000:",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) < 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if len(names) <= 1000:",
      "mutated_line": "if len(names) > 1000:",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) > 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if len(names) <= 1000:",
      "mutated_line": "if len(names) == 1000:",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) == 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "mid = len(names) // 2",
      "mutated_line": "left = process_names(names[:mid])",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) / 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "mid = len(names) // 2",
      "mutated_line": "left = process_names(names[:mid])",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) * 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(names) <= 1000:",
      "mutated_line": "if len(names) <= 1001:",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1001:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(names) <= 1000:",
      "mutated_line": "if len(names) <= 999:",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 999:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(names) <= 1000:",
      "mutated_line": "if len(names) <= 0:",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 0:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(names) <= 1000:",
      "mutated_line": "if len(names) <= 1:",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(names) <= 1000:",
      "mutated_line": "if len(names) <= -1000:",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= -1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mid = len(names) // 2",
      "mutated_line": "left = process_names(names[:mid])",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 3\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mid = len(names) // 2",
      "mutated_line": "left = process_names(names[:mid])",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 1\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mid = len(names) // 2",
      "mutated_line": "left = process_names(names[:mid])",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 0\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mid = len(names) // 2",
      "mutated_line": "left = process_names(names[:mid])",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 1\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mid = len(names) // 2",
      "mutated_line": "left = process_names(names[:mid])",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // -2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if key not in merged_dict:",
      "mutated_line": "if key in merged_dict:",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]",
      "mutated_line": "names = [name.strip().lower() for name in names if name.isalpha() or len(name) >= 3]",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() or len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "names = sorted(names, key=lambda x: len(x), reverse=True)",
      "mutated_line": "names = sorted(names, key=lambda x: len(x), reverse=False)",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]\n    names = sorted(names, key=lambda x: len(x), reverse=False)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]",
      "mutated_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) > 3]",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) > 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]",
      "mutated_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) < 3]",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) < 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]",
      "mutated_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) == 3]",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) == 3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]",
      "mutated_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 4]",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 4]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]",
      "mutated_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 2]",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 2]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]",
      "mutated_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 0]",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 0]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]",
      "mutated_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 1]",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 1]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= 3]",
      "mutated_line": "names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= -3]",
      "code": "def process_names(names):\n    \"\"\"\n    Process a list of names and return a dictionary where keys are names and values are their lengths.\n    \n    The function ignores names containing numbers or special characters, removes duplicates, and only considers names with a length of at least 3 characters.\n    It converts names to lowercase, strips leading/trailing whitespace, and sorts them in descending order based on their lengths.\n    \n    The function uses recursion to efficiently handle large lists of names.\n    \"\"\"\n    if len(names) <= 1000:\n        return create_dictionary(names)\n    mid = len(names) // 2\n    left = process_names(names[:mid])\n    right = process_names(names[mid:])\n    return merge_dictionaries(left, right)\n\ndef create_dictionary(names):\n    names = list(set(names))\n    names = [name.strip().lower() for name in names if name.isalpha() and len(name) >= -3]\n    names = sorted(names, key=lambda x: len(x), reverse=True)\n    return {name: len(name) for name in names}\n\ndef merge_dictionaries(dict1, dict2):\n    merged_dict = dict1.copy()\n    for (key, value) in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"
    }
  ]
}