{
  "task_id": "cf_67877",
  "entry_point": "weighted_avg_divisor_count_power_base",
  "mutant_count": 135,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m and (not (2 <= base <= 20 and 1 <= k <= 10)):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m and (not (2 <= base <= 20 and 1 <= k <= 10)):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sum_weighted = 0",
      "mutated_line": "sum_weighted = 1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 1\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sum_weighted = 0",
      "mutated_line": "sum_weighted = -1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = -1\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sum_weighted = 0",
      "mutated_line": "sum_weighted = 1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 1\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sum_weights = 0",
      "mutated_line": "sum_weights = 1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 1\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sum_weights = 0",
      "mutated_line": "sum_weights = -1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = -1\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sum_weights = 0",
      "mutated_line": "sum_weights = 1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 1\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "sum_weighted += num * weight",
      "mutated_line": "sum_weighted -= num * weight",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted -= num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "sum_weights += weight",
      "mutated_line": "sum_weights -= weight",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights -= weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "weighted_mean = sum_weighted / sum_weights",
      "mutated_line": "weighted_mean = sum_weighted * sum_weights",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted * sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "weighted_mean = sum_weighted / sum_weights",
      "mutated_line": "weighted_mean = sum_weighted // sum_weights",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted // sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if base == 2:",
      "mutated_line": "result = '0b' + bin(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base != 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n >= m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n >= m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n <= m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n <= m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n != m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n != m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return +1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "for num in range(n, m - 1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m - 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "for num in range(n, m * 1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m * 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count_divisors = 0",
      "mutated_line": "count_divisors = 1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 1\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count_divisors = 0",
      "mutated_line": "count_divisors = -1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = -1\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count_divisors = 0",
      "mutated_line": "count_divisors = 1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 1\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "weight = count_divisors ** k",
      "mutated_line": "weight = count_divisors * k",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors * k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "weight = count_divisors ** k",
      "mutated_line": "weight = count_divisors + k",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors + k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sum_weighted += num * weight",
      "mutated_line": "sum_weighted += num / weight",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num / weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sum_weighted += num * weight",
      "mutated_line": "sum_weighted += num + weight",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num + weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sum_weighted += num * weight",
      "mutated_line": "sum_weighted += num ** weight",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num ** weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if base == 2:",
      "mutated_line": "result = '0b' + bin(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 3:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if base == 2:",
      "mutated_line": "result = '0b' + bin(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 1:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if base == 2:",
      "mutated_line": "result = '0b' + bin(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 0:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if base == 2:",
      "mutated_line": "result = '0b' + bin(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 1:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if base == 2:",
      "mutated_line": "result = '0b' + bin(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == -2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "result = \"0b\" + bin(weighted_mean)[2:]",
      "mutated_line": "result = '0b' - bin(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' - bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "result = \"0b\" + bin(weighted_mean)[2:]",
      "mutated_line": "result = '0b' * bin(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' * bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base != 8:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base != 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 or 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 or 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -2\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -0\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -0\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return --1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "for num in range(n, m + 2):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 2):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "for num in range(n, m + 0):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 0):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "for num in range(n, m + 0):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 0):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "for num in range(n, m + -1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + -1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, num + 1):",
      "mutated_line": "for i in range(2, num + 1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(2, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, num + 1):",
      "mutated_line": "for i in range(0, num + 1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(0, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, num + 1):",
      "mutated_line": "for i in range(0, num + 1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(0, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, num + 1):",
      "mutated_line": "for i in range(-1, num + 1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(-1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, num + 1):",
      "mutated_line": "for i in range(1, num - 1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num - 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, num + 1):",
      "mutated_line": "for i in range(1, num * 1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num * 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i != 0:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i != 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "count_divisors += 1",
      "mutated_line": "count_divisors -= 1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors -= 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "result = \"0b\" + bin(weighted_mean)[2:]",
      "mutated_line": "result = '' + bin(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 9:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 9:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 7:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 7:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 0:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 0:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 1:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 1:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == -8:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == -8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result = \"0o\" + oct(weighted_mean)[2:]",
      "mutated_line": "result = '0o' - oct(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' - oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result = \"0o\" + oct(weighted_mean)[2:]",
      "mutated_line": "result = '0o' * oct(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' * oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base != 16:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base != 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 < base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 < base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 > base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 > base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 == base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 == base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 1 < k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 < k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 1 > k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 > k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 1 == k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 == k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, num + 1):",
      "mutated_line": "for i in range(1, num + 2):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 2):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, num + 1):",
      "mutated_line": "for i in range(1, num + 0):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 0):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, num + 1):",
      "mutated_line": "for i in range(1, num + 0):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 0):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, num + 1):",
      "mutated_line": "for i in range(1, num + -1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + -1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num * i == 0:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num * i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num + i == 0:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num + i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == 1:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 1:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == -1:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == -1:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == 1:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 1:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "count_divisors += 1",
      "mutated_line": "count_divisors += 2",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 2\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "count_divisors += 1",
      "mutated_line": "count_divisors += 0",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 0\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "count_divisors += 1",
      "mutated_line": "count_divisors += 0",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 0\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "count_divisors += 1",
      "mutated_line": "count_divisors += -1",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += -1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result = \"0o\" + oct(weighted_mean)[2:]",
      "mutated_line": "result = '' + oct(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base == 17:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 17:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base == 15:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 15:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base == 0:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 0:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base == 1:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 1:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base == -16:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == -16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "result = \"0x\" + hex(weighted_mean)[2:]",
      "mutated_line": "result = '0x' - hex(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' - hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "result = \"0x\" + hex(weighted_mean)[2:]",
      "mutated_line": "result = '0x' * hex(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' * hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
      "mutated_line": "digits = ''",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = ''\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "result = \"\"",
      "mutated_line": "result = 'MUTATED'",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = 'MUTATED'\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean >= 0:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean >= 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean <= 0:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean <= 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean != 0:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean != 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (3 <= base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (3 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (1 <= base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (1 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (0 <= base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (0 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (1 <= base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (1 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (-2 <= base <= 20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (-2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 21 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 21 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 19 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 19 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 0 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 0 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 1 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 1 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= -20 and 1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= -20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 2 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 2 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 0 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 0 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 0 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 0 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and -1 <= k <= 10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and -1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 11):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 11):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 9):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 9):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 0):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 0):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 1):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 1):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= 10):",
      "mutated_line": "if n > m or not (2 <= base <= 20 and 1 <= k <= -10):",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= -10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "result = \"0b\" + bin(weighted_mean)[2:]",
      "mutated_line": "result = '0b' + bin(weighted_mean)[3:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[3:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "result = \"0b\" + bin(weighted_mean)[2:]",
      "mutated_line": "result = '0b' + bin(weighted_mean)[1:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[1:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "result = \"0b\" + bin(weighted_mean)[2:]",
      "mutated_line": "result = '0b' + bin(weighted_mean)[0:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[0:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "result = \"0b\" + bin(weighted_mean)[2:]",
      "mutated_line": "result = '0b' + bin(weighted_mean)[1:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[1:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "result = \"0b\" + bin(weighted_mean)[2:]",
      "mutated_line": "result = '0b' + bin(weighted_mean)[-2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[-2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "result = \"0x\" + hex(weighted_mean)[2:]",
      "mutated_line": "result = '' + hex(weighted_mean)[2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean > 1:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 1:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean > -1:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > -1:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean > 1:",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 1:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "result = digits[weighted_mean % base] + result",
      "mutated_line": "result = digits[weighted_mean % base] - result",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] - result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "result = digits[weighted_mean % base] + result",
      "mutated_line": "result = digits[weighted_mean % base] * result",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] * result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result = \"0o\" + oct(weighted_mean)[2:]",
      "mutated_line": "result = '0o' + oct(weighted_mean)[3:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[3:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result = \"0o\" + oct(weighted_mean)[2:]",
      "mutated_line": "result = '0o' + oct(weighted_mean)[1:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[1:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result = \"0o\" + oct(weighted_mean)[2:]",
      "mutated_line": "result = '0o' + oct(weighted_mean)[0:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[0:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result = \"0o\" + oct(weighted_mean)[2:]",
      "mutated_line": "result = '0o' + oct(weighted_mean)[1:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[1:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result = \"0o\" + oct(weighted_mean)[2:]",
      "mutated_line": "result = '0o' + oct(weighted_mean)[-2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[-2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "result = \"0x\" + hex(weighted_mean)[2:]",
      "mutated_line": "result = '0x' + hex(weighted_mean)[3:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[3:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "result = \"0x\" + hex(weighted_mean)[2:]",
      "mutated_line": "result = '0x' + hex(weighted_mean)[1:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[1:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "result = \"0x\" + hex(weighted_mean)[2:]",
      "mutated_line": "result = '0x' + hex(weighted_mean)[0:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[0:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "result = \"0x\" + hex(weighted_mean)[2:]",
      "mutated_line": "result = '0x' + hex(weighted_mean)[1:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[1:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "result = \"0x\" + hex(weighted_mean)[2:]",
      "mutated_line": "result = '0x' + hex(weighted_mean)[-2:]",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[-2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean % base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "result = digits[weighted_mean % base] + result",
      "mutated_line": "result = digits[weighted_mean * base] + result",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean * base] + result\n            weighted_mean //= base\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "result = digits[weighted_mean % base] + result",
      "mutated_line": "result = digits[weighted_mean + base] + result",
      "code": "def weighted_avg_divisor_count_power_base(n, m, base, k):\n    \"\"\"\n    This function calculates the weighted mean of the integers within the given range, \n    where the weights are the count of their divisors raised to the power 'k'. \n    The function then rounds the resulting average to the nearest integer and converts \n    it to the custom numbering system specified by 'base'. \n    If 'n' is greater than 'm', or 'base' and 'k' don't meet the conditions, \n    the function returns -1.\n    \"\"\"\n    if n > m or not (2 <= base <= 20 and 1 <= k <= 10):\n        return -1\n    sum_weighted = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        count_divisors = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count_divisors += 1\n        weight = count_divisors ** k\n        sum_weighted += num * weight\n        sum_weights += weight\n    weighted_mean = sum_weighted / sum_weights\n    weighted_mean = round(weighted_mean)\n    if base == 2:\n        result = '0b' + bin(weighted_mean)[2:]\n    elif base == 8:\n        result = '0o' + oct(weighted_mean)[2:]\n    elif base == 16:\n        result = '0x' + hex(weighted_mean)[2:]\n    else:\n        digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        result = ''\n        while weighted_mean > 0:\n            result = digits[weighted_mean + base] + result\n            weighted_mean //= base\n    return result"
    }
  ]
}