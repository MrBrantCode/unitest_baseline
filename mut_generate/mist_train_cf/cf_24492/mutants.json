{
  "task_id": "cf_24492",
  "entry_point": "convert_to_postfix",
  "mutant_count": 64,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "output = ''",
      "mutated_line": "output = 'MUTATED'",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = 'MUTATED'\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "output += operator_stack.pop()",
      "mutated_line": "output -= operator_stack.pop()",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output -= operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'': 1, '-': 1, '*': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '': 1, '*': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 2, '-': 1, '*': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 2, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 0, '-': 1, '*': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 0, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 0, '-': 1, '*': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 0, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': -1, '-': 1, '*': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': -1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 2, '*': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 2, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 0, '*': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 0, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 0, '*': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 0, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': -1, '*': 2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': -1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 3, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 3, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 1, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 1, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 0, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 0, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 1, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 1, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': -2, '/': 2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': -2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 3}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 3}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 1}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 1}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 0}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 0}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 1}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 1}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': -2}",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': -2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "output += char",
      "mutated_line": "output -= char",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output -= char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif char in precedence:",
      "mutated_line": "elif char not in precedence:",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char not in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "while (operator_stack and",
      "mutated_line": "while operator_stack or operator_stack[-1] in precedence or precedence[operator_stack[-1]] >= precedence[char]:",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack or operator_stack[-1] in precedence or precedence[operator_stack[-1]] >= precedence[char]:\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "output += operator_stack.pop()",
      "mutated_line": "output -= operator_stack.pop()",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output -= operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif char == '(':",
      "mutated_line": "elif char != '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char != '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "operator_stack[-1] in precedence and",
      "mutated_line": "while operator_stack and operator_stack[-1] not in precedence and (precedence[operator_stack[-1]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] not in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "precedence[operator_stack[-1]] >= precedence[char]):",
      "mutated_line": "while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] > precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] > precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "precedence[operator_stack[-1]] >= precedence[char]):",
      "mutated_line": "while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] < precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] < precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "precedence[operator_stack[-1]] >= precedence[char]):",
      "mutated_line": "while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] == precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] == precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif char == '(':",
      "mutated_line": "elif char == '':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "elif char == ')':",
      "mutated_line": "elif char != ')':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char != ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif char == ')':",
      "mutated_line": "elif char == '':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == '':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "while operator_stack and operator_stack[-1] != '(':",
      "mutated_line": "while operator_stack or operator_stack[-1] != '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack or operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "output += operator_stack.pop()",
      "mutated_line": "output -= operator_stack.pop()",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output -= operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if operator_stack and operator_stack[-1] == '(':",
      "mutated_line": "if operator_stack or operator_stack[-1] == '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack or operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "operator_stack[-1] in precedence and",
      "mutated_line": "while operator_stack and operator_stack[+1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[+1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while operator_stack and operator_stack[-1] != '(':",
      "mutated_line": "while operator_stack and operator_stack[-1] == '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] == '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if operator_stack and operator_stack[-1] == '(':",
      "mutated_line": "if operator_stack and operator_stack[-1] != '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] != '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "operator_stack[-1] in precedence and",
      "mutated_line": "while operator_stack and operator_stack[-2] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-2] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "operator_stack[-1] in precedence and",
      "mutated_line": "while operator_stack and operator_stack[-0] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-0] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "operator_stack[-1] in precedence and",
      "mutated_line": "while operator_stack and operator_stack[-0] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-0] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "operator_stack[-1] in precedence and",
      "mutated_line": "while operator_stack and operator_stack[--1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[--1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "precedence[operator_stack[-1]] >= precedence[char]):",
      "mutated_line": "while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[+1]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[+1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while operator_stack and operator_stack[-1] != '(':",
      "mutated_line": "while operator_stack and operator_stack[-1] != '':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if operator_stack and operator_stack[-1] == '(':",
      "mutated_line": "if operator_stack and operator_stack[-1] == '':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "precedence[operator_stack[-1]] >= precedence[char]):",
      "mutated_line": "while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-2]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-2]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "precedence[operator_stack[-1]] >= precedence[char]):",
      "mutated_line": "while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-0]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-0]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "precedence[operator_stack[-1]] >= precedence[char]):",
      "mutated_line": "while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-0]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-0]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "precedence[operator_stack[-1]] >= precedence[char]):",
      "mutated_line": "while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[--1]] >= precedence[char]):",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[--1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "while operator_stack and operator_stack[-1] != '(':",
      "mutated_line": "while operator_stack and operator_stack[+1] != '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[+1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if operator_stack and operator_stack[-1] == '(':",
      "mutated_line": "if operator_stack and operator_stack[+1] == '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[+1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while operator_stack and operator_stack[-1] != '(':",
      "mutated_line": "while operator_stack and operator_stack[-2] != '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-2] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while operator_stack and operator_stack[-1] != '(':",
      "mutated_line": "while operator_stack and operator_stack[-0] != '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-0] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while operator_stack and operator_stack[-1] != '(':",
      "mutated_line": "while operator_stack and operator_stack[-0] != '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-0] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while operator_stack and operator_stack[-1] != '(':",
      "mutated_line": "while operator_stack and operator_stack[--1] != '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[--1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if operator_stack and operator_stack[-1] == '(':",
      "mutated_line": "if operator_stack and operator_stack[-2] == '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-2] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if operator_stack and operator_stack[-1] == '(':",
      "mutated_line": "if operator_stack and operator_stack[-0] == '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-0] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if operator_stack and operator_stack[-1] == '(':",
      "mutated_line": "if operator_stack and operator_stack[-0] == '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[-0] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if operator_stack and operator_stack[-1] == '(':",
      "mutated_line": "if operator_stack and operator_stack[--1] == '(':",
      "code": "def convert_to_postfix(expression):\n    \"\"\"\n    Converts an infix expression to postfix notation.\n\n    Args:\n    expression (str): The infix expression to be converted.\n\n    Returns:\n    str: The postfix equivalent of the input expression.\n    \"\"\"\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output = ''\n    operator_stack = []\n    for char in expression:\n        if char.isalpha():\n            output += char\n        elif char in precedence:\n            while operator_stack and operator_stack[-1] in precedence and (precedence[operator_stack[-1]] >= precedence[char]):\n                output += operator_stack.pop()\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack and operator_stack[-1] != '(':\n                output += operator_stack.pop()\n            if operator_stack and operator_stack[--1] == '(':\n                operator_stack.pop()\n    while operator_stack:\n        output += operator_stack.pop()\n    return output"
    }
  ]
}