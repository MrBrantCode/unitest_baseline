{
  "task_id": "cf_63355",
  "entry_point": "kruskal_mst",
  "mutant_count": 32,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"Disjoint set data structure to manage connected components.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "class DisjointSet:\n    \"\"\"\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"Initialize the disjoint set with the given vertices.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "\"\"\"Find the root of the set containing the given vertex.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if self.parent[vertex] != vertex:",
      "mutated_line": "if self.parent[vertex] == vertex:",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] == vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "\"\"\"Merge the sets containing the given vertices.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if root1 != root2:",
      "mutated_line": "if root1 == root2:",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 == root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):",
      "mutated_line": "if disjoint_set.find(vertex1) == disjoint_set.find(vertex2):",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) == disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.rank = {v: 0 for v in vertices}",
      "mutated_line": "self.rank = {v: 1 for v in vertices}",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 1 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.rank = {v: 0 for v in vertices}",
      "mutated_line": "self.rank = {v: -1 for v in vertices}",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: -1 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.rank = {v: 0 for v in vertices}",
      "mutated_line": "self.rank = {v: 1 for v in vertices}",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 1 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if self.rank[root1] > self.rank[root2]:",
      "mutated_line": "if self.rank[root1] >= self.rank[root2]:",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] >= self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if self.rank[root1] > self.rank[root2]:",
      "mutated_line": "if self.rank[root1] <= self.rank[root2]:",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] <= self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if self.rank[root1] > self.rank[root2]:",
      "mutated_line": "if self.rank[root1] != self.rank[root2]:",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] != self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if self.rank[root1] == self.rank[root2]:",
      "mutated_line": "if self.rank[root1] != self.rank[root2]:",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] != self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "self.rank[root2] += 1",
      "mutated_line": "self.rank[root2] -= 1",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] -= 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "vertices.add(edge[0])",
      "mutated_line": "vertices.add(edge[1])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[1])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "vertices.add(edge[0])",
      "mutated_line": "vertices.add(edge[-1])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[-1])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "vertices.add(edge[0])",
      "mutated_line": "vertices.add(edge[1])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[1])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "vertices.add(edge[1])",
      "mutated_line": "vertices.add(edge[2])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[2])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "vertices.add(edge[1])",
      "mutated_line": "vertices.add(edge[0])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[0])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "vertices.add(edge[1])",
      "mutated_line": "vertices.add(edge[0])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[0])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "vertices.add(edge[1])",
      "mutated_line": "vertices.add(edge[-1])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[-1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "self.rank[root2] += 1",
      "mutated_line": "self.rank[root2] += 2",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 2\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "self.rank[root2] += 1",
      "mutated_line": "self.rank[root2] += 0",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 0\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "self.rank[root2] += 1",
      "mutated_line": "self.rank[root2] += 0",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 0\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "self.rank[root2] += 1",
      "mutated_line": "self.rank[root2] += -1",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += -1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "edges.sort(key=lambda edge: edge[2])",
      "mutated_line": "edges.sort(key=lambda edge: edge[3])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[3])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "edges.sort(key=lambda edge: edge[2])",
      "mutated_line": "edges.sort(key=lambda edge: edge[1])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[1])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "edges.sort(key=lambda edge: edge[2])",
      "mutated_line": "edges.sort(key=lambda edge: edge[0])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[0])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "edges.sort(key=lambda edge: edge[2])",
      "mutated_line": "edges.sort(key=lambda edge: edge[1])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[1])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "edges.sort(key=lambda edge: edge[2])",
      "mutated_line": "edges.sort(key=lambda edge: edge[-2])",
      "code": "class DisjointSet:\n    \"\"\"Disjoint set data structure to manage connected components.\"\"\"\n\n    def __init__(self, vertices):\n        \"\"\"Initialize the disjoint set with the given vertices.\"\"\"\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\ndef kruskal_mst(edges):\n    \"\"\"\n    Find the minimum spanning tree of the graph represented by the given edges.\n\n    Args:\n    edges: A list of edges where each edge is represented as a tuple of two vertices and a weight.\n\n    Returns:\n    A list of edges representing the minimum spanning tree.\n    \"\"\"\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    edges.sort(key=lambda edge: edge[-2])\n    mst = []\n    for edge in edges:\n        (vertex1, vertex2, weight) = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst"
    }
  ]
}