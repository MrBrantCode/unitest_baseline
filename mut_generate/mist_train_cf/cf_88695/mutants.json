{
  "task_id": "cf_88695",
  "entry_point": "navigate_maze",
  "mutant_count": 153,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][0] = 1",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 1\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][0] = -1",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = -1\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][0] = 1",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 1\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited = [[False] * n for _ in range(n)]",
      "mutated_line": "visited = [[False] / n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] / n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited = [[False] * n for _ in range(n)]",
      "mutated_line": "visited = [[False] + n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] + n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited = [[False] * n for _ in range(n)]",
      "mutated_line": "visited = [[False] ** n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] ** n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance = [[float('inf')] * n for _ in range(n)]",
      "mutated_line": "distance = [[float('inf')] / n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] / n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance = [[float('inf')] * n for _ in range(n)]",
      "mutated_line": "distance = [[float('inf')] + n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] + n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance = [[float('inf')] * n for _ in range(n)]",
      "mutated_line": "distance = [[float('inf')] ** n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] ** n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "previous = [[None] * n for _ in range(n)]",
      "mutated_line": "previous = [[None] / n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] / n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "previous = [[None] * n for _ in range(n)]",
      "mutated_line": "previous = [[None] + n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] + n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "previous = [[None] * n for _ in range(n)]",
      "mutated_line": "previous = [[None] ** n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] ** n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][1] = 0",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][1] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][-1] = 0",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][-1] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][1] = 0",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][1] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[row][col] = True",
      "mutated_line": "if (row, col) == (n - 1, n - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = False\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) != (n - 1, n - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) != (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n + 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n * 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "while (row, col) != (0, 0):",
      "mutated_line": "(row, col) = previous[row][col]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) == (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(+1, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(+1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 1), (1, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 1), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, -1), (1, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, -1), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 1), (1, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 1), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (2, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (2, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (0, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (0, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (0, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (0, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (-1, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (-1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 1), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 1), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, -1), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, -1), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 1), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 1), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (1, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (1, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (-1, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (-1, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (1, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (1, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, +1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, +1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, -1), (1, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (1, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, -1), (-1, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (-1, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, -1), (1, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (1, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 2)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 2)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 0)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 0)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 0)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 0)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, -1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, -1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(1, 0)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(1, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(-1, 0)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(-1, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(1, 0)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(1, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 1)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(0, -1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, -1)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 1)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[1][0] = 0",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[1][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[-1][0] = 0",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[-1][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[1][0] = 0",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[1][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cell = queue.pop(0)",
      "mutated_line": "(row, col) = cell",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(1)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cell = queue.pop(0)",
      "mutated_line": "(row, col) = cell",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(-1)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cell = queue.pop(0)",
      "mutated_line": "(row, col) = cell",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(1)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "new_row = row + direction[0]",
      "mutated_line": "new_row = row - direction[0]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row - direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "new_row = row + direction[0]",
      "mutated_line": "new_row = row * direction[0]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row * direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col - direction[1]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col - direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col * direction[1]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col * direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n or 0 <= new_col < n or maze[new_row][new_col] == 0 or (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n or 0 <= new_col < n or maze[new_row][new_col] == 0 or (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n + 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n * 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 2]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 0]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 0]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - -1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n + 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n + 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n * 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n * 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n - 1, n + 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n + 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n - 1, n * 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n * 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited = [[False] * n for _ in range(n)]",
      "mutated_line": "visited = [[True] * n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[True] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-2, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-2, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-0, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-0, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-0, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-0, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(--1, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(--1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, -2), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -2), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, -0), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -0), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, -0), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -0), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "directions = [(-1, 0), (1, 0), (0, --1), (0, 1)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, --1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n + 1, n - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n + 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n * 1, n - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n * 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n - 1, n + 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n + 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n - 1, n * 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n * 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 < new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 < new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 > new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 > new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 == new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 == new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n and 0 < new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 < new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n and 0 > new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 > new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n and 0 == new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 == new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] != 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] != 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "new_distance = distance[row][col] + 1",
      "mutated_line": "new_distance = distance[row][col] - 1",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] - 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "new_distance = distance[row][col] + 1",
      "mutated_line": "new_distance = distance[row][col] * 1",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] * 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if new_distance < distance[new_row][new_col]:",
      "mutated_line": "if new_distance <= distance[new_row][new_col]:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance <= distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if new_distance < distance[new_row][new_col]:",
      "mutated_line": "if new_distance >= distance[new_row][new_col]:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance >= distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if new_distance < distance[new_row][new_col]:",
      "mutated_line": "if new_distance != distance[new_row][new_col]:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance != distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 2][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 0][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 0][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if visited[n-1][n-1]:",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - -1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n + 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n * 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n + 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n * 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n - 2, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 2, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n - 0, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 0, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n - 0, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 0, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n - -1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - -1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n - 1, n - 2)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 2)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n - 1, n - 0)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 0)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n - 1, n - 0)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 0)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "row, col = n-1, n-1",
      "mutated_line": "(row, col) = (n - 1, n - -1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - -1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while (row, col) != (0, 0):",
      "mutated_line": "(row, col) = previous[row][col]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (1, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while (row, col) != (0, 0):",
      "mutated_line": "(row, col) = previous[row][col]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (-1, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while (row, col) != (0, 0):",
      "mutated_line": "(row, col) = previous[row][col]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (1, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while (row, col) != (0, 0):",
      "mutated_line": "(row, col) = previous[row][col]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 1):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while (row, col) != (0, 0):",
      "mutated_line": "(row, col) = previous[row][col]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, -1):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while (row, col) != (0, 0):",
      "mutated_line": "(row, col) = previous[row][col]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 1):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = [[float('inf')] * n for _ in range(n)]",
      "mutated_line": "distance = [[float('')] * n for _ in range(n)]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n - 2, n - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 2, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n - 0, n - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 0, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n - 0, n - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 0, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n - -1, n - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - -1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n - 1, n - 2):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 2):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n - 1, n - 0):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 0):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n - 1, n - 0):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 0):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (row, col) == (n-1, n-1):",
      "mutated_line": "if (row, col) == (n - 1, n - -1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - -1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "new_row = row + direction[0]",
      "mutated_line": "new_row = row + direction[1]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[1]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "new_row = row + direction[0]",
      "mutated_line": "new_row = row + direction[-1]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[-1]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "new_row = row + direction[0]",
      "mutated_line": "new_row = row + direction[1]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[1]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col + direction[2]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[2]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col + direction[0]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[0]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col + direction[0]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[0]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "new_col = col + direction[1]",
      "mutated_line": "new_col = col + direction[-1]",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[-1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 1 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 1 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if -1 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if -1 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 1 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 1 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n and 1 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 1 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n and -1 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and -1 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n and 1 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 1 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 1) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 1) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == -1) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == -1) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= new_row < n and 0 <= new_col < n and maze[new_row][new_col] == 0 and not visited[new_row][new_col]:",
      "mutated_line": "if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 1) and (not visited[new_row][new_col]):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 1) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "new_distance = distance[row][col] + 1",
      "mutated_line": "new_distance = distance[row][col] + 2",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 2\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "new_distance = distance[row][col] + 1",
      "mutated_line": "new_distance = distance[row][col] + 0",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 0\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "new_distance = distance[row][col] + 1",
      "mutated_line": "new_distance = distance[row][col] + 0",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 0\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "new_distance = distance[row][col] + 1",
      "mutated_line": "new_distance = distance[row][col] + -1",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + -1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 2, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 0, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 0, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - -1, n - 1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 2)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 0)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - 0)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "path = [(n-1, n-1)]",
      "mutated_line": "(row, col) = (n - 1, n - 1)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n    n = len(maze)\n    visited = [[False] * n for _ in range(n)]\n    distance = [[float('inf')] * n for _ in range(n)]\n    previous = [[None] * n for _ in range(n)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = [(0, 0)]\n    distance[0][0] = 0\n    while queue:\n        cell = queue.pop(0)\n        (row, col) = cell\n        visited[row][col] = True\n        if (row, col) == (n - 1, n - 1):\n            break\n        for direction in directions:\n            new_row = row + direction[0]\n            new_col = col + direction[1]\n            if 0 <= new_row < n and 0 <= new_col < n and (maze[new_row][new_col] == 0) and (not visited[new_row][new_col]):\n                new_distance = distance[row][col] + 1\n                if new_distance < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_distance\n                    previous[new_row][new_col] = (row, col)\n                    queue.append((new_row, new_col))\n    if visited[n - 1][n - 1]:\n        path = [(n - 1, n - -1)]\n        (row, col) = (n - 1, n - 1)\n        while (row, col) != (0, 0):\n            (row, col) = previous[row][col]\n            path.append((row, col))\n        path.reverse()\n        return path\n    return []"
    }
  ]
}