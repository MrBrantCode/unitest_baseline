{
  "task_id": "cf_89228",
  "entry_point": "get_kth_distinct_permutation",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "used = [False] * len(nums)",
      "mutated_line": "used = [False] / len(nums)",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] / len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "used = [False] * len(nums)",
      "mutated_line": "used = [False] + len(nums)",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] + len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "used = [False] * len(nums)",
      "mutated_line": "used = [False] ** len(nums)",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] ** len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(path) == len(nums):",
      "mutated_line": "if len(path) != len(nums):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) != len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return result[k-1] if k <= len(result) else []",
      "mutated_line": "return result[k - 1] if k < len(result) else []",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k < len(result) else []"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return result[k-1] if k <= len(result) else []",
      "mutated_line": "return result[k - 1] if k > len(result) else []",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k > len(result) else []"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return result[k-1] if k <= len(result) else []",
      "mutated_line": "return result[k - 1] if k == len(result) else []",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k == len(result) else []"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] and (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] and (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "used[i] = True",
      "mutated_line": "used[i] = False",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = False\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "used[i] = False",
      "mutated_line": "used[i] = True",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = True\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "used = [False] * len(nums)",
      "mutated_line": "used = [True] * len(nums)",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [True] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return result[k-1] if k <= len(result) else []",
      "mutated_line": "return result[k + 1] if k <= len(result) else []",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k + 1] if k <= len(result) else []"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return result[k-1] if k <= len(result) else []",
      "mutated_line": "return result[k * 1] if k <= len(result) else []",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k * 1] if k <= len(result) else []"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 or nums[i] == nums[i - 1] or (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 or nums[i] == nums[i - 1] or (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return result[k-1] if k <= len(result) else []",
      "mutated_line": "return result[k - 2] if k <= len(result) else []",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 2] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return result[k-1] if k <= len(result) else []",
      "mutated_line": "return result[k - 0] if k <= len(result) else []",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 0] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return result[k-1] if k <= len(result) else []",
      "mutated_line": "return result[k - 0] if k <= len(result) else []",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 0] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return result[k-1] if k <= len(result) else []",
      "mutated_line": "return result[k - -1] if k <= len(result) else []",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - -1] if k <= len(result) else []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i >= 0 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i >= 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i <= 0 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i <= 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i != 0 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i != 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] != nums[i - 1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] != nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 1 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 1 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > -1 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > -1 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 1 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 1 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i + 1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i + 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i * 1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i * 1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i + 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i + 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i * 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i * 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 2] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 2] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 0] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 0] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 0] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 0] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - -1] and (not used[i - 1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - -1] and (not used[i - 1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 2])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 2])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 0])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 0])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 0])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 0])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - -1])):",
      "code": "def get_kth_distinct_permutation(nums, k):\n\n    def backtrack(path, result, used):\n        if len(path) == len(nums):\n            result.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - -1])):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, result, used)\n            used[i] = False\n            path.pop()\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    backtrack([], result, used)\n    return result[k - 1] if k <= len(result) else []"
    }
  ]
}