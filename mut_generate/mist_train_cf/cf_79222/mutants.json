{
  "task_id": "cf_79222",
  "entry_point": "third_smallest_and_largest",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(unique_nums) < 3:",
      "mutated_line": "return 'Not enough unique elements'",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) <= 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(unique_nums) < 3:",
      "mutated_line": "return 'Not enough unique elements'",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) >= 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(unique_nums) < 3:",
      "mutated_line": "return 'Not enough unique elements'",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) != 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(unique_nums) < 3:",
      "mutated_line": "return 'Not enough unique elements'",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 4:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(unique_nums) < 3:",
      "mutated_line": "return 'Not enough unique elements'",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 2:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(unique_nums) < 3:",
      "mutated_line": "return 'Not enough unique elements'",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 0:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(unique_nums) < 3:",
      "mutated_line": "return 'Not enough unique elements'",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 1:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(unique_nums) < 3:",
      "mutated_line": "return 'Not enough unique elements'",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < -3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return \"Not enough unique elements\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return ''\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "smallest_nums = heapq.nsmallest(3, unique_nums)",
      "mutated_line": "smallest_nums = heapq.nsmallest(4, unique_nums)",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(4, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "smallest_nums = heapq.nsmallest(3, unique_nums)",
      "mutated_line": "smallest_nums = heapq.nsmallest(2, unique_nums)",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(2, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "smallest_nums = heapq.nsmallest(3, unique_nums)",
      "mutated_line": "smallest_nums = heapq.nsmallest(0, unique_nums)",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(0, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "smallest_nums = heapq.nsmallest(3, unique_nums)",
      "mutated_line": "smallest_nums = heapq.nsmallest(1, unique_nums)",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(1, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "smallest_nums = heapq.nsmallest(3, unique_nums)",
      "mutated_line": "smallest_nums = heapq.nsmallest(-3, unique_nums)",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(-3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "largest_nums = heapq.nlargest(3, unique_nums)",
      "mutated_line": "largest_nums = heapq.nlargest(4, unique_nums)",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(4, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "largest_nums = heapq.nlargest(3, unique_nums)",
      "mutated_line": "largest_nums = heapq.nlargest(2, unique_nums)",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(2, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "largest_nums = heapq.nlargest(3, unique_nums)",
      "mutated_line": "largest_nums = heapq.nlargest(0, unique_nums)",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(0, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "largest_nums = heapq.nlargest(3, unique_nums)",
      "mutated_line": "largest_nums = heapq.nlargest(1, unique_nums)",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(1, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "largest_nums = heapq.nlargest(3, unique_nums)",
      "mutated_line": "largest_nums = heapq.nlargest(-3, unique_nums)",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(-3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-1])"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "return smallest_nums[-1], largest_nums[-1]",
      "mutated_line": "return (smallest_nums[+1], largest_nums[-1])",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[+1], largest_nums[-1])"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "return smallest_nums[-1], largest_nums[-1]",
      "mutated_line": "return (smallest_nums[-1], largest_nums[+1])",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[+1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return smallest_nums[-1], largest_nums[-1]",
      "mutated_line": "return (smallest_nums[-2], largest_nums[-1])",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-2], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return smallest_nums[-1], largest_nums[-1]",
      "mutated_line": "return (smallest_nums[-0], largest_nums[-1])",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-0], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return smallest_nums[-1], largest_nums[-1]",
      "mutated_line": "return (smallest_nums[-0], largest_nums[-1])",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-0], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return smallest_nums[-1], largest_nums[-1]",
      "mutated_line": "return (smallest_nums[--1], largest_nums[-1])",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[--1], largest_nums[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return smallest_nums[-1], largest_nums[-1]",
      "mutated_line": "return (smallest_nums[-1], largest_nums[-2])",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return smallest_nums[-1], largest_nums[-1]",
      "mutated_line": "return (smallest_nums[-1], largest_nums[-0])",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return smallest_nums[-1], largest_nums[-1]",
      "mutated_line": "return (smallest_nums[-1], largest_nums[-0])",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[-0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return smallest_nums[-1], largest_nums[-1]",
      "mutated_line": "return (smallest_nums[-1], largest_nums[--1])",
      "code": "import heapq\n\ndef third_smallest_and_largest(lst):\n    unique_nums = list(set(lst))\n    if len(unique_nums) < 3:\n        return 'Not enough unique elements'\n    smallest_nums = heapq.nsmallest(3, unique_nums)\n    largest_nums = heapq.nlargest(3, unique_nums)\n    return (smallest_nums[-1], largest_nums[--1])"
    }
  ]
}