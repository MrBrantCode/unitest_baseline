{
  "task_id": "cf_95753",
  "entry_point": "navigate_maze",
  "mutant_count": 110,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if maze[0][0] != 0:",
      "mutated_line": "if maze[0][0] == 0:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] == 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(0, 0, [(0, 0)]) and []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) and []"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) != (len(maze) - 1, len(maze[0]) - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) != (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 and row >= len(maze) and (col < 0) and (col >= len(maze[0])) and (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "maze[row][col] = -1",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = +1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "maze[row][col] = 0",
      "mutated_line": "maze[row][col] = 1",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 1\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "maze[row][col] = 0",
      "mutated_line": "maze[row][col] = -1",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = -1\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "maze[row][col] = 0",
      "mutated_line": "maze[row][col] = 1",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 1\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if maze[0][0] != 0:",
      "mutated_line": "if maze[0][0] != 1:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 1:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if maze[0][0] != 0:",
      "mutated_line": "if maze[0][0] != -1:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != -1:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if maze[0][0] != 0:",
      "mutated_line": "if maze[0][0] != 1:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 1:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row <= 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row >= 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row != 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row > len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row < len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row == len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col <= 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col >= 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col != 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col > len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col < len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col == len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] == 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maze[row][col] = -1",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -2\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maze[row][col] = -1",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -0\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maze[row][col] = -1",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -0\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maze[row][col] = -1",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = --1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if new_path is not None:",
      "mutated_line": "if new_path is None:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if maze[0][0] != 0:",
      "mutated_line": "if maze[0][1] != 0:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][1] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if maze[0][0] != 0:",
      "mutated_line": "if maze[0][-1] != 0:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][-1] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if maze[0][0] != 0:",
      "mutated_line": "if maze[0][1] != 0:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][1] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(1, 0, [(0, 0)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(1, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(-1, 0, [(0, 0)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(-1, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(1, 0, [(0, 0)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(1, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(0, 1, [(0, 0)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 1, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(0, -1, [(0, 0)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, -1, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(0, 1, [(0, 0)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 1, [(0, 0)]) or []"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) + 1, len(maze[0]) - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) + 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) * 1, len(maze[0]) - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) * 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 1, len(maze[0]) + 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) + 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 1, len(maze[0]) * 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) * 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 1 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < -1 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 1 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 1 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < -1 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 1 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 1):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != -1):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 1):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(1, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(-1, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(1, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 2), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 0), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 0), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, -1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (1, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (-1, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (1, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, +1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (2, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (0, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (0, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (-1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 1), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, -1), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 1), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (+1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 1)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, -1)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 1)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_row, new_col = row + dx, col + dy",
      "mutated_line": "(new_row, new_col) = (row - dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row - dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_row, new_col = row + dx, col + dy",
      "mutated_line": "(new_row, new_col) = (row * dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row * dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_row, new_col = row + dx, col + dy",
      "mutated_line": "(new_row, new_col) = (row + dx, col - dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col - dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_row, new_col = row + dx, col + dy",
      "mutated_line": "(new_row, new_col) = (row + dx, col * dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col * dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "new_path = dfs(new_row, new_col, path + [(new_row, new_col)])",
      "mutated_line": "new_path = dfs(new_row, new_col, path - [(new_row, new_col)])",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path - [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "new_path = dfs(new_row, new_col, path + [(new_row, new_col)])",
      "mutated_line": "new_path = dfs(new_row, new_col, path * [(new_row, new_col)])",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path * [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if maze[0][0] != 0:",
      "mutated_line": "if maze[1][0] != 0:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[1][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if maze[0][0] != 0:",
      "mutated_line": "if maze[-1][0] != 0:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[-1][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if maze[0][0] != 0:",
      "mutated_line": "if maze[1][0] != 0:",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[1][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 2, len(maze[0]) - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 2, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 0, len(maze[0]) - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 0, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 0, len(maze[0]) - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 0, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - -1, len(maze[0]) - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - -1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 1, len(maze[0]) - 2):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 2):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 1, len(maze[0]) - 0):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 0):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 1, len(maze[0]) - 0):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 0):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 1, len(maze[0]) - -1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - -1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -2), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -0), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -0), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, --1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-2, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-0, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-0, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "(new_row, new_col) = (row + dx, col + dy)",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (--1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(0, 0, [(1, 0)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(1, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(0, 0, [(-1, 0)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(-1, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(0, 0, [(1, 0)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(1, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(0, 0, [(0, 1)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 1)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(0, 0, [(0, -1)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, -1)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(0, 0, [(0, 0)]) or []",
      "mutated_line": "return dfs(0, 0, [(0, 1)]) or []",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 1)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[1])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[-1])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:",
      "mutated_line": "return None",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[0]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[1])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 1, len(maze[1]) - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[1]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 1, len(maze[-1]) - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[-1]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (row, col) == (len(maze)-1, len(maze[0])-1):",
      "mutated_line": "if (row, col) == (len(maze) - 1, len(maze[1]) - 1):",
      "code": "from typing import List, Tuple\n\ndef navigate_maze(maze: List[List[int]]) -> List[Tuple[int, int]]:\n\n    def dfs(row: int, col: int, path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if (row, col) == (len(maze) - 1, len(maze[1]) - 1):\n            return path\n        if row < 0 or row >= len(maze) or col < 0 or (col >= len(maze[0])) or (maze[row][col] != 0):\n            return None\n        maze[row][col] = -1\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (new_row, new_col) = (row + dx, col + dy)\n            new_path = dfs(new_row, new_col, path + [(new_row, new_col)])\n            if new_path is not None:\n                return new_path\n        maze[row][col] = 0\n        return None\n    if maze[0][0] != 0:\n        return []\n    return dfs(0, 0, [(0, 0)]) or []"
    }
  ]
}