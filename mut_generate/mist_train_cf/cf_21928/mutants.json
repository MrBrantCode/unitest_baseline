{
  "task_id": "cf_21928",
  "entry_point": "find_shortest_path",
  "mutant_count": 185,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] < 0 and source[0] >= rows and (source[1] < 0) and (source[1] >= cols) and (destination[0] < 0) and (destination[0] >= rows) and (destination[1] < 0) and (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 and source[0] >= rows and (source[1] < 0) and (source[1] >= cols) and (destination[0] < 0) and (destination[0] >= rows) and (destination[1] < 0) and (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 and array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 and array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[source[0]][source[1]] = True",
      "mutated_line": "visited[source[0]][source[1]] = False",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = False\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] <= 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] <= 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] >= 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] >= 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] != 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] != 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] > rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] > rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] < rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] < rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] == rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] == rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] <= 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] <= 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] >= 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] >= 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] != 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] != 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] > cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] > cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] < cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] < cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] == cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] == cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] <= 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] <= 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] >= 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] >= 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] != 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] != 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] > rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] > rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] < rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] < rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] == rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] == rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] <= 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] <= 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] >= 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] >= 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] != 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] != 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] > cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] > cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] < cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] < cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] == cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] == cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] != 1 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] != 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] != 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] != 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] / cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] / cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] + cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] + cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] ** cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] ** cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if x == destination[0] and y == destination[1]:",
      "mutated_line": "if x == destination[0] or y == destination[1]:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] or y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cols = len(array[0])",
      "mutated_line": "cols = len(array[1])",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[1])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cols = len(array[0])",
      "mutated_line": "cols = len(array[-1])",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[-1])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cols = len(array[0])",
      "mutated_line": "cols = len(array[1])",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[1])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] < 1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] < -1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < -1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] < 1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 1 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 1 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 1 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < -1 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < -1 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 1 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 1 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 1) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 1) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < -1) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < -1) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 1) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 1) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 1) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 1) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < -1) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < -1) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 1) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 1) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 2 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 2 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 0 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 0 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 0 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 0 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == -1 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == -1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 2:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 2:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 0:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 0:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 0:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 0:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == -1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == -1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[source[0]][source[1]] = True",
      "mutated_line": "visited[source[0]][source[2]] = True",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[2]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[source[0]][source[1]] = True",
      "mutated_line": "visited[source[0]][source[0]] = True",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[0]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[source[0]][source[1]] = True",
      "mutated_line": "visited[source[0]][source[0]] = True",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[0]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[source[0]][source[1]] = True",
      "mutated_line": "visited[source[0]][source[-1]] = True",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[-1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(+1, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(+1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 1), (1, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 1), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, -1), (1, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, -1), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 1), (1, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 1), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (2, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (2, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (0, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (0, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (0, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (0, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (-1, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (-1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 1), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 1), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, -1), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, -1), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 1), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 1), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (1, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (1, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (-1, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (-1, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (1, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (1, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, +1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, +1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (1, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, -1), (-1, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (-1, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, -1), (1, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (1, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 2)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 2)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 0)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 0)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, -1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, -1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x == destination[0] and y == destination[1]:",
      "mutated_line": "if x != destination[0] and y == destination[1]:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x != destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x == destination[0] and y == destination[1]:",
      "mutated_line": "if x == destination[0] and y != destination[1]:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y != destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return path + [(x, y)]",
      "mutated_line": "return path - [(x, y)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path - [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return path + [(x, y)]",
      "mutated_line": "return path * [(x, y)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path * [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "new_x = x + dx",
      "mutated_line": "new_x = x - dx",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x - dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "new_x = x + dx",
      "mutated_line": "new_x = x * dx",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x * dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "new_y = y + dy",
      "mutated_line": "new_y = y - dy",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y - dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "new_y = y + dy",
      "mutated_line": "new_y = y * dy",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y * dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if (new_x >= 0 and new_x < rows and",
      "mutated_line": "if new_x >= 0 or new_x < rows or new_y >= 0 or (new_y < cols) or (not visited[new_x][new_y]) or (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 or new_x < rows or new_y >= 0 or (new_y < cols) or (not visited[new_x][new_y]) or (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[-1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[-1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[1] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[1] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[1] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[-1] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[-1] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (source[0] < 0 or source[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[1] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[1] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[2] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[2] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[0] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[0] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[0] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[0] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[-1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[-1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[2] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[2] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[0] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[0] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[0] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[0] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "source[1] < 0 or source[1] >= cols or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[-1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[-1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[1] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[1] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[-1] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[-1] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[1] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[1] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[1] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[1] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[-1] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[-1] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "destination[0] < 0 or destination[0] >= rows or",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[1] >= rows) or (destination[1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[1] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[2] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[2] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[0] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[0] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[0] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[0] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[-1] < 0) or (destination[1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[-1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[2] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[2] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[0] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[0] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[0] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[0] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "destination[1] < 0 or destination[1] >= cols):",
      "mutated_line": "if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[-1] >= cols):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[-1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visited = [[False] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[True] * cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[True] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[source[0]][source[1]] = True",
      "mutated_line": "visited[source[1]][source[1]] = True",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[1]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[source[0]][source[1]] = True",
      "mutated_line": "visited[source[-1]][source[1]] = True",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[-1]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[source[0]][source[1]] = True",
      "mutated_line": "visited[source[1]][source[1]] = True",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[1]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((source[0], source[1], []))",
      "mutated_line": "queue.append((source[1], source[1], []))",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[1], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((source[0], source[1], []))",
      "mutated_line": "queue.append((source[-1], source[1], []))",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[-1], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((source[0], source[1], []))",
      "mutated_line": "queue.append((source[1], source[1], []))",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[1], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((source[0], source[1], []))",
      "mutated_line": "queue.append((source[0], source[2], []))",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[2], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((source[0], source[1], []))",
      "mutated_line": "queue.append((source[0], source[0], []))",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[0], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((source[0], source[1], []))",
      "mutated_line": "queue.append((source[0], source[0], []))",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[0], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((source[0], source[1], []))",
      "mutated_line": "queue.append((source[0], source[-1], []))",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[-1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-2, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-2, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-0, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-0, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-0, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-0, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(--1, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(--1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, -2), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -2), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, -0), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -0), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, -0), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -0), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "moves = [(-1, 0), (1, 0), (0, --1), (0, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, --1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (new_x >= 0 and new_x < rows and",
      "mutated_line": "if new_x > 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x > 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (new_x >= 0 and new_x < rows and",
      "mutated_line": "if new_x < 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x < 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (new_x >= 0 and new_x < rows and",
      "mutated_line": "if new_x == 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x == 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (new_x >= 0 and new_x < rows and",
      "mutated_line": "if new_x >= 0 and new_x <= rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x <= rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (new_x >= 0 and new_x < rows and",
      "mutated_line": "if new_x >= 0 and new_x >= rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x >= rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if (new_x >= 0 and new_x < rows and",
      "mutated_line": "if new_x >= 0 and new_x != rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x != rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "new_y >= 0 and new_y < cols and",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y > 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y > 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "new_y >= 0 and new_y < cols and",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y < 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y < 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "new_y >= 0 and new_y < cols and",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y == 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y == 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "new_y >= 0 and new_y < cols and",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y <= cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y <= cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "new_y >= 0 and new_y < cols and",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y >= cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y >= cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "new_y >= 0 and new_y < cols and",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y != cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y != cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "array[new_x][new_y] != 1):",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] == 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] == 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "visited[new_x][new_y] = True",
      "mutated_line": "visited[new_x][new_y] = False",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = False\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[2]] == 1 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[2]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[0]] == 1 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[0]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[0]] == 1 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[0]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[-1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[-1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[2]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[2]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[0]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[0]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[0]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[0]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[-1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[-1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x == destination[0] and y == destination[1]:",
      "mutated_line": "if x == destination[1] and y == destination[1]:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[1] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x == destination[0] and y == destination[1]:",
      "mutated_line": "if x == destination[-1] and y == destination[1]:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[-1] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x == destination[0] and y == destination[1]:",
      "mutated_line": "if x == destination[1] and y == destination[1]:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[1] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x == destination[0] and y == destination[1]:",
      "mutated_line": "if x == destination[0] and y == destination[2]:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[2]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x == destination[0] and y == destination[1]:",
      "mutated_line": "if x == destination[0] and y == destination[0]:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[0]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x == destination[0] and y == destination[1]:",
      "mutated_line": "if x == destination[0] and y == destination[0]:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[0]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x == destination[0] and y == destination[1]:",
      "mutated_line": "if x == destination[0] and y == destination[-1]:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[-1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (new_x >= 0 and new_x < rows and",
      "mutated_line": "if new_x >= 1 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 1 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (new_x >= 0 and new_x < rows and",
      "mutated_line": "if new_x >= -1 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= -1 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if (new_x >= 0 and new_x < rows and",
      "mutated_line": "if new_x >= 1 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 1 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "new_y >= 0 and new_y < cols and",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= 1) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 1) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "new_y >= 0 and new_y < cols and",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= -1) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= -1) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "new_y >= 0 and new_y < cols and",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= 1) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 1) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "array[new_x][new_y] != 1):",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 2):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 2):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "array[new_x][new_y] != 1):",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 0):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 0):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "array[new_x][new_y] != 1):",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 0):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 0):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "array[new_x][new_y] != 1):",
      "mutated_line": "if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != -1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[1]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[1]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[-1]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[-1]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[1]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[1]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[1]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[1]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[-1]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[-1]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:",
      "mutated_line": "if array[source[0]][source[1]] == 1 or array[destination[1]][destination[1]] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[1]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path + [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "queue.append((new_x, new_y, path + [(x, y)]))",
      "mutated_line": "queue.append((new_x, new_y, path - [(x, y)]))",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path - [(x, y)]))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "queue.append((new_x, new_y, path + [(x, y)]))",
      "mutated_line": "queue.append((new_x, new_y, path * [(x, y)]))",
      "code": "from collections import deque\n\ndef find_shortest_path(array, source, destination):\n    rows = len(array)\n    cols = len(array[0])\n    if source[0] < 0 or source[0] >= rows or source[1] < 0 or (source[1] >= cols) or (destination[0] < 0) or (destination[0] >= rows) or (destination[1] < 0) or (destination[1] >= cols):\n        return []\n    if array[source[0]][source[1]] == 1 or array[destination[0]][destination[1]] == 1:\n        return []\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque()\n    visited[source[0]][source[1]] = True\n    queue.append((source[0], source[1], []))\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while queue:\n        (x, y, path) = queue.popleft()\n        if x == destination[0] and y == destination[1]:\n            return path + [(x, y)]\n        for (dx, dy) in moves:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_x < rows and (new_y >= 0) and (new_y < cols) and (not visited[new_x][new_y]) and (array[new_x][new_y] != 1):\n                visited[new_x][new_y] = True\n                queue.append((new_x, new_y, path * [(x, y)]))\n    return []"
    }
  ]
}