{
  "task_id": "cf_56921",
  "entry_point": "minPathWithBlockedCells",
  "mutant_count": 96,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[0]][blockedCell[1]] = +1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = +1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return +1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[0]][blockedCell[1]] = -2",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -2\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[0]][blockedCell[1]] = -0",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -0\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[0]][blockedCell[1]] = -0",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -0\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[0]][blockedCell[1]] = --1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = --1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if distances[i][j] != -1:",
      "mutated_line": "if distances[i][j] == -1:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if distances[i][j] == k:",
      "mutated_line": "if distances[i][j] != k:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -2\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -0\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -0\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return --1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[0]][blockedCell[2]] = -1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[2]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[0]][blockedCell[0]] = -1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[0]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[0]][blockedCell[0]] = -1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[0]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[0]][blockedCell[-1]] = -1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[-1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if distances[i][j] != -1:",
      "mutated_line": "if distances[i][j] != +1:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != +1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[i][j] = 0",
      "mutated_line": "distances[i][j] = 1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 1\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[i][j] = 0",
      "mutated_line": "distances[i][j] = -1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = -1\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[i][j] = 0",
      "mutated_line": "distances[i][j] = 1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 1\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[1]][blockedCell[1]] = -1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[1]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[-1]][blockedCell[1]] = -1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[-1]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distances[blockedCell[0]][blockedCell[1]] = -1",
      "mutated_line": "distances[blockedCell[1]][blockedCell[1]] = -1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[1]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if distances[i][j] != -1:",
      "mutated_line": "if distances[i][j] != -2:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -2:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if distances[i][j] != -1:",
      "mutated_line": "if distances[i][j] != -0:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -0:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if distances[i][j] != -1:",
      "mutated_line": "if distances[i][j] != -0:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -0:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if distances[i][j] != -1:",
      "mutated_line": "if distances[i][j] != --1:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != --1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(1, -1), (0, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(1, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(-1, -1), (0, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(-1, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(1, -1), (0, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(1, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, +1), (0, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, +1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (1, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (1, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (-1, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (-1, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (1, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (1, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 2), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 2), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 0), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 0), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 0), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 0), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, -1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (+1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (+1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 1), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 1), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, -1), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, -1), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 1), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 1), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (2, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (2, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (0, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (0, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (0, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (0, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (-1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (-1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 1)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 1)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, -1)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, -1)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 1)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 1)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N or 0 <= new_j < N or distances[new_i][new_j] != -1:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N or 0 <= new_j < N or distances[new_i][new_j] != -1:\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -2), (0, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -2), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -0), (0, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -0), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -0), (0, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -0), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, --1), (0, 1), (-1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, --1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-2, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-2, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-0, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-0, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (-0, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-0, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, 1), (--1, 0), (1, 0)]",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (--1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i - direction[0], cur_j + direction[1])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i - direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i * direction[0], cur_j + direction[1])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i * direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i + direction[0], cur_j - direction[1])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j - direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i + direction[0], cur_j * direction[1])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j * direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 < new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 < new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 > new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 > new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 == new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 == new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 0 < new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 < new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 0 > new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 > new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 0 == new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 == new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] == -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] == -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_distance = distances[cur_i][cur_j] + 1",
      "mutated_line": "new_distance = distances[cur_i][cur_j] - 1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] - 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_distance = distances[cur_i][cur_j] + 1",
      "mutated_line": "new_distance = distances[cur_i][cur_j] * 1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] * 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if new_distance < distances[new_i][new_j]:",
      "mutated_line": "if new_distance <= distances[new_i][new_j]:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance <= distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if new_distance < distances[new_i][new_j]:",
      "mutated_line": "if new_distance >= distances[new_i][new_j]:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance >= distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if new_distance < distances[new_i][new_j]:",
      "mutated_line": "if new_distance != distances[new_i][new_j]:",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance != distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 1 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 1 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if -1 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if -1 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 1 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 1 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 1 <= new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 1 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and -1 <= new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and -1 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 1 <= new_j < N and (distances[new_i][new_j] != -1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 1 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != +1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != +1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "new_distance = distances[cur_i][cur_j] + 1",
      "mutated_line": "new_distance = distances[cur_i][cur_j] + 2",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 2\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "new_distance = distances[cur_i][cur_j] + 1",
      "mutated_line": "new_distance = distances[cur_i][cur_j] + 0",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 0\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "new_distance = distances[cur_i][cur_j] + 1",
      "mutated_line": "new_distance = distances[cur_i][cur_j] + 0",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 0\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "new_distance = distances[cur_i][cur_j] + 1",
      "mutated_line": "new_distance = distances[cur_i][cur_j] + -1",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + -1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i + direction[1], cur_j + direction[1])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[1], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i + direction[-1], cur_j + direction[1])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[-1], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i + direction[1], cur_j + direction[1])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[1], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i + direction[0], cur_j + direction[2])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[2])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i + direction[0], cur_j + direction[0])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[0])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i + direction[0], cur_j + direction[0])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[0])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "new_i, new_j = cur_i + direction[0], cur_j + direction[1]",
      "mutated_line": "(new_i, new_j) = (cur_i + direction[0], cur_j + direction[-1])",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[-1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -2):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -2):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -0):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -0):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -0):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != -0):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= new_i < N and 0 <= new_j < N and distances[new_i][new_j] != -1:",
      "mutated_line": "if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != --1):",
      "code": "from queue import Queue\nimport sys\n\ndef minPathWithBlockedCells(grid, k, blockedCells):\n    N = len(grid)\n    distances = [[sys.maxsize for _ in range(N)] for _ in range(N)]\n    for blockedCell in blockedCells:\n        distances[blockedCell[0]][blockedCell[1]] = -1\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] != -1:\n                distances[i][j] = 0\n                queue = Queue()\n                queue.put((i, j))\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                while not queue.empty():\n                    (cur_i, cur_j) = queue.get()\n                    for direction in directions:\n                        (new_i, new_j) = (cur_i + direction[0], cur_j + direction[1])\n                        if 0 <= new_i < N and 0 <= new_j < N and (distances[new_i][new_j] != --1):\n                            new_distance = distances[cur_i][cur_j] + 1\n                            if new_distance < distances[new_i][new_j]:\n                                distances[new_i][new_j] = new_distance\n                                queue.put((new_i, new_j))\n    path = []\n    for i in range(N):\n        for j in range(N):\n            if distances[i][j] == k:\n                path.append(grid[i][j])\n    if not path:\n        return -1\n    path.sort()\n    return path"
    }
  ]
}