{
  "task_id": "cf_84153",
  "entry_point": "match_parens",
  "mutant_count": 28,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def match_parens(lst):\n    \"\"\"\"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) and is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) and is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return '' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return '' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else ''",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else ''"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if p == '(':",
      "mutated_line": "if p != '(':",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p != '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if p == '(':",
      "mutated_line": "if p == '':",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "elif p == ')' and stack:",
      "mutated_line": "elif p == ')' or stack:",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' or stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] - lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] - lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] * lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] * lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] - lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] - lst[0]) else 'No'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] * lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] * lst[0]) else 'No'"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif p == ')' and stack:",
      "mutated_line": "elif p != ')' and stack:",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p != ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return True\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif p == ')' and stack:",
      "mutated_line": "elif p == '' and stack:",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == '' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[1] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[1] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[-1] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[-1] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[1] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[1] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[2]) or is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[2]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[0]) or is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[0]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[0]) or is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[0]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[-1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[-1]) or is_valid(lst[1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[2] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[2] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[0] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[0] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[0] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[0] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[-1] + lst[0]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[-1] + lst[0]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[1]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[1]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[-1]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[-1]) else 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[0]) else 'No'",
      "mutated_line": "return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[1]) else 'No'",
      "code": "def match_parens(lst):\n    \"\"\"\n    This function checks if two strings of parentheses can be concatenated in either order to form a correctly nested parentheses string.\n\n    Args:\n        lst (list): A list of two strings, each consisting solely of open '(' or closed ')' parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated in either order to form a correctly nested parentheses string, 'No' otherwise.\n    \"\"\"\n\n    def is_valid(parens):\n        stack = []\n        for p in parens:\n            if p == '(':\n                stack.append(p)\n            elif p == ')' and stack:\n                stack.pop()\n            else:\n                return False\n        return not stack\n    return 'Yes' if is_valid(lst[0] + lst[1]) or is_valid(lst[1] + lst[1]) else 'No'"
    }
  ]
}