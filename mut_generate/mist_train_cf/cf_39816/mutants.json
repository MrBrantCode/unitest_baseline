{
  "task_id": "cf_39816",
  "entry_point": "distance_between_nodes",
  "mutant_count": 23,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)",
      "mutated_line": "return find_path_length(tree, node1, root) - find_path_length(tree, node2, root)",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) - find_path_length(tree, node2, root)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)",
      "mutated_line": "return find_path_length(tree, node1, root) * find_path_length(tree, node2, root)",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) * find_path_length(tree, node2, root)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [False] * len(tree)",
      "mutated_line": "visited = [False] / len(tree)",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] / len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [False] * len(tree)",
      "mutated_line": "visited = [False] + len(tree)",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] + len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [False] * len(tree)",
      "mutated_line": "visited = [False] ** len(tree)",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] ** len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "return -1  # If no path found",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return +1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if current == end:",
      "mutated_line": "if current != end:",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current != end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[current] = True",
      "mutated_line": "visited[current] = False",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = False\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1  # If no path found",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -2\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1  # If no path found",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -0\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1  # If no path found",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -0\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1  # If no path found",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return --1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [False] * len(tree)",
      "mutated_line": "visited = [True] * len(tree)",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [True] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if connected and not visited[neighbor]:",
      "mutated_line": "if connected or not visited[neighbor]:",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected or not visited[neighbor]:\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(start, 0)])",
      "mutated_line": "queue = deque([(start, 1)])",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 1)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(start, 0)])",
      "mutated_line": "queue = deque([(start, -1)])",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, -1)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(start, 0)])",
      "mutated_line": "queue = deque([(start, 1)])",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 1)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "queue.append((neighbor, distance + 1))",
      "mutated_line": "queue.append((neighbor, distance - 1))",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance - 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "queue.append((neighbor, distance + 1))",
      "mutated_line": "queue.append((neighbor, distance * 1))",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance * 1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((neighbor, distance + 1))",
      "mutated_line": "queue.append((neighbor, distance + 2))",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 2))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((neighbor, distance + 1))",
      "mutated_line": "queue.append((neighbor, distance + 0))",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 0))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((neighbor, distance + 1))",
      "mutated_line": "queue.append((neighbor, distance + 0))",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + 0))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((neighbor, distance + 1))",
      "mutated_line": "queue.append((neighbor, distance + -1))",
      "code": "from collections import deque\n\ndef distance_between_nodes(tree, root, node1, node2):\n\n    def find_path_length(tree, start, end):\n        visited = [False] * len(tree)\n        queue = deque([(start, 0)])\n        while queue:\n            (current, distance) = queue.popleft()\n            if current == end:\n                return distance\n            visited[current] = True\n            for (neighbor, connected) in enumerate(tree[current]):\n                if connected and (not visited[neighbor]):\n                    queue.append((neighbor, distance + -1))\n        return -1\n    return find_path_length(tree, node1, root) + find_path_length(tree, node2, root)"
    }
  ]
}