{
  "task_id": "cf_37446",
  "entry_point": "kruskal_mst",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if self.parent[v] != v:",
      "mutated_line": "if self.parent[v] == v:",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] == v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if root1 != root2:",
      "mutated_line": "if root1 == root2:",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 == root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if disjoint_set.find(v1) != disjoint_set.find(v2):",
      "mutated_line": "if disjoint_set.find(v1) == disjoint_set.find(v2):",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) == disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = {v: 0 for v in vertices}",
      "mutated_line": "self.rank = {v: 1 for v in vertices}",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 1 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = {v: 0 for v in vertices}",
      "mutated_line": "self.rank = {v: -1 for v in vertices}",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: -1 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = {v: 0 for v in vertices}",
      "mutated_line": "self.rank = {v: 1 for v in vertices}",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 1 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if self.rank[root1] < self.rank[root2]:",
      "mutated_line": "if self.rank[root1] <= self.rank[root2]:",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] <= self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if self.rank[root1] < self.rank[root2]:",
      "mutated_line": "if self.rank[root1] >= self.rank[root2]:",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] >= self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if self.rank[root1] < self.rank[root2]:",
      "mutated_line": "if self.rank[root1] != self.rank[root2]:",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] != self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif self.rank[root1] > self.rank[root2]:",
      "mutated_line": "elif self.rank[root1] >= self.rank[root2]:",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] >= self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif self.rank[root1] > self.rank[root2]:",
      "mutated_line": "elif self.rank[root1] <= self.rank[root2]:",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] <= self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif self.rank[root1] > self.rank[root2]:",
      "mutated_line": "elif self.rank[root1] != self.rank[root2]:",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] != self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "self.rank[root1] += 1",
      "mutated_line": "self.rank[root1] -= 1",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] -= 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vertices.add(edge[0])",
      "mutated_line": "",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[1])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vertices.add(edge[0])",
      "mutated_line": "vertices.add(edge[-1])",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[-1])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vertices.add(edge[0])",
      "mutated_line": "",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[1])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vertices.add(edge[1])",
      "mutated_line": "vertices.add(edge[2])",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[2])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vertices.add(edge[1])",
      "mutated_line": "vertices.add(edge[0])",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[0])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vertices.add(edge[1])",
      "mutated_line": "vertices.add(edge[0])",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[0])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vertices.add(edge[1])",
      "mutated_line": "vertices.add(edge[-1])",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[-1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.rank[root1] += 1",
      "mutated_line": "self.rank[root1] += 2",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 2\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.rank[root1] += 1",
      "mutated_line": "self.rank[root1] += 0",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 0\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.rank[root1] += 1",
      "mutated_line": "self.rank[root1] += 0",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 0\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.rank[root1] += 1",
      "mutated_line": "self.rank[root1] += -1",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += -1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "edges.sort(key=lambda x: x[2])  # Sort edges by weight",
      "mutated_line": "edges.sort(key=lambda x: x[3])",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[3])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "edges.sort(key=lambda x: x[2])  # Sort edges by weight",
      "mutated_line": "edges.sort(key=lambda x: x[1])",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[1])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "edges.sort(key=lambda x: x[2])  # Sort edges by weight",
      "mutated_line": "edges.sort(key=lambda x: x[0])",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[0])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "edges.sort(key=lambda x: x[2])  # Sort edges by weight",
      "mutated_line": "edges.sort(key=lambda x: x[1])",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[1])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "edges.sort(key=lambda x: x[2])  # Sort edges by weight",
      "mutated_line": "edges.sort(key=lambda x: x[-2])",
      "code": "class DisjointSet:\n\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, v):\n        if self.parent[v] != v:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n\n    def union(self, v1, v2):\n        root1 = self.find(v1)\n        root2 = self.find(v2)\n        if root1 != root2:\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            elif self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef kruskal_mst(edges):\n    edges.sort(key=lambda x: x[-2])\n    vertices = set()\n    for edge in edges:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    for edge in edges:\n        (v1, v2, weight) = edge\n        if disjoint_set.find(v1) != disjoint_set.find(v2):\n            mst.append((v1, v2, weight))\n            disjoint_set.union(v1, v2)\n    return mst"
    }
  ]
}