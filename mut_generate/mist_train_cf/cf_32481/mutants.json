{
  "task_id": "cf_32481",
  "entry_point": "game_of_life",
  "mutant_count": 124,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 1\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = -1\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 1\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "next_state = [[False] * cols for _ in range(rows)]",
      "mutated_line": "next_state = [[False] / cols for _ in range(rows)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] / cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "next_state = [[False] * cols for _ in range(rows)]",
      "mutated_line": "next_state = [[False] + cols for _ in range(rows)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] + cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "next_state = [[False] * cols for _ in range(rows)]",
      "mutated_line": "next_state = [[False] ** cols for _ in range(rows)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] ** cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(2, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(2, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(0, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(0, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(0, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(0, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(-1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(-1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 1), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 1), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, -1), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, -1), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 1), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 1), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (+1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (+1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 1), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 1), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, -1), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, -1), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 1), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 1), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (1, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (1, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (-1, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (-1, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (1, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (1, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 2), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 2), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, -1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, -1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, +1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, +1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (2, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (2, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 2), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 2), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, -1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, -1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (+1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (+1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, +1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, +1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (2, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (2, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (-1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (-1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, +1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, +1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (+1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (+1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 2)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 2)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, -1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, -1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 0 <= r < rows or 0 <= c < cols or board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows or 0 <= c < cols or board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count -= 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(board), len(board[0])",
      "mutated_line": "(rows, cols) = (len(board), len(board[1]))",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[1]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(board), len(board[0])",
      "mutated_line": "(rows, cols) = (len(board), len(board[-1]))",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[-1]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(board), len(board[0])",
      "mutated_line": "(rows, cols) = (len(board), len(board[1]))",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[1]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-2, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-2, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-0, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-0, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-0, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-0, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (--1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (--1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -2), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -2), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, --1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, --1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-2, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-2, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (--1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (--1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -2), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -2), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, --1), (1, -1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, --1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -2), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -2), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, --1), (-1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, --1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-2, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-2, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (--1, 1)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (--1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r, c = row + dr, col + dc",
      "mutated_line": "(r, c) = (row - dr, col + dc)",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row - dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r, c = row + dr, col + dc",
      "mutated_line": "(r, c) = (row * dr, col + dc)",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row * dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r, c = row + dr, col + dc",
      "mutated_line": "(r, c) = (row + dr, col - dc)",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col - dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r, c = row + dr, col + dc",
      "mutated_line": "(r, c) = (row + dr, col * dc)",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col * dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 0 < r < rows and 0 <= c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 < r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 0 > r < rows and 0 <= c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 > r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 0 == r < rows and 0 <= c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 == r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 0 <= r < rows and 0 < c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 < c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 0 <= r < rows and 0 > c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 > c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 0 <= r < rows and 0 == c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 == c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 2\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 0\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 0\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += -1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "next_state = [[False] * cols for _ in range(rows)]",
      "mutated_line": "next_state = [[True] * cols for _ in range(rows)]",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[True] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 and live_neighbors > 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 and live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[r][c] = True",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors != 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 1 <= r < rows and 0 <= c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 1 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if -1 <= r < rows and 0 <= c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if -1 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 1 <= r < rows and 0 <= c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 1 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 0 <= r < rows and 1 <= c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 1 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 0 <= r < rows and -1 <= c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and -1 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= r < rows and 0 <= c < cols and board[r][c]:",
      "mutated_line": "if 0 <= r < rows and 1 <= c < cols and board[r][c]:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 1 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors <= 2 or live_neighbors > 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors <= 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors >= 2 or live_neighbors > 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors >= 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors != 2 or live_neighbors > 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors != 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors >= 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors >= 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors <= 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors <= 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors != 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors != 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "next_state[r][c] = False  # cell dies",
      "mutated_line": "next_state[r][c] = True",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = True\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "next_state[r][c] = True  # cell lives on",
      "mutated_line": "next_state[r][c] = False",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = False\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[r][c] = True",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 4:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[r][c] = True",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 2:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[r][c] = True",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 0:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[r][c] = True",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 1:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[r][c] = True",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == -3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "next_state[r][c] = True  # cell becomes alive",
      "mutated_line": "next_state[r][c] = False",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = False\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 3 or live_neighbors > 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 3 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 1 or live_neighbors > 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 1 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 0 or live_neighbors > 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 0 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 1 or live_neighbors > 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 1 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < -2 or live_neighbors > 3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < -2 or live_neighbors > 3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 4:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 4:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 2:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 2:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 0:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 0:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 1:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > 1:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > -3:",
      "code": "from typing import List\n\ndef game_of_life(board: List[List[bool]]) -> None:\n    (rows, cols) = (len(board), len(board[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for (dr, dc) in directions:\n            (r, c) = (row + dr, col + dc)\n            if 0 <= r < rows and 0 <= c < cols and board[r][c]:\n                count += 1\n        return count\n    next_state = [[False] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            live_neighbors = count_live_neighbors(r, c)\n            if board[r][c]:\n                if live_neighbors < 2 or live_neighbors > -3:\n                    next_state[r][c] = False\n                else:\n                    next_state[r][c] = True\n            elif live_neighbors == 3:\n                next_state[r][c] = True\n    for r in range(rows):\n        for c in range(cols):\n            board[r][c] = next_state[r][c]"
    }
  ]
}