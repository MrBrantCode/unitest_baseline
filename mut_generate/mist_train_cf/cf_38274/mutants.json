{
  "task_id": "cf_38274",
  "entry_point": "find_patterns",
  "mutant_count": 34,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "node_count = 0",
      "mutated_line": "node_count = 1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 1\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "node_count = 0",
      "mutated_line": "node_count = -1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = -1\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "node_count = 0",
      "mutated_line": "node_count = 1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 1\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index = 0",
      "mutated_line": "index = 1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 1\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index = 0",
      "mutated_line": "index = -1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = -1\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index = 0",
      "mutated_line": "index = 1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 1\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "v = 0",
      "mutated_line": "v = 1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 1\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "v = 0",
      "mutated_line": "v = -1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = -1\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "v = 0",
      "mutated_line": "v = 1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 1\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while False:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "current_node = 0",
      "mutated_line": "current_node = 1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 1\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "current_node = 0",
      "mutated_line": "current_node = -1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = -1\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "current_node = 0",
      "mutated_line": "current_node = 1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 1\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if text[position:position + len(pattern)] == pattern:",
      "mutated_line": "if text[position:position + len(pattern)] != pattern:",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] != pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if (current_node, char) not in trie:",
      "mutated_line": "if (current_node, char) in trie:",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "node_count += 1",
      "mutated_line": "node_count -= 1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count -= 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return False\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif trie.get((v, symbol), None) in trie.values():",
      "mutated_line": "elif trie.get((v, symbol), None) not in trie.values():",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) not in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "index += 1",
      "mutated_line": "index -= 1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index -= 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "node_count += 1",
      "mutated_line": "node_count += 2",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 2\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "node_count += 1",
      "mutated_line": "node_count += 0",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 0\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "node_count += 1",
      "mutated_line": "node_count += 0",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 0\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "node_count += 1",
      "mutated_line": "node_count += -1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += -1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "index += 1",
      "mutated_line": "index += 2",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 2\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "index += 1",
      "mutated_line": "index += 0",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 0\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "index += 1",
      "mutated_line": "index += 0",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 0\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "index += 1",
      "mutated_line": "index += -1",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += -1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if index < len(text):",
      "mutated_line": "if index <= len(text):",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index <= len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if index < len(text):",
      "mutated_line": "if index >= len(text):",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index >= len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if index < len(text):",
      "mutated_line": "if index != len(text):",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index != len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return True\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "symbol = ''",
      "mutated_line": "symbol = 'MUTATED'",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = 'MUTATED'\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position + len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if text[position:position + len(pattern)] == pattern:",
      "mutated_line": "if text[position:position - len(pattern)] == pattern:",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position - len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if text[position:position + len(pattern)] == pattern:",
      "mutated_line": "if text[position:position * len(pattern)] == pattern:",
      "code": "from typing import List\n\ndef find_patterns(text: str, patterns: List[str]) -> List[List[int]]:\n\n    def build_trie(patterns):\n        trie = {}\n        node_count = 0\n        for pattern in patterns:\n            current_node = 0\n            for char in pattern:\n                if (current_node, char) not in trie:\n                    node_count += 1\n                    trie[current_node, char] = node_count\n                current_node = trie[current_node, char]\n        return trie\n\n    def prefix_trie_matching(text, trie):\n        index = 0\n        symbol = text[index]\n        v = 0\n        while True:\n            if not trie.get((v, symbol), None):\n                return True\n            elif trie.get((v, symbol), None) in trie.values():\n                v = trie[v, symbol]\n                index += 1\n                if index < len(text):\n                    symbol = text[index]\n                else:\n                    symbol = ''\n            else:\n                return False\n    trie = build_trie(patterns)\n    positions = []\n    for i in range(len(text)):\n        if prefix_trie_matching(text[i:], trie):\n            positions.append(i)\n    result = [[] for _ in range(len(patterns))]\n    for (i, pattern) in enumerate(patterns):\n        for position in positions:\n            if text[position:position * len(pattern)] == pattern:\n                result[i].append(position)\n    return result"
    }
  ]
}