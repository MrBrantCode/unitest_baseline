{
  "task_id": "cf_52430",
  "entry_point": "minimizeRoundingError",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if target < F:",
      "mutated_line": "if target <= F:",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target <= F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if target < F:",
      "mutated_line": "if target >= F:",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target >= F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if target < F:",
      "mutated_line": "if target != F:",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target != F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while F < target:",
      "mutated_line": "while F <= target:",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F <= target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while F < target:",
      "mutated_line": "while F >= target:",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F >= target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while F < target:",
      "mutated_line": "while F != target:",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F != target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "F += 1",
      "mutated_line": "F -= 1",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F -= 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "flo[i] += 1",
      "mutated_line": "flo[i] -= 1",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] -= 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if flo[i] < prices[i]:",
      "mutated_line": "if flo[i] <= prices[i]:",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] <= prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if flo[i] < prices[i]:",
      "mutated_line": "if flo[i] >= prices[i]:",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] >= prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if flo[i] < prices[i]:",
      "mutated_line": "if flo[i] != prices[i]:",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] != prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return \"-1\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return ''\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "F += 1",
      "mutated_line": "F += 2",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 2\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "F += 1",
      "mutated_line": "F += 0",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 0\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "F += 1",
      "mutated_line": "F += 0",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 0\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "F += 1",
      "mutated_line": "F += -1",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += -1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "flo[i] += 1",
      "mutated_line": "flo[i] += 2",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 2\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "flo[i] += 1",
      "mutated_line": "flo[i] += 0",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 0\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "flo[i] += 1",
      "mutated_line": "flo[i] += 0",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 0\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "flo[i] += 1",
      "mutated_line": "flo[i] += -1",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += -1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = heapq.heappop(ceiling)[1]",
      "mutated_line": "i = heapq.heappop(ceiling)[2]",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[2]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = heapq.heappop(ceiling)[1]",
      "mutated_line": "i = heapq.heappop(ceiling)[0]",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[0]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = heapq.heappop(ceiling)[1]",
      "mutated_line": "i = heapq.heappop(ceiling)[0]",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[0]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = heapq.heappop(ceiling)[1]",
      "mutated_line": "i = heapq.heappop(ceiling)[-1]",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[-1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return '{:.3f}'.format(ans)",
      "mutated_line": "return ''.format(ans)",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return ''.format(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = sum([abs(flo[i]-prices[i]) for i in range(n)])",
      "mutated_line": "ans = sum([abs(flo[i] + prices[i]) for i in range(n)])",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] + prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = sum([abs(flo[i]-prices[i]) for i in range(n)])",
      "mutated_line": "ans = sum([abs(flo[i] * prices[i]) for i in range(n)])",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] - prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] * prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "heapq.heappush(ceiling, (flo[i]-prices[i], i))",
      "mutated_line": "heapq.heappush(ceiling, (flo[i] + prices[i], i))",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] + prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "heapq.heappush(ceiling, (flo[i]-prices[i], i))",
      "mutated_line": "heapq.heappush(ceiling, (flo[i] * prices[i], i))",
      "code": "import heapq\n\ndef minimizeRoundingError(prices, target):\n    (n, target, ceiling) = (len(prices), int(target), [])\n    prices = [float(p) for p in prices]\n    flo = [int(p) for p in prices]\n    F = sum(flo)\n    for i in range(n):\n        if flo[i] < prices[i]:\n            heapq.heappush(ceiling, (flo[i] * prices[i], i))\n    if target < F:\n        return '-1'\n    while F < target:\n        F += 1\n        i = heapq.heappop(ceiling)[1]\n        flo[i] += 1\n    ans = sum([abs(flo[i] - prices[i]) for i in range(n)])\n    return '{:.3f}'.format(ans)"
    }
  ]
}