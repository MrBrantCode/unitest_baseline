{
  "task_id": "cf_67223",
  "entry_point": "shortest_path",
  "mutant_count": 17,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 1\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = -1",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = -1\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 1\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if distances[end] == float('infinity'):",
      "mutated_line": "return (float('inf'), [])",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] != float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(1, start)]",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(1, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(-1, start)]",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(-1, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(1, start)]",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(1, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances = {node: float('infinity') for node in graph}",
      "mutated_line": "distances = {node: float('') for node in graph}",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance = curr_distance + neighbor_distance",
      "mutated_line": "distance = curr_distance - neighbor_distance",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance - neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance = curr_distance + neighbor_distance",
      "mutated_line": "distance = curr_distance * neighbor_distance",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance * neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance <= distances[neighbor]:",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance <= distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance >= distances[neighbor]:",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance >= distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance != distances[neighbor]:",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance != distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if distances[end] == float('infinity'):",
      "mutated_line": "return (float('inf'), [])",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float(''):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "paths[neighbor] = paths[curr_vertex] + [neighbor]",
      "mutated_line": "paths[neighbor] = paths[curr_vertex] - [neighbor]",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] - [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "paths[neighbor] = paths[curr_vertex] + [neighbor]",
      "mutated_line": "paths[neighbor] = paths[curr_vertex] * [neighbor]",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] * [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float('inf'), [])\n    return (distances[end], paths[end])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return float('inf'), []",
      "mutated_line": "return (float(''), [])",
      "code": "import sys\nimport heapq\n\ndef shortest_path(graph, start, end):\n    heap = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    paths = {start: [start]}\n    while heap:\n        (curr_distance, curr_vertex) = heapq.heappop(heap)\n        for (neighbor, neighbor_distance) in graph[curr_vertex].items():\n            distance = curr_distance + neighbor_distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                paths[neighbor] = paths[curr_vertex] + [neighbor]\n                heapq.heappush(heap, (distance, neighbor))\n    if distances[end] == float('infinity'):\n        return (float(''), [])\n    return (distances[end], paths[end])"
    }
  ]
}