{
  "task_id": "cf_65691",
  "entry_point": "edgeLengthRestrictedPaths",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans = [None] * len(queries)",
      "mutated_line": "ans = [None] / len(queries)",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] / len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans = [None] * len(queries)",
      "mutated_line": "ans = [None] + len(queries)",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] + len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans = [None] * len(queries)",
      "mutated_line": "ans = [None] ** len(queries)",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] ** len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pointer_edges = 0",
      "mutated_line": "for (limit, p, q, i) in query_with_index:",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 1\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pointer_edges = 0",
      "mutated_line": "for (limit, p, q, i) in query_with_index:",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = -1\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pointer_edges = 0",
      "mutated_line": "for (limit, p, q, i) in query_with_index:",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 1\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:",
      "mutated_line": "(_, u, v) = edges[pointer_edges]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) or edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "pointer_edges += 1",
      "mutated_line": "pointer_edges -= 1",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges -= 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "ans[i] = (uf.find(p) == uf.find(q))",
      "mutated_line": "ans[i] = uf.find(p) != uf.find(q)",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) != uf.find(q)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank   = [0] * n",
      "mutated_line": "self.rank = [0] / n",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] / n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank   = [0] * n",
      "mutated_line": "self.rank = [0] + n",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] + n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank   = [0] * n",
      "mutated_line": "self.rank = [0] ** n",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] ** n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x != self.parent[x]:",
      "mutated_line": "if x == self.parent[x]:",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x == self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if rx != ry:",
      "mutated_line": "if rx == ry:",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx == ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "edges.sort(reverse=True)",
      "mutated_line": "query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=False)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "query_with_index.sort(key=lambda t: t[0], reverse=True)",
      "mutated_line": "query_with_index.sort(key=lambda t: t[0], reverse=False)",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=False)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:",
      "mutated_line": "(_, u, v) = edges[pointer_edges]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges <= len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:",
      "mutated_line": "(_, u, v) = edges[pointer_edges]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges >= len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:",
      "mutated_line": "(_, u, v) = edges[pointer_edges]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges != len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:",
      "mutated_line": "(_, u, v) = edges[pointer_edges]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] > limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:",
      "mutated_line": "(_, u, v) = edges[pointer_edges]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] < limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:",
      "mutated_line": "(_, u, v) = edges[pointer_edges]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] == limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "pointer_edges += 1",
      "mutated_line": "pointer_edges += 2",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 2\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "pointer_edges += 1",
      "mutated_line": "pointer_edges += 0",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 0\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "pointer_edges += 1",
      "mutated_line": "pointer_edges += 0",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 0\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "pointer_edges += 1",
      "mutated_line": "pointer_edges += -1",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += -1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if self.rank[rx] > self.rank[ry]:",
      "mutated_line": "if self.rank[rx] >= self.rank[ry]:",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] >= self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if self.rank[rx] > self.rank[ry]:",
      "mutated_line": "if self.rank[rx] <= self.rank[ry]:",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] <= self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if self.rank[rx] > self.rank[ry]:",
      "mutated_line": "if self.rank[rx] != self.rank[ry]:",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] != self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank   = [0] * n",
      "mutated_line": "self.rank = [1] * n",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [1] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank   = [0] * n",
      "mutated_line": "self.rank = [-1] * n",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [-1] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank   = [0] * n",
      "mutated_line": "self.rank = [1] * n",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [1] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if self.rank[rx] == self.rank[ry]:",
      "mutated_line": "if self.rank[rx] != self.rank[ry]:",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] != self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "self.rank[ry] += 1",
      "mutated_line": "self.rank[ry] -= 1",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] -= 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "query_with_index.sort(key=lambda t: t[0], reverse=True)",
      "mutated_line": "query_with_index.sort(key=lambda t: t[1], reverse=True)",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[1], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "query_with_index.sort(key=lambda t: t[0], reverse=True)",
      "mutated_line": "query_with_index.sort(key=lambda t: t[-1], reverse=True)",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[-1], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "query_with_index.sort(key=lambda t: t[0], reverse=True)",
      "mutated_line": "query_with_index.sort(key=lambda t: t[1], reverse=True)",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[1], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:",
      "mutated_line": "(_, u, v) = edges[pointer_edges]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][1] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:",
      "mutated_line": "(_, u, v) = edges[pointer_edges]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][-1] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:",
      "mutated_line": "(_, u, v) = edges[pointer_edges]",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][1] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.rank[ry] += 1",
      "mutated_line": "self.rank[ry] += 2",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 2\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.rank[ry] += 1",
      "mutated_line": "self.rank[ry] += 0",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 0\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.rank[ry] += 1",
      "mutated_line": "self.rank[ry] += 0",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += 0\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.rank[ry] += 1",
      "mutated_line": "self.rank[ry] += -1",
      "code": "def edgeLengthRestrictedPaths(n, edgeList, queries):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n\n        def find(self, x):\n            if x != self.parent[x]:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n        def union(self, x, y):\n            (rx, ry) = (self.find(x), self.find(y))\n            if rx != ry:\n                if self.rank[rx] > self.rank[ry]:\n                    self.parent[ry] = rx\n                else:\n                    self.parent[rx] = ry\n                    if self.rank[rx] == self.rank[ry]:\n                        self.rank[ry] += -1\n    edges = [(d, u, v) for (u, v, d) in edgeList]\n    edges.sort(reverse=True)\n    query_with_index = [(limit, p, q, i) for (i, (p, q, limit)) in enumerate(queries)]\n    query_with_index.sort(key=lambda t: t[0], reverse=True)\n    uf = UnionFind(n)\n    ans = [None] * len(queries)\n    pointer_edges = 0\n    for (limit, p, q, i) in query_with_index:\n        while pointer_edges < len(edges) and edges[pointer_edges][0] >= limit:\n            (_, u, v) = edges[pointer_edges]\n            uf.union(u, v)\n            pointer_edges += 1\n        ans[i] = uf.find(p) == uf.find(q)\n    return ans"
    }
  ]
}