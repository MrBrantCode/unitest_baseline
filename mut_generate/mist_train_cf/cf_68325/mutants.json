{
  "task_id": "cf_68325",
  "entry_point": "smallest_triangular_position",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n <= 0:",
      "mutated_line": "if n < 0:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n < 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n <= 0:",
      "mutated_line": "if n > 0:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n > 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n <= 0:",
      "mutated_line": "if n == 0:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n == 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "low = 1",
      "mutated_line": "low = 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 2\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "low = 1",
      "mutated_line": "low = 0",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 0\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "low = 1",
      "mutated_line": "low = 0",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 0\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "low = 1",
      "mutated_line": "low = -1",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = -1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if index != -1:",
      "mutated_line": "if index == -1:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index == -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n <= 0:",
      "mutated_line": "if n <= 1:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 1:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n <= 0:",
      "mutated_line": "if n <= -1:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= -1:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n <= 0:",
      "mutated_line": "if n <= 1:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 1:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return \"Error: n should be a positive integer\"",
      "mutated_line": "return ''",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return ''\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "high = int(10e6)  # upper limit for processing",
      "mutated_line": "high = int(10000001.0)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000001.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "high = int(10e6)  # upper limit for processing",
      "mutated_line": "high = int(9999999.0)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(9999999.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "high = int(10e6)  # upper limit for processing",
      "mutated_line": "high = int(0)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "high = int(10e6)  # upper limit for processing",
      "mutated_line": "high = int(1)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(1)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "high = int(10e6)  # upper limit for processing",
      "mutated_line": "high = int(-10000000.0)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(-10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + 1) / 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) / 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + 1) * 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) * 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if high >= low:",
      "mutated_line": "if high > low:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high > low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if high >= low:",
      "mutated_line": "if high < low:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high < low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if high >= low:",
      "mutated_line": "if high == low:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high == low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "if index != -1:",
      "mutated_line": "if index != +1:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != +1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "execution_time = time.time() - start_time",
      "mutated_line": "execution_time = time.time() + start_time",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() + start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "execution_time = time.time() - start_time",
      "mutated_line": "execution_time = time.time() * start_time",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() * start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return \"No triangular number found for provided digit count\"",
      "mutated_line": "return ''",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return ''"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x / (x + 1) // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x / (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return (x + (x + 1)) // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return (x + (x + 1)) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x ** (x + 1) // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x ** (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + 1) // 3",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 3\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + 1) // 1",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 1\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + 1) // 0",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 0\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + 1) // 1",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 1\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + 1) // -2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // -2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = (high + low) // 2",
      "mutated_line": "mid = (high + low) / 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) / 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = (high + low) // 2",
      "mutated_line": "mid = (high + low) * 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) * 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if mid_number_log >= n:",
      "mutated_line": "if mid_number_log > n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log > n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if mid_number_log >= n:",
      "mutated_line": "if mid_number_log < n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log < n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if mid_number_log >= n:",
      "mutated_line": "if mid_number_log == n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log == n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return +1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if index != -1:",
      "mutated_line": "if index != -2:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -2:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if index != -1:",
      "mutated_line": "if index != -0:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -0:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if index != -1:",
      "mutated_line": "if index != -0:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -0:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if index != -1:",
      "mutated_line": "if index != --1:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != --1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x - 1) // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x - 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x * 1) // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x * 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = (high + low) // 2",
      "mutated_line": "mid = (high - low) // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high - low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = (high + low) // 2",
      "mutated_line": "mid = high * low // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = high * low // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = (high + low) // 2",
      "mutated_line": "mid = (high + low) // 3",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 3\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = (high + low) // 2",
      "mutated_line": "mid = (high + low) // 1",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 1\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = (high + low) // 2",
      "mutated_line": "mid = (high + low) // 0",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 0\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = (high + low) // 2",
      "mutated_line": "mid = (high + low) // 1",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 1\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = (high + low) // 2",
      "mutated_line": "mid = (high + low) // -2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // -2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if mid_number_log - 1 < n:",
      "mutated_line": "if mid_number_log - 1 <= n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 <= n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if mid_number_log - 1 < n:",
      "mutated_line": "if mid_number_log - 1 >= n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 >= n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if mid_number_log - 1 < n:",
      "mutated_line": "if mid_number_log - 1 != n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 != n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -2\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -0\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -0\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return --1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return triangular, index, round(execution_time, 4)",
      "mutated_line": "return (triangular, index, round(execution_time, 5))",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 5))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return triangular, index, round(execution_time, 4)",
      "mutated_line": "return (triangular, index, round(execution_time, 3))",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 3))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return triangular, index, round(execution_time, 4)",
      "mutated_line": "return (triangular, index, round(execution_time, 0))",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 0))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return triangular, index, round(execution_time, 4)",
      "mutated_line": "return (triangular, index, round(execution_time, 1))",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 1))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return triangular, index, round(execution_time, 4)",
      "mutated_line": "return (triangular, index, round(execution_time, -4))",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, -4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + 2) // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 2) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + 0) // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 0) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + 0) // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 0) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return x * (x + 1) // 2",
      "mutated_line": "return x * (x + -1) // 2",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + -1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if mid_number_log - 1 < n:",
      "mutated_line": "if mid_number_log + 1 < n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log + 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if mid_number_log - 1 < n:",
      "mutated_line": "if mid_number_log * 1 < n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log * 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return binary_search(n, mid + 1, high)",
      "mutated_line": "return binary_search(n, mid - 1, high)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid - 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return binary_search(n, mid + 1, high)",
      "mutated_line": "return binary_search(n, mid * 1, high)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid * 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if mid_number_log - 1 < n:",
      "mutated_line": "if mid_number_log - 2 < n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 2 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if mid_number_log - 1 < n:",
      "mutated_line": "if mid_number_log - 0 < n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 0 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if mid_number_log - 1 < n:",
      "mutated_line": "if mid_number_log - 0 < n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 0 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if mid_number_log - 1 < n:",
      "mutated_line": "if mid_number_log - -1 < n:",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - -1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return binary_search(n, low, mid - 1)",
      "mutated_line": "return binary_search(n, low, mid + 1)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid + 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return binary_search(n, low, mid - 1)",
      "mutated_line": "return binary_search(n, low, mid * 1)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid * 1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return binary_search(n, mid + 1, high)",
      "mutated_line": "return binary_search(n, mid + 2, high)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 2, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return binary_search(n, mid + 1, high)",
      "mutated_line": "return binary_search(n, mid + 0, high)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 0, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return binary_search(n, mid + 1, high)",
      "mutated_line": "return binary_search(n, mid + 0, high)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + 0, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return binary_search(n, mid + 1, high)",
      "mutated_line": "return binary_search(n, mid + -1, high)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 1)\n                else:\n                    return binary_search(n, mid + -1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return binary_search(n, low, mid - 1)",
      "mutated_line": "return binary_search(n, low, mid - 2)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 2)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return binary_search(n, low, mid - 1)",
      "mutated_line": "return binary_search(n, low, mid - 0)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 0)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return binary_search(n, low, mid - 1)",
      "mutated_line": "return binary_search(n, low, mid - 0)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - 0)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return binary_search(n, low, mid - 1)",
      "mutated_line": "return binary_search(n, low, mid - -1)",
      "code": "import math\nimport time\n\ndef smallest_triangular_position(n):\n    if isinstance(n, list):\n        result = []\n        for num in n:\n            result.append(smallest_triangular_position(num))\n        return result\n    else:\n        if n <= 0:\n            return 'Error: n should be a positive integer'\n        if not isinstance(n, int):\n            n = round(n)\n        start_time = time.time()\n        low = 1\n        high = int(10000000.0)\n\n        def triangular_number(x):\n            return x * (x + 1) // 2\n\n        def binary_search(n, low, high):\n            if high >= low:\n                mid = (high + low) // 2\n                mid_number_log = math.log10(triangular_number(mid))\n                if mid_number_log >= n:\n                    if mid_number_log - 1 < n:\n                        return mid\n                    else:\n                        return binary_search(n, low, mid - -1)\n                else:\n                    return binary_search(n, mid + 1, high)\n            else:\n                return -1\n        index = binary_search(n, low, high)\n        if index != -1:\n            execution_time = time.time() - start_time\n            triangular = triangular_number(index)\n            return (triangular, index, round(execution_time, 4))\n        else:\n            return 'No triangular number found for provided digit count'"
    }
  ]
}