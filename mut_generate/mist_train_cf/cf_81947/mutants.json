{
  "task_id": "cf_81947",
  "entry_point": "shortestAlternatingPaths",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result[0] = [0,0]",
      "mutated_line": "queue = deque([(0, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[1] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result[0] = [0,0]",
      "mutated_line": "queue = deque([(0, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[-1] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result[0] = [0,0]",
      "mutated_line": "queue = deque([(0, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[1] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result[0] = [0,0]",
      "mutated_line": "queue = deque([(0, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [1, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result[0] = [0,0]",
      "mutated_line": "queue = deque([(0, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [-1, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result[0] = [0,0]",
      "mutated_line": "queue = deque([(0, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [1, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result[0] = [0,0]",
      "mutated_line": "queue = deque([(0, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 1]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result[0] = [0,0]",
      "mutated_line": "queue = deque([(0, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, -1]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result[0] = [0,0]",
      "mutated_line": "queue = deque([(0, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 1]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "result = [[-1,-1] for _ in range(n)]",
      "mutated_line": "result[0] = [0, 0]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[+1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "result = [[-1,-1] for _ in range(n)]",
      "mutated_line": "result[0] = [0, 0]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, +1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y != -1 else y if x == -1 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y != -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result = [[-1,-1] for _ in range(n)]",
      "mutated_line": "result[0] = [0, 0]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-2, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result = [[-1,-1] for _ in range(n)]",
      "mutated_line": "result[0] = [0, 0]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-0, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result = [[-1,-1] for _ in range(n)]",
      "mutated_line": "result[0] = [0, 0]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-0, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result = [[-1,-1] for _ in range(n)]",
      "mutated_line": "result[0] = [0, 0]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[--1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result = [[-1,-1] for _ in range(n)]",
      "mutated_line": "result[0] = [0, 0]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -2] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result = [[-1,-1] for _ in range(n)]",
      "mutated_line": "result[0] = [0, 0]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -0] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result = [[-1,-1] for _ in range(n)]",
      "mutated_line": "result[0] = [0, 0]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -0] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result = [[-1,-1] for _ in range(n)]",
      "mutated_line": "result[0] = [0, 0]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, --1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(0, True), (0, False)])",
      "mutated_line": "queue = deque([(1, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(1, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(0, True), (0, False)])",
      "mutated_line": "queue = deque([(-1, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(-1, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(0, True), (0, False)])",
      "mutated_line": "queue = deque([(1, True), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(1, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(0, True), (0, False)])",
      "mutated_line": "queue = deque([(0, False), (0, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, False), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(0, True), (0, False)])",
      "mutated_line": "queue = deque([(0, True), (1, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (1, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(0, True), (0, False)])",
      "mutated_line": "queue = deque([(0, True), (-1, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (-1, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(0, True), (0, False)])",
      "mutated_line": "queue = deque([(0, True), (1, False)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (1, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(0, True), (0, False)])",
      "mutated_line": "queue = deque([(0, True), (0, True)])",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, True)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 and result[node][0] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 and result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 and result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 and result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == +1 else y if x == -1 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == +1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == -1 else y if x != -1 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x != -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] != -1 or result[node][0] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] != -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][0] + weight <= result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight <= result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][0] + weight >= result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight >= result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][0] + weight != result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight != result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "result[next_node][0] = result[node][0] + weight",
      "mutated_line": "result[next_node][0] = result[node][0] - weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] - weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "result[next_node][0] = result[node][0] + weight",
      "mutated_line": "result[next_node][0] = result[node][0] * weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] * weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] != -1 or result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] != -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][1] + weight <= result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight <= result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][1] + weight >= result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight >= result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][1] + weight != result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight != result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result[next_node][1] = result[node][1] + weight",
      "mutated_line": "result[next_node][1] = result[node][1] - weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] - weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result[next_node][1] = result[node][1] + weight",
      "mutated_line": "result[next_node][1] = result[node][1] * weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] * weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == -2 else y if x == -1 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -2 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == -0 else y if x == -1 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -0 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == -0 else y if x == -1 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -0 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == --1 else y if x == -1 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == --1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == -1 else y if x == +1 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == +1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == +1 or result[node][0] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == +1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][0] - weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] - weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][0] * weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] * weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "result[next_node][0] = result[node][0] + weight",
      "mutated_line": "result[next_node][1] = result[node][0] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][1] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "result[next_node][0] = result[node][0] + weight",
      "mutated_line": "result[next_node][-1] = result[node][0] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][-1] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "result[next_node][0] = result[node][0] + weight",
      "mutated_line": "result[next_node][1] = result[node][0] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][1] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == +1 or result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == +1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][1] - weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] - weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][1] * weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] * weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result[next_node][1] = result[node][1] + weight",
      "mutated_line": "result[next_node][2] = result[node][1] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][2] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result[next_node][1] = result[node][1] + weight",
      "mutated_line": "result[next_node][0] = result[node][1] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][0] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result[next_node][1] = result[node][1] + weight",
      "mutated_line": "result[next_node][0] = result[node][1] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][0] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result[next_node][1] = result[node][1] + weight",
      "mutated_line": "result[next_node][-1] = result[node][1] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][-1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == -1 else y if x == -2 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -2 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == -1 else y if x == -0 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -0 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == -1 else y if x == -0 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -0 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [x if y == -1 else y if x == -1 else min(x, y) for x, y in result]",
      "mutated_line": "return [x if y == -1 else y if x == --1 else min(x, y) for (x, y) in result]",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == --1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][0] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][1] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][-1] == -1 or result[node][0] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][-1] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][0] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][1] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -2 or result[node][0] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -2 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -0 or result[node][0] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -0 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -0 or result[node][0] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -0 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == --1 or result[node][0] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == --1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][1]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][-1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][-1]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][1]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "result[next_node][0] = result[node][0] + weight",
      "mutated_line": "result[next_node][0] = result[node][1] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][1] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "result[next_node][0] = result[node][0] + weight",
      "mutated_line": "result[next_node][0] = result[node][-1] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][-1] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "result[next_node][0] = result[node][0] + weight",
      "mutated_line": "result[next_node][0] = result[node][1] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][1] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append((next_node, False))",
      "mutated_line": "queue.append((next_node, True))",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, True))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][2] == -1 or result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][2] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][0] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][0] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][-1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][-1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -2 or result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -2 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -0 or result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -0 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -0 or result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -0 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == --1 or result[node][1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == --1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][2]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][2]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][0]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][0]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][-1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][-1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result[next_node][1] = result[node][1] + weight",
      "mutated_line": "result[next_node][1] = result[node][2] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][2] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result[next_node][1] = result[node][1] + weight",
      "mutated_line": "result[next_node][1] = result[node][0] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][0] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result[next_node][1] = result[node][1] + weight",
      "mutated_line": "result[next_node][1] = result[node][0] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][0] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result[next_node][1] = result[node][1] + weight",
      "mutated_line": "result[next_node][1] = result[node][-1] + weight",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][-1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue.append((next_node, True))",
      "mutated_line": "queue.append((next_node, False))",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, False))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][1] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][1] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][-1] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][-1] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:",
      "mutated_line": "if result[next_node][0] == -1 or result[node][1] + weight < result[next_node][0]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][1] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][2] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][2] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][0] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][0] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][0] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][0] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if result[next_node][1] == -1 or result[node][1] + weight < result[next_node][1]:",
      "mutated_line": "if result[next_node][1] == -1 or result[node][-1] + weight < result[next_node][1]:",
      "code": "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, red_edges, blue_edges):\n    red = defaultdict(list)\n    blue = defaultdict(list)\n    for (i, j, w) in red_edges:\n        red[i].append((j, w))\n    for (i, j, w) in blue_edges:\n        blue[i].append((j, w))\n    result = [[-1, -1] for _ in range(n)]\n    result[0] = [0, 0]\n    queue = deque([(0, True), (0, False)])\n    while queue:\n        (node, is_red) = queue.popleft()\n        if is_red:\n            for (next_node, weight) in red[node]:\n                if result[next_node][0] == -1 or result[node][0] + weight < result[next_node][0]:\n                    result[next_node][0] = result[node][0] + weight\n                    queue.append((next_node, False))\n        else:\n            for (next_node, weight) in blue[node]:\n                if result[next_node][1] == -1 or result[node][-1] + weight < result[next_node][1]:\n                    result[next_node][1] = result[node][1] + weight\n                    queue.append((next_node, True))\n    return [x if y == -1 else y if x == -1 else min(x, y) for (x, y) in result]"
    }
  ]
}