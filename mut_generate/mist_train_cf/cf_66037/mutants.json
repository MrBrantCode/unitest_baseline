{
  "task_id": "cf_66037",
  "entry_point": "maxProbability",
  "mutant_count": 36,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "best_prob = [0.0] * n",
      "mutated_line": "best_prob = [0.0] / n",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] / n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "best_prob = [0.0] * n",
      "mutated_line": "best_prob = [0.0] + n",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] + n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "best_prob = [0.0] * n",
      "mutated_line": "best_prob = [0.0] ** n",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] ** n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "best_prob[start] = 1.0",
      "mutated_line": "best_prob[start] = 2.0",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 2.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "best_prob[start] = 1.0",
      "mutated_line": "best_prob[start] = 0.0",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 0.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "best_prob[start] = 1.0",
      "mutated_line": "best_prob[start] = 0",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "best_prob[start] = 1.0",
      "mutated_line": "best_prob[start] = -1.0",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = -1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "prob *= -1",
      "mutated_line": "prob /= -1",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob /= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "prob *= -1",
      "mutated_line": "prob *= +1",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= +1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if node not in visited:",
      "mutated_line": "if node in visited:",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 0.0, []",
      "mutated_line": "return (1.0, [])",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (1.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 0.0, []",
      "mutated_line": "return (-1.0, [])",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (-1.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 0.0, []",
      "mutated_line": "return (1, [])",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "best_prob = [0.0] * n",
      "mutated_line": "best_prob = [1.0] * n",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [1.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "best_prob = [0.0] * n",
      "mutated_line": "best_prob = [-1.0] * n",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [-1.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "best_prob = [0.0] * n",
      "mutated_line": "best_prob = [1] * n",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [1] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "queue = [(-1.0, start, [start])]",
      "mutated_line": "queue = [(+1.0, start, [start])]",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(+1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "prob *= -1",
      "mutated_line": "prob *= -2",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -2\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "prob *= -1",
      "mutated_line": "prob *= -0",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -0\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "prob *= -1",
      "mutated_line": "prob *= -0",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -0\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "prob *= -1",
      "mutated_line": "prob *= --1",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= --1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if node == end:",
      "mutated_line": "if node != end:",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node != end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = [(-1.0, start, [start])]",
      "mutated_line": "queue = [(-2.0, start, [start])]",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-2.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = [(-1.0, start, [start])]",
      "mutated_line": "queue = [(-0.0, start, [start])]",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-0.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = [(-1.0, start, [start])]",
      "mutated_line": "queue = [(-0, start, [start])]",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = [(-1.0, start, [start])]",
      "mutated_line": "queue = [(--1.0, start, [start])]",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(--1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if neigh not in visited:",
      "mutated_line": "if neigh in visited:",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new_prob = prob * edge_prob",
      "mutated_line": "new_prob = prob / edge_prob",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob / edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new_prob = prob * edge_prob",
      "mutated_line": "new_prob = prob + edge_prob",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob + edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new_prob = prob * edge_prob",
      "mutated_line": "new_prob = prob ** edge_prob",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob ** edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if new_prob > best_prob[neigh]:",
      "mutated_line": "if new_prob >= best_prob[neigh]:",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob >= best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if new_prob > best_prob[neigh]:",
      "mutated_line": "if new_prob <= best_prob[neigh]:",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob <= best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if new_prob > best_prob[neigh]:",
      "mutated_line": "if new_prob != best_prob[neigh]:",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob != best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))",
      "mutated_line": "heapq.heappush(queue, (+new_prob, neigh, path + [neigh]))",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (+new_prob, neigh, path + [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))",
      "mutated_line": "heapq.heappush(queue, (-new_prob, neigh, path - [neigh]))",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path - [neigh]))\n    return (0.0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heapq.heappush(queue, (-new_prob, neigh, path + [neigh]))",
      "mutated_line": "heapq.heappush(queue, (-new_prob, neigh, path * [neigh]))",
      "code": "import collections\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = collections.defaultdict(list)\n    for ((a, b), prob) in zip(edges, succProb):\n        graph[a].append((b, prob))\n        graph[b].append((a, prob))\n    best_prob = [0.0] * n\n    best_prob[start] = 1.0\n    visited = set()\n    queue = [(-1.0, start, [start])]\n    while queue:\n        (prob, node, path) = heapq.heappop(queue)\n        prob *= -1\n        if node not in visited:\n            visited.add(node)\n            if node == end:\n                return (prob, path)\n            for (neigh, edge_prob) in graph[node]:\n                if neigh not in visited:\n                    new_prob = prob * edge_prob\n                    if new_prob > best_prob[neigh]:\n                        best_prob[neigh] = new_prob\n                        heapq.heappush(queue, (-new_prob, neigh, path * [neigh]))\n    return (0.0, [])"
    }
  ]
}