{
  "task_id": "cf_100851",
  "entry_point": "longest_path",
  "mutant_count": 69,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_path_length = 0",
      "mutated_line": "max_path_length = 1",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 1\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_path_length = 0",
      "mutated_line": "max_path_length = -1",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = -1\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_path_length = 0",
      "mutated_line": "max_path_length = 1",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 1\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dfs(start, 1)",
      "mutated_line": "dfs(start, 2)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 2)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dfs(start, 1)",
      "mutated_line": "dfs(start, 0)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 0)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dfs(start, 1)",
      "mutated_line": "dfs(start, 0)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 0)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dfs(start, 1)",
      "mutated_line": "dfs(start, -1)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, -1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) or 0 <= ncol < len(maze[0]) or maze[nrow][ncol] != 1 or ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) or 0 <= ncol < len(maze[0]) or maze[nrow][ncol] != 1 or ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(1, 1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(1, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(-1, 1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(-1, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(1, 1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(1, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 2), (0, -1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 2), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 0), (0, -1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 0), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 0), (0, -1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 0), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, -1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, -1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (1, -1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (1, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (-1, -1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (-1, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (1, -1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (1, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, +1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, +1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (2, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (2, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (0, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (0, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (0, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (0, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (-1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (-1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, 1), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 1), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, -1), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, -1), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, 1), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 1), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (+1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (+1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 1)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 1)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, -1)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, -1)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 1)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 1)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "nrow, ncol = row + drow, col + dcol",
      "mutated_line": "(nrow, ncol) = (row - drow, col + dcol)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row - drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "nrow, ncol = row + drow, col + dcol",
      "mutated_line": "(nrow, ncol) = (row * drow, col + dcol)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row * drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "nrow, ncol = row + drow, col + dcol",
      "mutated_line": "(nrow, ncol) = (row + drow, col - dcol)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col - dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "nrow, ncol = row + drow, col + dcol",
      "mutated_line": "(nrow, ncol) = (row + drow, col * dcol)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col * dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 < nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 < nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 > nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 > nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 == nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 == nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 < ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 < ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 > ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 > ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 == ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 == ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] == 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] == 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dfs(neighbor, path_length + 1)",
      "mutated_line": "dfs(neighbor, path_length - 1)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length - 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dfs(neighbor, path_length + 1)",
      "mutated_line": "dfs(neighbor, path_length * 1)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length * 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -2), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -2), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -0), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -0), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -0), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -0), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, --1), (1, 0), (-1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, --1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-2, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-2, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-0, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-0, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-0, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-0, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for drow, dcol in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (--1, 0)]:",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (--1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 1 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 1 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if -1 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if -1 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 1 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 1 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 1 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 1 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and -1 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and -1 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 1 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 1 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 2) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 2) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 0) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 0) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 0) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 0) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != -1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != -1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dfs(neighbor, path_length + 1)",
      "mutated_line": "dfs(neighbor, path_length + 2)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 2)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dfs(neighbor, path_length + 1)",
      "mutated_line": "dfs(neighbor, path_length + 0)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 0)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dfs(neighbor, path_length + 1)",
      "mutated_line": "dfs(neighbor, path_length + 0)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 0)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dfs(neighbor, path_length + 1)",
      "mutated_line": "dfs(neighbor, path_length + -1)",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + -1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[1]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[1]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[-1]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[-1]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[0]) and maze[nrow][ncol] != 1 and (nrow, ncol) not in visited:",
      "mutated_line": "if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[1]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):",
      "code": "def longest_path(maze, start, end):\n    visited = set()\n    max_path_length = 0\n\n    def dfs(cell, path_length):\n        nonlocal max_path_length\n        max_path_length = max(max_path_length, path_length)\n        visited.add(cell)\n        for neighbor in get_unvisited_neighbors(maze, cell, visited):\n            dfs(neighbor, path_length + 1)\n        visited.remove(cell)\n    dfs(start, 1)\n    return max_path_length\n\ndef get_unvisited_neighbors(maze, cell, visited):\n    (row, col) = cell\n    neighbors = []\n    for (drow, dcol) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        (nrow, ncol) = (row + drow, col + dcol)\n        if 0 <= nrow < len(maze) and 0 <= ncol < len(maze[1]) and (maze[nrow][ncol] != 1) and ((nrow, ncol) not in visited):\n            neighbors.append((nrow, ncol))\n    return neighbors"
    }
  ]
}