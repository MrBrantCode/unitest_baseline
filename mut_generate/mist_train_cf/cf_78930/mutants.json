{
  "task_id": "cf_78930",
  "entry_point": "game_of_life_step",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "size = grid.shape[0]",
      "mutated_line": "size = grid.shape[1]",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[1]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "size = grid.shape[0]",
      "mutated_line": "size = grid.shape[-1]",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[-1]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "size = grid.shape[0]",
      "mutated_line": "size = grid.shape[1]",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[1]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "count -= grid[i, j]",
      "mutated_line": "count += grid[i, j]",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count += grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 1\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = -1\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 1\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if grid[i, j] == 1:",
      "mutated_line": "if grid[i, j] != 1:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] != 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "for x in range(-1, 2):",
      "mutated_line": "for x in range(+1, 2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(+1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for x in range(-1, 2):",
      "mutated_line": "for x in range(-1, 3):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 3):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for x in range(-1, 2):",
      "mutated_line": "for x in range(-1, 1):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 1):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for x in range(-1, 2):",
      "mutated_line": "for x in range(-1, 0):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 0):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for x in range(-1, 2):",
      "mutated_line": "for x in range(-1, 1):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 1):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for x in range(-1, 2):",
      "mutated_line": "for x in range(-1, -2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, -2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "count += grid[row, col]",
      "mutated_line": "count -= grid[row, col]",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count -= grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if grid[i, j] == 1:",
      "mutated_line": "if grid[i, j] == 2:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 2:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if grid[i, j] == 1:",
      "mutated_line": "if grid[i, j] == 0:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 0:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if grid[i, j] == 1:",
      "mutated_line": "if grid[i, j] == 0:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 0:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if grid[i, j] == 1:",
      "mutated_line": "if grid[i, j] == -1:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == -1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 2 and count > 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 and count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif grid[i, j] == 0:",
      "mutated_line": "elif grid[i, j] != 0:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] != 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for x in range(-1, 2):",
      "mutated_line": "for x in range(-2, 2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-2, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for x in range(-1, 2):",
      "mutated_line": "for x in range(-0, 2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-0, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for x in range(-1, 2):",
      "mutated_line": "for x in range(-0, 2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-0, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for x in range(-1, 2):",
      "mutated_line": "for x in range(--1, 2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(--1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for y in range(-1, 2):",
      "mutated_line": "for y in range(+1, 2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(+1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for y in range(-1, 2):",
      "mutated_line": "for y in range(-1, 3):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 3):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for y in range(-1, 2):",
      "mutated_line": "for y in range(-1, 1):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 1):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for y in range(-1, 2):",
      "mutated_line": "for y in range(-1, 0):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 0):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for y in range(-1, 2):",
      "mutated_line": "for y in range(-1, 1):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 1):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for y in range(-1, 2):",
      "mutated_line": "for y in range(-1, -2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, -2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "col = (j + y + size) % size",
      "mutated_line": "col = (j + y + size) * size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) * size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "col = (j + y + size) % size",
      "mutated_line": "col = j + y + size + size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = j + y + size + size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "row = (i + x + size) % size",
      "mutated_line": "row = (i + x + size) * size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) * size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "row = (i + x + size) % size",
      "mutated_line": "row = i + x + size + size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = i + x + size + size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count <= 2 or count > 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count <= 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count >= 2 or count > 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count >= 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count != 2 or count > 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count != 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 2 or count >= 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count >= 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 2 or count <= 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count <= 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 2 or count != 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count != 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_grid[i, j] = 0",
      "mutated_line": "new_grid[i, j] = 1",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 1\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_grid[i, j] = 0",
      "mutated_line": "new_grid[i, j] = -1",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = -1\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_grid[i, j] = 0",
      "mutated_line": "new_grid[i, j] = 1",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 1\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif grid[i, j] == 0:",
      "mutated_line": "elif grid[i, j] == 1:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 1:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif grid[i, j] == 0:",
      "mutated_line": "elif grid[i, j] == -1:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == -1:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif grid[i, j] == 0:",
      "mutated_line": "elif grid[i, j] == 1:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 1:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if count == 3:",
      "mutated_line": "if count != 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count != 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for y in range(-1, 2):",
      "mutated_line": "for y in range(-2, 2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-2, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for y in range(-1, 2):",
      "mutated_line": "for y in range(-0, 2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-0, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for y in range(-1, 2):",
      "mutated_line": "for y in range(-0, 2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-0, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for y in range(-1, 2):",
      "mutated_line": "for y in range(--1, 2):",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(--1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "col = (j + y + size) % size",
      "mutated_line": "col = (j + y - size) % size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y - size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "col = (j + y + size) % size",
      "mutated_line": "col = (j + y) * size % size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y) * size % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "row = (i + x + size) % size",
      "mutated_line": "row = (i + x - size) % size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x - size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "row = (i + x + size) % size",
      "mutated_line": "row = (i + x) * size % size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x) * size % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 3 or count > 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 3 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 1 or count > 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 1 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 0 or count > 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 0 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 1 or count > 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 1 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < -2 or count > 3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < -2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 2 or count > 4:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 4:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 2 or count > 2:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 2:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 2 or count > 0:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 0:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 2 or count > 1:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 1:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (count < 2) or (count > 3):",
      "mutated_line": "if count < 2 or count > -3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > -3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if count == 3:",
      "mutated_line": "if count == 4:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 4:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if count == 3:",
      "mutated_line": "if count == 2:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 2:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if count == 3:",
      "mutated_line": "if count == 0:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 0:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if count == 3:",
      "mutated_line": "if count == 1:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 1:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if count == 3:",
      "mutated_line": "if count == -3:",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == -3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_grid[i, j] = 1",
      "mutated_line": "new_grid[i, j] = 2",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 2\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_grid[i, j] = 1",
      "mutated_line": "new_grid[i, j] = 0",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 0\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_grid[i, j] = 1",
      "mutated_line": "new_grid[i, j] = 0",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 0\n    return new_grid"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_grid[i, j] = 1",
      "mutated_line": "new_grid[i, j] = -1",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = -1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "col = (j + y + size) % size",
      "mutated_line": "col = (j - y + size) % size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j - y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "col = (j + y + size) % size",
      "mutated_line": "col = (j * y + size) % size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j * y + size) % size\n                    row = (i + x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "row = (i + x + size) % size",
      "mutated_line": "row = (i - x + size) % size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i - x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "row = (i + x + size) % size",
      "mutated_line": "row = (i * x + size) % size",
      "code": "import numpy as np\n\ndef game_of_life_step(grid):\n    \"\"\"\n    Simulates one step of Conway's Game of Life with toroidal boundary conditions.\n\n    Parameters:\n    grid (numpy array): The current state of the game grid.\n\n    Returns:\n    new_grid (numpy array): The state of the game grid after one step.\n    \"\"\"\n    size = grid.shape[0]\n    new_grid = np.copy(grid)\n    for i in range(size):\n        for j in range(size):\n            count = 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    col = (j + y + size) % size\n                    row = (i * x + size) % size\n                    count += grid[row, col]\n            count -= grid[i, j]\n            if grid[i, j] == 1:\n                if count < 2 or count > 3:\n                    new_grid[i, j] = 0\n            elif grid[i, j] == 0:\n                if count == 3:\n                    new_grid[i, j] = 1\n    return new_grid"
    }
  ]
}