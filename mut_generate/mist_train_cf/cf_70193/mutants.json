{
  "task_id": "cf_70193",
  "entry_point": "shortest_unique_substrings",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "result = \"\"",
      "mutated_line": "result = 'MUTATED'",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = 'MUTATED'\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "min_len = float('inf')",
      "mutated_line": "result = ''",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for sub_len in range(1, len(string) + 1):",
      "mutated_line": "for sub_len in range(2, len(string) + 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(2, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for sub_len in range(1, len(string) + 1):",
      "mutated_line": "for sub_len in range(0, len(string) + 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(0, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for sub_len in range(1, len(string) + 1):",
      "mutated_line": "for sub_len in range(0, len(string) + 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(0, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for sub_len in range(1, len(string) + 1):",
      "mutated_line": "for sub_len in range(-1, len(string) + 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(-1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for sub_len in range(1, len(string) + 1):",
      "mutated_line": "for sub_len in range(1, len(string) - 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) - 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for sub_len in range(1, len(string) + 1):",
      "mutated_line": "for sub_len in range(1, len(string) * 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) * 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for sub_len in range(1, len(string) + 1):",
      "mutated_line": "for sub_len in range(1, len(string) + 2):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 2):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for sub_len in range(1, len(string) + 1):",
      "mutated_line": "for sub_len in range(1, len(string) + 0):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 0):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for sub_len in range(1, len(string) + 1):",
      "mutated_line": "for sub_len in range(1, len(string) + 0):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 0):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for sub_len in range(1, len(string) + 1):",
      "mutated_line": "for sub_len in range(1, len(string) + -1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + -1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(1, len(string) - sub_len + 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(1, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(-1, len(string) - sub_len + 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(-1, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(1, len(string) - sub_len + 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(1, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(0, len(string) - sub_len - 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len - 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(0, (len(string) - sub_len) * 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, (len(string) - sub_len) * 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] or substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] or substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(0, len(string) + sub_len + 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) + sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(0, len(string) * sub_len + 1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) * sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(0, len(string) - sub_len + 2):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 2):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(0, len(string) - sub_len + 0):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 0):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(0, len(string) - sub_len + 0):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 0):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for start_index in range(0, len(string) - sub_len + 1):",
      "mutated_line": "for start_index in range(0, len(string) - sub_len + -1):",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + -1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if sub_len < min_len:",
      "mutated_line": "if sub_len <= min_len:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len <= min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if sub_len < min_len:",
      "mutated_line": "if sub_len >= min_len:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len >= min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if sub_len < min_len:",
      "mutated_line": "if sub_len != min_len:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len != min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "substring = string[start_index:start_index + sub_len]",
      "mutated_line": "substring = string[start_index:start_index - sub_len]",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index - sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "substring = string[start_index:start_index + sub_len]",
      "mutated_line": "substring = string[start_index:start_index * sub_len]",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index * sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) * 3] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) * 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[i + 1 + 3] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[i + 1 + 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) * 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) * 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[i + 2 + 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[i + 2 + 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i - 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i - 1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[i * 1 % 3] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[i * 1 % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 4] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 4] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 2] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 2] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 0] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 0] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 1] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 1] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % -3] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % -3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i - 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i - 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[i * 2 % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[i * 2 % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 4]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 4]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 2]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 2]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 0]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 0]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 1]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 1]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % -3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % -3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 2) % 3] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 2) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 0) % 3] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 0) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 0) % 3] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 0) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + -1) % 3] and substring not in sets[(i + 2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + -1) % 3] and substring not in sets[(i + 2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 3) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 3) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 1) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 1) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 0) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 0) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 1) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 1) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + 2) % 3]:",
      "mutated_line": "if substring not in sets[(i + 1) % 3] and substring not in sets[(i + -2) % 3]:",
      "code": "def shortest_unique_substrings(n, m, p):\n    min_len = float('inf')\n    result = ''\n    sets = [set(), set(), set()]\n    for (i, string) in enumerate([n, m, p]):\n        for sub_len in range(1, len(string) + 1):\n            for start_index in range(0, len(string) - sub_len + 1):\n                substring = string[start_index:start_index + sub_len]\n                if substring not in sets[(i + 1) % 3] and substring not in sets[(i + -2) % 3]:\n                    sets[i].add(substring)\n                    if sub_len < min_len:\n                        min_len = sub_len\n                        result = substring\n    return result if result else None"
    }
  ]
}