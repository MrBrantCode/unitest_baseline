{
  "task_id": "cf_27839",
  "entry_point": "shortest_distance",
  "mutant_count": 65,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "min_distance = float('inf')",
      "mutated_line": "min_distance = float('')",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "min_vertices = (0, 0)",
      "mutated_line": "min_vertices = (1, 0)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (1, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "min_vertices = (0, 0)",
      "mutated_line": "min_vertices = (-1, 0)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (-1, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "min_vertices = (0, 0)",
      "mutated_line": "min_vertices = (1, 0)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (1, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "min_vertices = (0, 0)",
      "mutated_line": "min_vertices = (0, 1)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 1)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "min_vertices = (0, 0)",
      "mutated_line": "min_vertices = (0, -1)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, -1)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "min_vertices = (0, 0)",
      "mutated_line": "min_vertices = (0, 1)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 1)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 - (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 - (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt(((x2 - x1) ** 2 + (y2 - y1) ** 2) * (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt(((x2 - x1) ** 2 + (y2 - y1) ** 2) * (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(vertices)):",
      "mutated_line": "for j in range(i - 1, len(vertices)):",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i - 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(vertices)):",
      "mutated_line": "for j in range(i * 1, len(vertices)):",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i * 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if distance < min_distance:",
      "mutated_line": "if distance <= min_distance:",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance <= min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if distance < min_distance:",
      "mutated_line": "if distance >= min_distance:",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance >= min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if distance < min_distance:",
      "mutated_line": "if distance != min_distance:",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance != min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 - (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 - (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 * (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 * (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) * 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) * 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1 + 2))",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1 + 2))\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(vertices)):",
      "mutated_line": "for j in range(i + 2, len(vertices)):",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 2, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(vertices)):",
      "mutated_line": "for j in range(i + 0, len(vertices)):",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 0, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(vertices)):",
      "mutated_line": "for j in range(i + 0, len(vertices)):",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 0, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(vertices)):",
      "mutated_line": "for j in range(i + -1, len(vertices)):",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + -1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x1, y1, z1 = map(float, vertex1.split()[2:])",
      "mutated_line": "(x1, y1, z1) = map(float, vertex1.split()[3:])",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[3:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x1, y1, z1 = map(float, vertex1.split()[2:])",
      "mutated_line": "(x1, y1, z1) = map(float, vertex1.split()[1:])",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[1:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x1, y1, z1 = map(float, vertex1.split()[2:])",
      "mutated_line": "(x1, y1, z1) = map(float, vertex1.split()[0:])",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[0:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x1, y1, z1 = map(float, vertex1.split()[2:])",
      "mutated_line": "(x1, y1, z1) = map(float, vertex1.split()[1:])",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[1:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x1, y1, z1 = map(float, vertex1.split()[2:])",
      "mutated_line": "(x1, y1, z1) = map(float, vertex1.split()[-2:])",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[-2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x2, y2, z2 = map(float, vertex2.split()[2:])",
      "mutated_line": "(x2, y2, z2) = map(float, vertex2.split()[3:])",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[3:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x2, y2, z2 = map(float, vertex2.split()[2:])",
      "mutated_line": "(x2, y2, z2) = map(float, vertex2.split()[1:])",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[1:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x2, y2, z2 = map(float, vertex2.split()[2:])",
      "mutated_line": "(x2, y2, z2) = map(float, vertex2.split()[0:])",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[0:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x2, y2, z2 = map(float, vertex2.split()[2:])",
      "mutated_line": "(x2, y2, z2) = map(float, vertex2.split()[1:])",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[1:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x2, y2, z2 = map(float, vertex2.split()[2:])",
      "mutated_line": "(x2, y2, z2) = map(float, vertex2.split()[-2:])",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[-2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) * 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) * 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt(x2 - x1 + 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt(x2 - x1 + 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) * 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) * 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1 + 2) + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1 + 2) + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 + z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 + z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 * z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 * z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 3)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 3)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 1)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 1)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 0)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 0)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 1)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 1)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** -2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** -2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 + x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 + x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 * x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 * x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 3 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 3 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 1 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 1 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 0 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 0 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 1 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 1 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** -2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** -2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 + y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 + y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 * y1) ** 2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 * y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 3 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 3 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 1 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 1 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 0 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 0 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 1 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 1 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)",
      "mutated_line": "return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** -2 + (z2 - z1) ** 2)",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** -2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))",
      "mutated_line": "min_vertices = (int(vertices[i].split()[2]), int(vertices[j].split()[1]))",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[2]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))",
      "mutated_line": "min_vertices = (int(vertices[i].split()[0]), int(vertices[j].split()[1]))",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[0]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))",
      "mutated_line": "min_vertices = (int(vertices[i].split()[0]), int(vertices[j].split()[1]))",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[0]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))",
      "mutated_line": "min_vertices = (int(vertices[i].split()[-1]), int(vertices[j].split()[1]))",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[-1]), int(vertices[j].split()[1]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))",
      "mutated_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[2]))",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[2]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))",
      "mutated_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[0]))",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[0]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))",
      "mutated_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[0]))",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[0]))\n    return min_vertices"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[1]))",
      "mutated_line": "min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[-1]))",
      "code": "from typing import List, Tuple\nimport math\n\ndef shortest_distance(vertices: List[str]) -> Tuple[int, int]:\n\n    def calculate_distance(vertex1, vertex2):\n        (x1, y1, z1) = map(float, vertex1.split()[2:])\n        (x2, y2, z2) = map(float, vertex2.split()[2:])\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n    min_distance = float('inf')\n    min_vertices = (0, 0)\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            distance = calculate_distance(vertices[i], vertices[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_vertices = (int(vertices[i].split()[1]), int(vertices[j].split()[-1]))\n    return min_vertices"
    }
  ]
}