{
  "task_id": "cf_54689",
  "entry_point": "knapsack_greedy",
  "mutant_count": 8,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def knapsack_greedy(items, capacity):\n    \"\"\"\"\"\"\n    ratios = [(value / weight, weight, value) for (weight, value) in items]\n    ratios.sort(reverse=True)\n    selected_items = []\n    remaining_capacity = capacity\n    for (ratio, weight, value) in ratios:\n        if weight <= remaining_capacity:\n            selected_items.append((weight, value))\n            remaining_capacity -= weight\n    return selected_items"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if weight <= remaining_capacity:",
      "mutated_line": "if weight < remaining_capacity:",
      "code": "def knapsack_greedy(items, capacity):\n    \"\"\"\n    A greedy algorithm for the 0/1 knapsack problem.\n\n    Parameters:\n    items (list): A list of items where each item is represented as a tuple (weight, value)\n    capacity (int): The maximum capacity of the knapsack\n\n    Returns:\n    list: A list of the selected items\n    \"\"\"\n    ratios = [(value / weight, weight, value) for (weight, value) in items]\n    ratios.sort(reverse=True)\n    selected_items = []\n    remaining_capacity = capacity\n    for (ratio, weight, value) in ratios:\n        if weight < remaining_capacity:\n            selected_items.append((weight, value))\n            remaining_capacity -= weight\n    return selected_items"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if weight <= remaining_capacity:",
      "mutated_line": "if weight > remaining_capacity:",
      "code": "def knapsack_greedy(items, capacity):\n    \"\"\"\n    A greedy algorithm for the 0/1 knapsack problem.\n\n    Parameters:\n    items (list): A list of items where each item is represented as a tuple (weight, value)\n    capacity (int): The maximum capacity of the knapsack\n\n    Returns:\n    list: A list of the selected items\n    \"\"\"\n    ratios = [(value / weight, weight, value) for (weight, value) in items]\n    ratios.sort(reverse=True)\n    selected_items = []\n    remaining_capacity = capacity\n    for (ratio, weight, value) in ratios:\n        if weight > remaining_capacity:\n            selected_items.append((weight, value))\n            remaining_capacity -= weight\n    return selected_items"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if weight <= remaining_capacity:",
      "mutated_line": "if weight == remaining_capacity:",
      "code": "def knapsack_greedy(items, capacity):\n    \"\"\"\n    A greedy algorithm for the 0/1 knapsack problem.\n\n    Parameters:\n    items (list): A list of items where each item is represented as a tuple (weight, value)\n    capacity (int): The maximum capacity of the knapsack\n\n    Returns:\n    list: A list of the selected items\n    \"\"\"\n    ratios = [(value / weight, weight, value) for (weight, value) in items]\n    ratios.sort(reverse=True)\n    selected_items = []\n    remaining_capacity = capacity\n    for (ratio, weight, value) in ratios:\n        if weight == remaining_capacity:\n            selected_items.append((weight, value))\n            remaining_capacity -= weight\n    return selected_items"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "remaining_capacity -= weight",
      "mutated_line": "remaining_capacity += weight",
      "code": "def knapsack_greedy(items, capacity):\n    \"\"\"\n    A greedy algorithm for the 0/1 knapsack problem.\n\n    Parameters:\n    items (list): A list of items where each item is represented as a tuple (weight, value)\n    capacity (int): The maximum capacity of the knapsack\n\n    Returns:\n    list: A list of the selected items\n    \"\"\"\n    ratios = [(value / weight, weight, value) for (weight, value) in items]\n    ratios.sort(reverse=True)\n    selected_items = []\n    remaining_capacity = capacity\n    for (ratio, weight, value) in ratios:\n        if weight <= remaining_capacity:\n            selected_items.append((weight, value))\n            remaining_capacity += weight\n    return selected_items"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ratios = [(value / weight, weight, value) for weight, value in items]",
      "mutated_line": "ratios = [(value * weight, weight, value) for (weight, value) in items]",
      "code": "def knapsack_greedy(items, capacity):\n    \"\"\"\n    A greedy algorithm for the 0/1 knapsack problem.\n\n    Parameters:\n    items (list): A list of items where each item is represented as a tuple (weight, value)\n    capacity (int): The maximum capacity of the knapsack\n\n    Returns:\n    list: A list of the selected items\n    \"\"\"\n    ratios = [(value * weight, weight, value) for (weight, value) in items]\n    ratios.sort(reverse=True)\n    selected_items = []\n    remaining_capacity = capacity\n    for (ratio, weight, value) in ratios:\n        if weight <= remaining_capacity:\n            selected_items.append((weight, value))\n            remaining_capacity -= weight\n    return selected_items"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ratios = [(value / weight, weight, value) for weight, value in items]",
      "mutated_line": "ratios = [(value // weight, weight, value) for (weight, value) in items]",
      "code": "def knapsack_greedy(items, capacity):\n    \"\"\"\n    A greedy algorithm for the 0/1 knapsack problem.\n\n    Parameters:\n    items (list): A list of items where each item is represented as a tuple (weight, value)\n    capacity (int): The maximum capacity of the knapsack\n\n    Returns:\n    list: A list of the selected items\n    \"\"\"\n    ratios = [(value // weight, weight, value) for (weight, value) in items]\n    ratios.sort(reverse=True)\n    selected_items = []\n    remaining_capacity = capacity\n    for (ratio, weight, value) in ratios:\n        if weight <= remaining_capacity:\n            selected_items.append((weight, value))\n            remaining_capacity -= weight\n    return selected_items"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ratios.sort(reverse=True)",
      "mutated_line": "ratios.sort(reverse=False)",
      "code": "def knapsack_greedy(items, capacity):\n    \"\"\"\n    A greedy algorithm for the 0/1 knapsack problem.\n\n    Parameters:\n    items (list): A list of items where each item is represented as a tuple (weight, value)\n    capacity (int): The maximum capacity of the knapsack\n\n    Returns:\n    list: A list of the selected items\n    \"\"\"\n    ratios = [(value / weight, weight, value) for (weight, value) in items]\n    ratios.sort(reverse=False)\n    selected_items = []\n    remaining_capacity = capacity\n    for (ratio, weight, value) in ratios:\n        if weight <= remaining_capacity:\n            selected_items.append((weight, value))\n            remaining_capacity -= weight\n    return selected_items"
    }
  ]
}