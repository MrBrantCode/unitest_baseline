{
  "task_id": "cf_78273",
  "entry_point": "maximumPath",
  "mutant_count": 103,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid and len(grid) == 0 and (len(grid[0]) == 0):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid and len(grid) == 0 and (len(grid[0]) == 0):\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) != 0 or len(grid[0]) == 0:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) != 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) == 0 or len(grid[0]) != 0:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) != 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 and y < 0 and (k < 0) and (x >= rows) and (y >= cols) and (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 and y < 0 and (k < 0) and (x >= rows) and (y >= cols) and (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k == 1:",
      "mutated_line": "if k != 1:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k != 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "res = -sys.maxsize",
      "mutated_line": "for (dx, dy) in directions:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = +sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) == 1 or len(grid[0]) == 0:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 1 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) == -1 or len(grid[0]) == 0:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == -1 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) == 1 or len(grid[0]) == 0:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 1 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) == 0 or len(grid[0]) == 1:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 1:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) == 0 or len(grid[0]) == -1:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == -1:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) == 0 or len(grid[0]) == 1:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 1:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] / (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] + (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] ** (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(-1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(-1, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 2), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 2), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, -1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, -1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (2, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (2, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (-1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (-1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, -1), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, -1), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (-1, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, +1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, +1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (+1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (+1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, -1)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, -1)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x <= 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x <= 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x >= 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x >= 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x != 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x != 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y <= 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y <= 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y >= 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y >= 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y != 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y != 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k <= 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k <= 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k >= 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k >= 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k != 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k != 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < 0 or (x > rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x > rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < 0 or (x < rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x < rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < 0 or (x == rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x == rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < 0 or (x >= rows) or (y > cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y > cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < 0 or (x >= rows) or (y < cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y < cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < 0 or (x >= rows) or (y == cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y == cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] == -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] == -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "return -sys.maxsize",
      "mutated_line": "return +sys.maxsize",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return +sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 2:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 2:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 0:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 0:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k == 1:",
      "mutated_line": "if k == -1:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == -1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[1]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[-1]))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[-1]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[1]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k - 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k * 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -2), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -2), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, --1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, --1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-2, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-2, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (--1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (--1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 1 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 1 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < -1 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < -1 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 1 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 1 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 1 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 1 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < -1 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < -1 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 1 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 1 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < 1 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 1 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < -1 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < -1 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < 1 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 1 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "if x < 0 or y < 0 or k < 0 or x >= rows or y >= cols or memo[x][y][k] != -sys.maxsize:",
      "mutated_line": "if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != +sys.maxsize):",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != +sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] - dfs(x + dx, y + dy, k - 1))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] - dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] * dfs(x + dx, y + dy, k - 1))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] * dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "return max(dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize)",
      "mutated_line": "return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) == -sys.maxsize))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) == -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) == 0 or len(grid[1]) == 0:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[1]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) == 0 or len(grid[-1]) == 0:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[-1]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or len(grid) == 0 or len(grid[0]) == 0:",
      "mutated_line": "if not grid or len(grid) == 0 or len(grid[1]) == 0:",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[1]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[+sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 2) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 0) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 0) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + -1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "return max(dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize)",
      "mutated_line": "return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != +sys.maxsize))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != +sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] + dfs(x - dx, y + dy, k - 1))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x - dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] + dfs(x * dx, y + dy, k - 1))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x * dx, y + dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] + dfs(x + dx, y - dy, k - 1))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y - dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] + dfs(x + dx, y * dy, k - 1))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y * dy, k - 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k + 1))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k + 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k * 1))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k * 1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 2))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 2))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 0))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 0))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 0))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 0))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - 1))",
      "mutated_line": "res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - -1))",
      "code": "import sys\n\ndef maximumPath(grid, k):\n    if not grid or len(grid) == 0 or len(grid[0]) == 0:\n        return None\n    (rows, cols) = (len(grid), len(grid[0]))\n    memo = [[[-sys.maxsize] * (k + 1) for _ in range(cols)] for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, k):\n        if x < 0 or y < 0 or k < 0 or (x >= rows) or (y >= cols) or (memo[x][y][k] != -sys.maxsize):\n            return -sys.maxsize\n        if k == 1:\n            return grid[x][y]\n        res = -sys.maxsize\n        for (dx, dy) in directions:\n            res = max(res, grid[x][y] + dfs(x + dx, y + dy, k - -1))\n        memo[x][y][k] = res\n        return res\n    return max((dfs(i, j, k) for i in range(rows) for j in range(cols) if dfs(i, j, k) != -sys.maxsize))"
    }
  ]
}