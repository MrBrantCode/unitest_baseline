{
  "task_id": "cf_50464",
  "entry_point": "max_overlapping_events",
  "mutant_count": 42,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "heap += [(end, 0) for start, end, attendees in events]",
      "mutated_line": "heap -= [(end, 0) for (start, end, attendees) in events]",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap -= [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_attendees, current_attendees = 0, 0",
      "mutated_line": "(max_events, current_events) = (0, 0)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (1, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_attendees, current_attendees = 0, 0",
      "mutated_line": "(max_events, current_events) = (0, 0)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (-1, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_attendees, current_attendees = 0, 0",
      "mutated_line": "(max_events, current_events) = (0, 0)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (1, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_attendees, current_attendees = 0, 0",
      "mutated_line": "(max_events, current_events) = (0, 0)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 1)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_attendees, current_attendees = 0, 0",
      "mutated_line": "(max_events, current_events) = (0, 0)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, -1)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_attendees, current_attendees = 0, 0",
      "mutated_line": "(max_events, current_events) = (0, 0)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 1)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_events, current_events = 0, 0",
      "mutated_line": "(max_events, current_events) = (1, 0)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (1, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_events, current_events = 0, 0",
      "mutated_line": "(max_events, current_events) = (-1, 0)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (-1, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_events, current_events = 0, 0",
      "mutated_line": "(max_events, current_events) = (1, 0)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (1, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_events, current_events = 0, 0",
      "mutated_line": "(max_events, current_events) = (0, 1)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 1)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_events, current_events = 0, 0",
      "mutated_line": "(max_events, current_events) = (0, -1)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, -1)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "max_events, current_events = 0, 0",
      "mutated_line": "(max_events, current_events) = (0, 1)",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 1)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if attendees > 0:",
      "mutated_line": "if attendees >= 0:",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees >= 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if attendees > 0:",
      "mutated_line": "if attendees <= 0:",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees <= 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if attendees > 0:",
      "mutated_line": "if attendees != 0:",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees != 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "current_events += 1",
      "mutated_line": "current_events -= 1",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events -= 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "current_attendees += attendees",
      "mutated_line": "current_attendees -= attendees",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees -= attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "current_events -= 1",
      "mutated_line": "current_events += 1",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events += 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "mutated_line": "if current_attendees > max_attendees and (current_attendees == max_attendees and current_events > max_events):",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees and (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap += [(end, 0) for start, end, attendees in events]",
      "mutated_line": "heap += [(end, 1) for (start, end, attendees) in events]",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 1) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap += [(end, 0) for start, end, attendees in events]",
      "mutated_line": "heap += [(end, -1) for (start, end, attendees) in events]",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, -1) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap += [(end, 0) for start, end, attendees in events]",
      "mutated_line": "heap += [(end, 1) for (start, end, attendees) in events]",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 1) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if attendees > 0:",
      "mutated_line": "if attendees > 1:",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 1:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if attendees > 0:",
      "mutated_line": "if attendees > -1:",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > -1:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if attendees > 0:",
      "mutated_line": "if attendees > 1:",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 1:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_events += 1",
      "mutated_line": "current_events += 2",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 2\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_events += 1",
      "mutated_line": "current_events += 0",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 0\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_events += 1",
      "mutated_line": "current_events += 0",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 0\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "current_events += 1",
      "mutated_line": "current_events += -1",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += -1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current_events -= 1",
      "mutated_line": "current_events -= 2",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 2\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current_events -= 1",
      "mutated_line": "current_events -= 0",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 0\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current_events -= 1",
      "mutated_line": "current_events -= 0",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 0\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current_events -= 1",
      "mutated_line": "current_events -= -1",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= -1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "mutated_line": "if current_attendees >= max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees >= max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "mutated_line": "if current_attendees <= max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees <= max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "mutated_line": "if current_attendees != max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees != max_attendees or (current_attendees == max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "mutated_line": "if current_attendees > max_attendees or (current_attendees == max_attendees or current_events > max_events):",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees or current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "mutated_line": "if current_attendees > max_attendees or (current_attendees != max_attendees and current_events > max_events):",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees != max_attendees and current_events > max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "mutated_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events >= max_events):",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events >= max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "mutated_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events <= max_events):",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events <= max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events > max_events):",
      "mutated_line": "if current_attendees > max_attendees or (current_attendees == max_attendees and current_events != max_events):",
      "code": "import heapq\n\ndef max_overlapping_events(events):\n    heap = [(start, attendees) for (start, end, attendees) in events]\n    heap += [(end, 0) for (start, end, attendees) in events]\n    heapq.heapify(heap)\n    (max_attendees, current_attendees) = (0, 0)\n    (max_events, current_events) = (0, 0)\n    while heap:\n        (time, attendees) = heapq.heappop(heap)\n        if attendees > 0:\n            current_events += 1\n            current_attendees += attendees\n        else:\n            current_events -= 1\n        if current_attendees > max_attendees or (current_attendees == max_attendees and current_events != max_events):\n            max_attendees = current_attendees\n            max_events = current_events\n    return (max_events, max_attendees)"
    }
  ]
}