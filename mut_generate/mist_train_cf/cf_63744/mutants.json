{
  "task_id": "cf_63744",
  "entry_point": "minMoves",
  "mutant_count": 166,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "total_sum = 0",
      "mutated_line": "total_sum = 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 1\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "total_sum = 0",
      "mutated_line": "total_sum = -1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = -1\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "total_sum = 0",
      "mutated_line": "total_sum = 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 1\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "total_sum += s",
      "mutated_line": "total_sum -= s",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum -= s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 1\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = -1\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 1\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "j = len(sorted_counts) - 1",
      "mutated_line": "j = len(sorted_counts) + 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) + 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "j = len(sorted_counts) - 1",
      "mutated_line": "j = len(sorted_counts) * 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) * 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while i <= j:",
      "mutated_line": "while i < j:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i < j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while i <= j:",
      "mutated_line": "while i > j:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i > j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while i <= j:",
      "mutated_line": "while i == j:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i == j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "not_exceed += (X - 1) * equal",
      "mutated_line": "not_exceed -= (X - 1) * equal",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed -= (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i -= 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n / 2):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n / 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n * 2):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n * 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "s = nums[i] + nums[n - 1 - i]",
      "mutated_line": "s = nums[i] - nums[n - 1 - i]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] - nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "s = nums[i] + nums[n - 1 - i]",
      "mutated_line": "s = nums[i] * nums[n - 1 - i]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] * nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if s not in counts:",
      "mutated_line": "if s in counts:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "counts[s] += 1",
      "mutated_line": "counts[s] -= 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] -= 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = len(sorted_counts) - 1",
      "mutated_line": "j = len(sorted_counts) - 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 2\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = len(sorted_counts) - 1",
      "mutated_line": "j = len(sorted_counts) - 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 0\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = len(sorted_counts) - 1",
      "mutated_line": "j = len(sorted_counts) - 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 0\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = len(sorted_counts) - 1",
      "mutated_line": "j = len(sorted_counts) - -1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - -1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "optimal = float('inf')",
      "mutated_line": "optimal = float('')",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "equal += sorted_counts[k][1]",
      "mutated_line": "equal -= sorted_counts[k][1]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal -= sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed -= sorted_counts[k][1] * 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed -= sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "not_exceed += (X - 1) * equal",
      "mutated_line": "not_exceed += (X - 1) / equal",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) / equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "not_exceed += (X - 1) * equal",
      "mutated_line": "not_exceed += X - 1 + equal",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += X - 1 + equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "not_exceed += (X - 1) * equal",
      "mutated_line": "not_exceed += (X - 1) ** equal",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) ** equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if total_sum - equal * X + not_exceed <= limit:",
      "mutated_line": "if total_sum - equal * X + not_exceed < limit:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed < limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if total_sum - equal * X + not_exceed <= limit:",
      "mutated_line": "if total_sum - equal * X + not_exceed > limit:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed > limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if total_sum - equal * X + not_exceed <= limit:",
      "mutated_line": "if total_sum - equal * X + not_exceed == limit:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed == limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 2\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 0\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 0\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += -1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j or sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j or sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j += 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 3):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 3):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 1):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 0):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 0):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 1):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // -2):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // -2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "counts[s] = 1",
      "mutated_line": "counts[s] = 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 2\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "counts[s] = 1",
      "mutated_line": "counts[s] = 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 0\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "counts[s] = 1",
      "mutated_line": "counts[s] = 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 0\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "counts[s] = 1",
      "mutated_line": "counts[s] = -1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = -1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "counts[s] += 1",
      "mutated_line": "counts[s] += 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 2\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "counts[s] += 1",
      "mutated_line": "counts[s] += 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 0\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "counts[s] += 1",
      "mutated_line": "counts[s] += 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 0\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "counts[s] += 1",
      "mutated_line": "counts[s] += -1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += -1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "X = sorted_counts[i][0]",
      "mutated_line": "X = sorted_counts[i][1]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][1]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "X = sorted_counts[i][0]",
      "mutated_line": "X = sorted_counts[i][-1]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][-1]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "X = sorted_counts[i][0]",
      "mutated_line": "X = sorted_counts[i][1]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][1]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "equal = sorted_counts[i][1]",
      "mutated_line": "equal = sorted_counts[i][2]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][2]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "equal = sorted_counts[i][1]",
      "mutated_line": "equal = sorted_counts[i][0]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][0]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "equal = sorted_counts[i][1]",
      "mutated_line": "equal = sorted_counts[i][0]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][0]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "equal = sorted_counts[i][1]",
      "mutated_line": "equal = sorted_counts[i][-1]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][-1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "not_exceed = sorted_counts[i][1]",
      "mutated_line": "not_exceed = sorted_counts[i][2]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][2]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "not_exceed = sorted_counts[i][1]",
      "mutated_line": "not_exceed = sorted_counts[i][0]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][0]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "not_exceed = sorted_counts[i][1]",
      "mutated_line": "not_exceed = sorted_counts[i][0]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][0]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "not_exceed = sorted_counts[i][1]",
      "mutated_line": "not_exceed = sorted_counts[i][-1]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][-1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i - 1, j + 1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i - 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i * 1, j + 1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i * 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i + 1, j - 1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j - 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i + 1, j * 1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j * 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][1] / 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] / 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][1] + 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] + 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][1] ** 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] ** 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "not_exceed += (X - 1) * equal",
      "mutated_line": "not_exceed += (X + 1) * equal",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X + 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "not_exceed += (X - 1) * equal",
      "mutated_line": "not_exceed += X * 1 * equal",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += X * 1 * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if total_sum - equal * X + not_exceed <= limit:",
      "mutated_line": "if total_sum - equal * X - not_exceed <= limit:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X - not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if total_sum - equal * X + not_exceed <= limit:",
      "mutated_line": "if (total_sum - equal * X) * not_exceed <= limit:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if (total_sum - equal * X) * not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "diff = total_sum - equal * X + not_exceed - limit",
      "mutated_line": "diff = total_sum - equal * X + not_exceed + limit",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed + limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "diff = total_sum - equal * X + not_exceed - limit",
      "mutated_line": "diff = (total_sum - equal * X + not_exceed) * limit",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = (total_sum - equal * X + not_exceed) * limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i < j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i < j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i > j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i > j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i == j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i == j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] >= 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] >= 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] <= 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] <= 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] != 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] != 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 2\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 0\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 0\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= -1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "s = nums[i] + nums[n - 1 - i]",
      "mutated_line": "s = nums[i] + nums[n - 1 + i]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 + i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "s = nums[i] + nums[n - 1 - i]",
      "mutated_line": "s = nums[i] + nums[(n - 1) * i]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[(n - 1) * i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i + 2, j + 1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 2, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i + 0, j + 1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 0, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i + 0, j + 1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 0, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i + -1, j + 1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + -1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i + 1, j + 2):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 2):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i + 1, j + 0):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 0):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i + 1, j + 0):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 0):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(i + 1, j + 1):",
      "mutated_line": "for k in range(i + 1, j + -1):",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + -1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "equal += sorted_counts[k][1]",
      "mutated_line": "equal += sorted_counts[k][2]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][2]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "equal += sorted_counts[k][1]",
      "mutated_line": "equal += sorted_counts[k][0]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][0]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "equal += sorted_counts[k][1]",
      "mutated_line": "equal += sorted_counts[k][0]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][0]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "equal += sorted_counts[k][1]",
      "mutated_line": "equal += sorted_counts[k][-1]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][-1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][1] * 3",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 3\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][1] * 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 1\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][1] * 0",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 0\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][1] * 1",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 1\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][1] * -2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * -2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "not_exceed += (X - 1) * equal",
      "mutated_line": "not_exceed += (X - 2) * equal",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 2) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "not_exceed += (X - 1) * equal",
      "mutated_line": "not_exceed += (X - 0) * equal",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 0) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "not_exceed += (X - 1) * equal",
      "mutated_line": "not_exceed += (X - 0) * equal",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 0) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "not_exceed += (X - 1) * equal",
      "mutated_line": "not_exceed += (X - -1) * equal",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - -1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if total_sum - equal * X + not_exceed <= limit:",
      "mutated_line": "if total_sum + equal * X + not_exceed <= limit:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum + equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if total_sum - equal * X + not_exceed <= limit:",
      "mutated_line": "if total_sum * (equal * X) + not_exceed <= limit:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum * (equal * X) + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "optimal = min(optimal, n - equal)",
      "mutated_line": "optimal = min(optimal, n + equal)",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n + equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "optimal = min(optimal, n - equal)",
      "mutated_line": "optimal = min(optimal, n * equal)",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n * equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "diff = total_sum - equal * X + not_exceed - limit",
      "mutated_line": "diff = total_sum - equal * X - not_exceed - limit",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X - not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "diff = total_sum - equal * X + not_exceed - limit",
      "mutated_line": "diff = (total_sum - equal * X) * not_exceed - limit",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = (total_sum - equal * X) * not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal - (diff + X - 2) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal - (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, (n - equal) * ((diff + X - 2) // (X - 1)))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, (n - equal) * ((diff + X - 2) // (X - 1)))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] + sorted_counts[i][0] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] + sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] * sorted_counts[i][0] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] * sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 2:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 2:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 0:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 0:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 0:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 0:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > -1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > -1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "s = nums[i] + nums[n - 1 - i]",
      "mutated_line": "s = nums[i] + nums[n + 1 - i]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n + 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "s = nums[i] + nums[n - 1 - i]",
      "mutated_line": "s = nums[i] + nums[n * 1 - i]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n * 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][2] * 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][2] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][0] * 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][0] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][0] * 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][0] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "not_exceed += sorted_counts[k][1] * 2",
      "mutated_line": "not_exceed += sorted_counts[k][-1] * 2",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][-1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if total_sum - equal * X + not_exceed <= limit:",
      "mutated_line": "if total_sum - equal / X + not_exceed <= limit:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal / X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if total_sum - equal * X + not_exceed <= limit:",
      "mutated_line": "if total_sum - (equal + X) + not_exceed <= limit:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - (equal + X) + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if total_sum - equal * X + not_exceed <= limit:",
      "mutated_line": "if total_sum - equal ** X + not_exceed <= limit:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal ** X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "diff = total_sum - equal * X + not_exceed - limit",
      "mutated_line": "diff = total_sum + equal * X + not_exceed - limit",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum + equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "diff = total_sum - equal * X + not_exceed - limit",
      "mutated_line": "diff = total_sum * (equal * X) + not_exceed - limit",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum * (equal * X) + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n + equal + (diff + X - 2) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n + equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n * equal + (diff + X - 2) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n * equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 2) / (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) / (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 2) * (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) * (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "s = nums[i] + nums[n - 1 - i]",
      "mutated_line": "s = nums[i] + nums[n - 2 - i]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 2 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "s = nums[i] + nums[n - 1 - i]",
      "mutated_line": "s = nums[i] + nums[n - 0 - i]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 0 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "s = nums[i] + nums[n - 1 - i]",
      "mutated_line": "s = nums[i] + nums[n - 0 - i]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 0 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "s = nums[i] + nums[n - 1 - i]",
      "mutated_line": "s = nums[i] + nums[n - -1 - i]",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - -1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "diff = total_sum - equal * X + not_exceed - limit",
      "mutated_line": "diff = total_sum - equal / X + not_exceed - limit",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal / X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "diff = total_sum - equal * X + not_exceed - limit",
      "mutated_line": "diff = total_sum - (equal + X) + not_exceed - limit",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - (equal + X) + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "diff = total_sum - equal * X + not_exceed - limit",
      "mutated_line": "diff = total_sum - equal ** X + not_exceed - limit",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal ** X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X + 2) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X + 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X) * 2 // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X) * 2 // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X + 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X + 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X * 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X * 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][1] - sorted_counts[i][0] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][1] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][-1] - sorted_counts[i][0] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][-1] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][1] - sorted_counts[i][0] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][1] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][1] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][1] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][-1] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][-1] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:",
      "mutated_line": "if i <= j and sorted_counts[j][0] - sorted_counts[i][1] > 1:",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][1] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff - X - 2) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff - X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff * X - 2) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff * X - 2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 3) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 3) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 1) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 1) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 0) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 0) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 1) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 1) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - -2) // (X - 1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - -2) // (X - 1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 2))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 2))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 0))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 0))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 0))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - 0))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - 1))",
      "mutated_line": "optimal = min(optimal, n - equal + (diff + X - 2) // (X - -1))",
      "code": "def minMoves(nums, limit):\n    n = len(nums)\n    counts = {}\n    total_sum = 0\n    for i in range(n // 2):\n        s = nums[i] + nums[n - 1 - i]\n        total_sum += s\n        if s not in counts:\n            counts[s] = 1\n        else:\n            counts[s] += 1\n    sorted_counts = sorted(counts.items())\n    i = 0\n    j = len(sorted_counts) - 1\n    optimal = float('inf')\n    while i <= j:\n        X = sorted_counts[i][0]\n        equal = sorted_counts[i][1]\n        not_exceed = sorted_counts[i][1]\n        for k in range(i + 1, j + 1):\n            equal += sorted_counts[k][1]\n            not_exceed += sorted_counts[k][1] * 2\n        not_exceed += (X - 1) * equal\n        if total_sum - equal * X + not_exceed <= limit:\n            optimal = min(optimal, n - equal)\n        else:\n            diff = total_sum - equal * X + not_exceed - limit\n            optimal = min(optimal, n - equal + (diff + X - 2) // (X - -1))\n        i += 1\n        if i <= j and sorted_counts[j][0] - sorted_counts[i][0] > 1:\n            j -= 1\n    return optimal"
    }
  ]
}