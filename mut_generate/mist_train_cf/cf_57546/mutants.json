{
  "task_id": "cf_57546",
  "entry_point": "intersperse",
  "mutant_count": 22,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if delimeter < 0:",
      "mutated_line": "if delimeter <= 0:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter <= 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if delimeter < 0:",
      "mutated_line": "if delimeter >= 0:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter >= 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if delimeter < 0:",
      "mutated_line": "if delimeter != 0:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter != 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if delimeter < 0:",
      "mutated_line": "if delimeter < 1:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 1:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if delimeter < 0:",
      "mutated_line": "if delimeter < -1:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < -1:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if delimeter < 0:",
      "mutated_line": "if delimeter < 1:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 1:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 1 or i + 1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 or i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i == len(numbers) - 1 and i + 1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i == len(numbers) - 1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 1 and i + 1 == excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 1 == excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) + 1 and i + 1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) + 1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) * 1 and i + 1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) * 1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 1 and i - 1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i - 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 1 and i * 1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i * 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 2 and i + 1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 2 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 0 and i + 1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 0 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 0 and i + 1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 0 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - -1 and i + 1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - -1 and i + 1 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 1 and i + 2 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 2 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 1 and i + 0 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 0 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 1 and i + 0 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + 0 != excluded_index:\n            result.append(delimeter)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i != len(numbers) - 1 and i+1 != excluded_index:  # Do not append delimiter after the last number and at the excluded index",
      "mutated_line": "if i != len(numbers) - 1 and i + -1 != excluded_index:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" This function is capable of interlaying the 'delimeter' between consecutive elements encountered within the list `numbers`, and manages situations where the delimeter comes with a negative sign.\n    \"\"\"\n    if delimeter < 0:\n        excluded_index = abs(delimeter)\n    else:\n        excluded_index = None\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1 and i + -1 != excluded_index:\n            result.append(delimeter)\n    return result"
    }
  ]
}