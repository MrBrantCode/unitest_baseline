{
  "task_id": "cf_46780",
  "entry_point": "is_nested_and_balanced",
  "mutant_count": 14,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return stack == []",
      "mutated_line": "return stack != []",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack != []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'(': ')',",
      "mutated_line": "openers_to_closers = {'': ')', '[': ']', '{': '}', '<': '>'}",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'': ')', '[': ']', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'[': ']',",
      "mutated_line": "openers_to_closers = {'(': ')', '': ']', '{': '}', '<': '>'}",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '': ']', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'{': '}',",
      "mutated_line": "openers_to_closers = {'(': ')', '[': ']', '': '}', '<': '>'}",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'<': '>',",
      "mutated_line": "openers_to_closers = {'(': ')', '[': ']', '{': '}', '': '>'}",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '{': '}', '': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'(': ')',",
      "mutated_line": "openers_to_closers = {'(': '', '[': ']', '{': '}', '<': '>'}",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': '', '[': ']', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'[': ']',",
      "mutated_line": "openers_to_closers = {'(': ')', '[': '', '{': '}', '<': '>'}",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': '', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'{': '}',",
      "mutated_line": "openers_to_closers = {'(': ')', '[': ']', '{': '', '<': '>'}",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '{': '', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'<': '>',",
      "mutated_line": "openers_to_closers = {'(': ')', '[': ']', '{': '}', '<': ''}",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '{': '}', '<': ''}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if char in openers_to_closers:",
      "mutated_line": "if char not in openers_to_closers:",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char not in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif char in closers:",
      "mutated_line": "elif char not in closers:",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char not in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return True\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not char == openers_to_closers[last_unclosed_opener]:",
      "mutated_line": "if not char != openers_to_closers[last_unclosed_opener]:",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char != openers_to_closers[last_unclosed_opener]:\n                    return False\n    return stack == []"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_nested_and_balanced(s):\n    stack = []\n    openers_to_closers = {'(': ')', '[': ']', '{': '}', '<': '>'}\n    closers = set(openers_to_closers.values())\n    for char in s:\n        if char in openers_to_closers:\n            stack.append(char)\n        elif char in closers:\n            if not stack:\n                return False\n            else:\n                last_unclosed_opener = stack.pop()\n                if not char == openers_to_closers[last_unclosed_opener]:\n                    return True\n    return stack == []"
    }
  ]
}