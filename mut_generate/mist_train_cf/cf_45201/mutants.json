{
  "task_id": "cf_45201",
  "entry_point": "maze3",
  "mutant_count": 159,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = ''",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = ''\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start + [0, 0])] = 1",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 1\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start + [0, 0])] = -1",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = -1\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start + [0, 0])] = 1",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 1\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]",
      "mutated_line": "portals = [portal1, portal2] if portal1 <= portal2 else [portal2, portal1]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 <= portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]",
      "mutated_line": "portals = [portal1, portal2] if portal1 >= portal2 else [portal2, portal1]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 >= portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]",
      "mutated_line": "portals = [portal1, portal2] if portal1 != portal2 else [portal2, portal1]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 != portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dest_node = tuple(destination + [0, 0])",
      "mutated_line": "distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination - [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dest_node = tuple(destination + [0, 0])",
      "mutated_line": "distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination * [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if (x, y, dx, dy) == dest_node:",
      "mutated_line": "if (x, y, dx, dy) != dest_node:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) != dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "nx -= ndx",
      "mutated_line": "nx += ndx",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx += ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "ny -= ndy",
      "mutated_line": "ny += ndy",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny += ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[2]] = maze[portal2[0]][portal2[1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[2]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[0]] = maze[portal2[0]][portal2[1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[0]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[0]] = maze[portal2[0]][portal2[1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[0]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[-1]] = maze[portal2[0]][portal2[1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[-1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[2]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[2]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[0]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[0]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[0]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[0]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[-1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[-1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for dx, dy in directions}",
      "mutated_line": "distances = {(i, j, dx, dy): float('') for i in range(rows) for j in range(cols) for (dx, dy) in directions}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start - [0, 0])] = 0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start - [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start * [0, 0])] = 0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start * [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(1, tuple(start + [0, 0]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(1, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(-1, tuple(start + [0, 0]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(-1, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(1, tuple(start + [0, 0]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(1, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows or 0 <= ny < cols or maze[nx][ny] in [0, '2']:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows or 0 <= ny < cols or maze[nx][ny] in [0, '2']:\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "nx += ndx",
      "mutated_line": "nx -= ndx",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx -= ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "ny += ndy",
      "mutated_line": "ny -= ndy",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny -= ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "nsteps += 1",
      "mutated_line": "nsteps -= 1",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps -= 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 0 <= ny < cols) and distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) and distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "distances[(nx, ny, ndx, ndy)] = current_dist + nsteps",
      "mutated_line": "distances[nx, ny, ndx, ndy] = current_dist - nsteps",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist - nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "distances[(nx, ny, ndx, ndy)] = current_dist + nsteps",
      "mutated_line": "distances[nx, ny, ndx, ndy] = current_dist * nsteps",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist * nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[1]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[1]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[-1]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[-1]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[1]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[1]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[1]] = maze[portal2[1]][portal2[1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[1]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[1]] = maze[portal2[-1]][portal2[1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[-1]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'",
      "mutated_line": "maze[portal1[0]][portal1[1]] = maze[portal2[1]][portal2[1]] = '2'",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[1]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[1]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[1]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[-1]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[-1]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[1]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[1]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[2]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[2]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[0]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[0]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[0]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[0]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[-1]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[-1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[2]), tuple(portals[1]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[2]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[0]), tuple(portals[1]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[0]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[0]), tuple(portals[1]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[0]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[-1]), tuple(portals[1]): tuple(portals[0])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[-1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[1])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[1])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[-1])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[-1])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}",
      "mutated_line": "portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[1])}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[1])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[1]))",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[-1]))",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[-1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[1]))",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dest_node = tuple(destination + [0, 0])",
      "mutated_line": "distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [1, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dest_node = tuple(destination + [0, 0])",
      "mutated_line": "distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [-1, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dest_node = tuple(destination + [0, 0])",
      "mutated_line": "distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [1, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dest_node = tuple(destination + [0, 0])",
      "mutated_line": "distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 1])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dest_node = tuple(destination + [0, 0])",
      "mutated_line": "distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, -1])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dest_node = tuple(destination + [0, 0])",
      "mutated_line": "distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 1])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(0, tuple(start - [0, 0]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start - [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(0, tuple(start * [0, 0]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start * [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "nx, ny, nsteps = x + ndx, y + ndy, 0",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x - ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "nx, ny, nsteps = x + ndx, y + ndy, 0",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x * ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "nx, ny, nsteps = x + ndx, y + ndy, 0",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y - ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "nx, ny, nsteps = x + ndx, y + ndy, 0",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y * ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "nx, ny, nsteps = x + ndx, y + ndy, 0",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 1)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "nx, ny, nsteps = x + ndx, y + ndy, 0",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, -1)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "nx, ny, nsteps = x + ndx, y + ndy, 0",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 1)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 < nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 < nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 > nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 > nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 == nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 == nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and 0 < ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 < ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and 0 > ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 > ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and 0 == ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 == ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] not in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] not in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if maze[nx][ny] == '2':",
      "mutated_line": "(nx, ny) = portal_dict[nx, ny]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] != '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nsteps += 1",
      "mutated_line": "nsteps += 2",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 2\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nsteps += 1",
      "mutated_line": "nsteps += 0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 0\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nsteps += 1",
      "mutated_line": "nsteps += 0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 0\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nsteps += 1",
      "mutated_line": "nsteps += -1",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += -1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] < current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] < current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] > current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] > current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] == current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] == current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start + [1, 0])] = 0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [1, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start + [-1, 0])] = 0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [-1, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start + [1, 0])] = 0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [1, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start + [0, 1])] = 0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 1])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start + [0, -1])] = 0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, -1])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances[tuple(start + [0, 0])] = 0",
      "mutated_line": "distances[tuple(start + [0, 1])] = 0",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 1])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while -1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while -1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and 1 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 1 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and -1 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and -1 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and 1 <= ny < cols and (maze[nx][ny] in [0, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 1 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if maze[nx][ny] == '2':",
      "mutated_line": "(nx, ny) = portal_dict[nx, ny]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows or 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows or 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist - nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist - nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist * nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist * nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(0, tuple(start + [1, 0]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [1, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(0, tuple(start + [-1, 0]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [-1, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(0, tuple(start + [1, 0]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [1, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(0, tuple(start + [0, 1]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 1]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(0, tuple(start + [0, -1]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, -1]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heap = [(0, tuple(start + [0, 0]))]",
      "mutated_line": "heap = [(0, tuple(start + [0, 1]))]",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 1]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [1, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [1, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [-1, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [-1, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [1, '2']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [1, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] in [0, '2']:",
      "mutated_line": "while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '']):",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 < nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 < nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 > nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 > nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 == nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 == nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 0 < ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 < ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 0 > ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 > ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 0 == ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 0 == ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (1 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (1 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (-1 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (-1 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (1 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (1 <= nx < rows and 0 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 1 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 1 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and -1 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and -1 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if not(0 <= nx < rows and 0 <= ny < cols) or distances[(nx, ny, ndx, ndy)] <= current_dist + nsteps:",
      "mutated_line": "if not (0 <= nx < rows and 1 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:",
      "code": "from collections import deque\nfrom heapq import heappop, heappush\n\ndef maze3(maze, start, destination, portal1, portal2):\n    maze[portal1[0]][portal1[1]] = maze[portal2[0]][portal2[1]] = '2'\n    portals = [portal1, portal2] if portal1 < portal2 else [portal2, portal1]\n    portal_dict = {tuple(portals[0]): tuple(portals[1]), tuple(portals[1]): tuple(portals[0])}\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dest_node = tuple(destination + [0, 0])\n    distances = {(i, j, dx, dy): float('inf') for i in range(rows) for j in range(cols) for (dx, dy) in directions}\n    distances[tuple(start + [0, 0])] = 0\n    heap = [(0, tuple(start + [0, 0]))]\n    while heap:\n        (current_dist, (x, y, dx, dy)) = heappop(heap)\n        if (x, y, dx, dy) == dest_node:\n            return current_dist\n        for (ndx, ndy) in directions:\n            (nx, ny, nsteps) = (x + ndx, y + ndy, 0)\n            while 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] in [0, '2']):\n                if maze[nx][ny] == '2':\n                    (nx, ny) = portal_dict[nx, ny]\n                nx += ndx\n                ny += ndy\n                nsteps += 1\n            nx -= ndx\n            ny -= ndy\n            if not (0 <= nx < rows and 1 <= ny < cols) or distances[nx, ny, ndx, ndy] <= current_dist + nsteps:\n                continue\n            distances[nx, ny, ndx, ndy] = current_dist + nsteps\n            heappush(heap, (distances[nx, ny, ndx, ndy], (nx, ny, ndx, ndy)))\n    return -1"
    }
  ]
}