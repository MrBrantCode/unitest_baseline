{
  "task_id": "cf_69631",
  "entry_point": "get_shortest_path",
  "mutant_count": 180,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def get_shortest_path(start_pos, end_pos, blocked, board_dim=8):",
      "mutated_line": "def get_shortest_path(start_pos, end_pos, blocked, board_dim=9):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=9):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def get_shortest_path(start_pos, end_pos, blocked, board_dim=8):",
      "mutated_line": "def get_shortest_path(start_pos, end_pos, blocked, board_dim=7):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=7):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def get_shortest_path(start_pos, end_pos, blocked, board_dim=8):",
      "mutated_line": "def get_shortest_path(start_pos, end_pos, blocked, board_dim=0):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=0):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def get_shortest_path(start_pos, end_pos, blocked, board_dim=8):",
      "mutated_line": "def get_shortest_path(start_pos, end_pos, blocked, board_dim=1):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=1):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def get_shortest_path(start_pos, end_pos, blocked, board_dim=8):",
      "mutated_line": "def get_shortest_path(start_pos, end_pos, blocked, board_dim=-8):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=-8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited[sx][sy] = True",
      "mutated_line": "visited[sx][sy] = False",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = False\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[sx][sy] = 0",
      "mutated_line": "dist[sx][sy] = 1",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 1\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[sx][sy] = 0",
      "mutated_line": "dist[sx][sy] = -1",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = -1\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[sx][sy] = 0",
      "mutated_line": "dist[sx][sy] = 1",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 1\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "shortest_path_count[sx][sy] = 1",
      "mutated_line": "shortest_path_count[sx][sy] = 2",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 2\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "shortest_path_count[sx][sy] = 1",
      "mutated_line": "shortest_path_count[sx][sy] = 0",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 0\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "shortest_path_count[sx][sy] = 1",
      "mutated_line": "shortest_path_count[sx][sy] = 0",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 0\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "shortest_path_count[sx][sy] = 1",
      "mutated_line": "shortest_path_count[sx][sy] = -1",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = -1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [3, 2, -2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [3, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [1, 2, -2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [1, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [0, 2, -2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [0, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [1, 2, -2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [1, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [-2, 2, -2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [-2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 3, -2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 3, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 1, -2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 1, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 0, -2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 0, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 1, -2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 1, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, -2, -2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, -2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, +2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, +2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, +2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, +2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 2, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 2, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 0, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 0, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 0, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 0, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, -1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, -1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 2, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 2, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 0, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 0, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 0, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 0, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, -1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, -1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 1, +1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, +1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 1, -1, +1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, +1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [2, -1, 1, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [2, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [0, -1, 1, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [0, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [0, -1, 1, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [0, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [-1, -1, 1, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [-1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, +1, 1, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, +1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 2, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 2, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 0, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 0, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 0, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 0, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, -1, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, -1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, +1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, +1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 3, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 3, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 1, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 1, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 0, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 0, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 1, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 1, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, -2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, -2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, +2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, +2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, 3, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 3, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, 1, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 1, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, 0, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 0, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, 1, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 1, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, -2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, -2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, 2, +2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, +2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[block[0]][block[1]] = True",
      "mutated_line": "visited[block[0]][block[1]] = False",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = False\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if x == tx and y == ty:",
      "mutated_line": "if x == tx or y == ty:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx or y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "return -1, 0",
      "mutated_line": "return (+1, 0)",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (+1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1, 0",
      "mutated_line": "return (-1, 1)",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1, 0",
      "mutated_line": "return (-1, -1)",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1, 0",
      "mutated_line": "return (-1, 1)",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -3, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -3, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -1, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -1, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -0, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -0, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -1, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -1, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, --2, -2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, --2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -3, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -3, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -1, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -1, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -0, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -0, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -1, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -1, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, --2, 1, 1, -1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, --2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 1, -2, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -2, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 1, -0, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -0, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 1, -0, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -0, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 1, --1, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, --1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 1, -1, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -2]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 1, -1, -0]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -0]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 1, -1, -0]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -0]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dx = [2, 2, -2, -2, 1, 1, -1, -1]",
      "mutated_line": "dx = [2, 2, -2, -2, 1, 1, -1, --1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, --1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -2, 1, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -2, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -0, 1, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -0, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -0, 1, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -0, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, --1, 1, -1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, --1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -2, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -2, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -0, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -0, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -0, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -0, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, --1, 2, -2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, --1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -3, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -3, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -1, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -1, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -0, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -0, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -1, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -1, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, --2, 2, -2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, --2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, 2, -3]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -3]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, 2, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -1]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, 2, -0]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -0]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, 2, -1]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -1]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dy = [1, -1, 1, -1, 2, -2, 2, -2]",
      "mutated_line": "dy = [1, -1, 1, -1, 2, -2, 2, --2]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, --2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]",
      "mutated_line": "visited = [[True for _ in range(board_dim)] for __ in range(board_dim)]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[True for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]",
      "mutated_line": "shortest_path_count = [[1 for _ in range(board_dim)] for __ in range(board_dim)]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[1 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]",
      "mutated_line": "shortest_path_count = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]",
      "mutated_line": "shortest_path_count = [[1 for _ in range(board_dim)] for __ in range(board_dim)]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[1 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]",
      "mutated_line": "dist = [[+1 for _ in range(board_dim)] for __ in range(board_dim)]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[+1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[1], start_pos[1], end_pos[0], end_pos[1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[1], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[-1], start_pos[1], end_pos[0], end_pos[1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[-1], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[1], start_pos[1], end_pos[0], end_pos[1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[1], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[2], end_pos[0], end_pos[1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[2], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[0], end_pos[0], end_pos[1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[0], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[0], end_pos[0], end_pos[1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[0], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[-1], end_pos[0], end_pos[1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[-1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[1], end_pos[1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[1], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[-1], end_pos[1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[-1], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[1], end_pos[1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[1], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[2])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[2])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[0])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[0])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[0])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[0])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sx, sy, tx, ty = start_pos[0], start_pos[1], end_pos[0], end_pos[1]",
      "mutated_line": "(sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[-1])",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[-1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if x == tx and y == ty:",
      "mutated_line": "if x != tx and y == ty:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x != tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if x == tx and y == ty:",
      "mutated_line": "if x == tx and y != ty:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y != ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(9):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(9):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(7):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(7):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(0):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(0):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(1):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(1):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(-8):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(-8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "nx = x + dx[i]",
      "mutated_line": "nx = x - dx[i]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x - dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "nx = x + dx[i]",
      "mutated_line": "nx = x * dx[i]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x * dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ny = y + dy[i]",
      "mutated_line": "ny = y - dy[i]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y - dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ny = y + dy[i]",
      "mutated_line": "ny = y * dy[i]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y * dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < board_dim or 0 <= ny < board_dim or (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim or 0 <= ny < board_dim or (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1, 0",
      "mutated_line": "return (-2, 0)",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-2, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1, 0",
      "mutated_line": "return (-0, 0)",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1, 0",
      "mutated_line": "return (-0, 0)",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1, 0",
      "mutated_line": "return (--1, 0)",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (--1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]",
      "mutated_line": "dist = [[-2 for _ in range(board_dim)] for __ in range(board_dim)]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-2 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]",
      "mutated_line": "dist = [[-0 for _ in range(board_dim)] for __ in range(board_dim)]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-0 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]",
      "mutated_line": "dist = [[-0 for _ in range(board_dim)] for __ in range(board_dim)]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-0 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]",
      "mutated_line": "dist = [[--1 for _ in range(board_dim)] for __ in range(board_dim)]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[--1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[block[0]][block[1]] = True",
      "mutated_line": "visited[block[0]][block[2]] = True",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[2]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[block[0]][block[1]] = True",
      "mutated_line": "visited[block[0]][block[0]] = True",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[0]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[block[0]][block[1]] = True",
      "mutated_line": "visited[block[0]][block[0]] = True",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[0]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[block[0]][block[1]] = True",
      "mutated_line": "visited[block[0]][block[-1]] = True",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[-1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 0 < nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 < nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 0 > nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 > nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 0 == nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 == nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < board_dim and 0 < ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 < ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < board_dim and 0 > ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 > ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < board_dim and 0 == ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 == ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -1 and dist[nx][ny] == dist[x][y] + 1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 and dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "shortest_path_count[nx][ny] += shortest_path_count[x][y]",
      "mutated_line": "shortest_path_count[nx][ny] -= shortest_path_count[x][y]",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] -= shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[block[0]][block[1]] = True",
      "mutated_line": "visited[block[1]][block[1]] = True",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[1]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[block[0]][block[1]] = True",
      "mutated_line": "visited[block[-1]][block[1]] = True",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[-1]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[block[0]][block[1]] = True",
      "mutated_line": "visited[block[1]][block[1]] = True",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[1]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 1 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 1 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if -1 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if -1 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 1 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 1 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < board_dim and 1 <= ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 1 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < board_dim and -1 <= ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and -1 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= nx < board_dim and 0 <= ny < board_dim and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < board_dim and 1 <= ny < board_dim and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 1 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] != -1 or dist[nx][ny] == dist[x][y] + 1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] != -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -1 or dist[nx][ny] != dist[x][y] + 1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] != dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "visited[nx][ny] = True",
      "mutated_line": "visited[nx][ny] = False",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = False\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] - 1",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] - 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] * 1",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] * 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == +1 or dist[nx][ny] == dist[x][y] + 1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == +1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] - 1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] - 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] * 1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] * 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 2",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 2\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 0",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 0\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 0",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 0\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + -1",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + -1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -2 or dist[nx][ny] == dist[x][y] + 1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -2 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -0 or dist[nx][ny] == dist[x][y] + 1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -0 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -0 or dist[nx][ny] == dist[x][y] + 1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -0 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == --1 or dist[nx][ny] == dist[x][y] + 1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == --1 or dist[nx][ny] == dist[x][y] + 1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 2:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 2:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 0:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 0:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 0:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 0:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + 1:",
      "mutated_line": "if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + -1:",
      "code": "from collections import deque\n\ndef get_shortest_path(start_pos, end_pos, blocked, board_dim=8):\n    \"\"\"\n    This function calculates the minimum number of steps for a knight to reach the end position from the start position\n    and the total number of such shortest paths on a chessboard of variable size.\n\n    Args:\n    start_pos (tuple): The start position of the knight.\n    end_pos (tuple): The end position of the knight.\n    blocked (list): A list of blocked positions on the chessboard.\n    board_dim (int): The size of the chessboard. Default is 8.\n\n    Returns:\n    tuple: A tuple containing the minimum number of steps and the total number of such shortest paths.\n    \"\"\"\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n    queue = deque()\n    visited = [[False for _ in range(board_dim)] for __ in range(board_dim)]\n    shortest_path_count = [[0 for _ in range(board_dim)] for __ in range(board_dim)]\n    dist = [[-1 for _ in range(board_dim)] for __ in range(board_dim)]\n    for block in blocked:\n        visited[block[0]][block[1]] = True\n    (sx, sy, tx, ty) = (start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    visited[sx][sy] = True\n    dist[sx][sy] = 0\n    shortest_path_count[sx][sy] = 1\n    queue.append((sx, sy))\n    while queue:\n        (x, y) = queue.popleft()\n        if x == tx and y == ty:\n            return (dist[tx][ty], shortest_path_count[tx][ty])\n        for i in range(8):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < board_dim and 0 <= ny < board_dim and (not visited[nx][ny]):\n                if dist[nx][ny] == -1 or dist[nx][ny] == dist[x][y] + -1:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n                    dist[nx][ny] = dist[x][y] + 1\n                    shortest_path_count[nx][ny] += shortest_path_count[x][y]\n    return (-1, 0)"
    }
  ]
}