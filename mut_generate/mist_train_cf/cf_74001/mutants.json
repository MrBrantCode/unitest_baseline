{
  "task_id": "cf_74001",
  "entry_point": "dijkstra_algorithm",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distances[start] = 0  # The distance to the start node is 0",
      "mutated_line": "distances[start] = 1",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 1\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distances[start] = 0  # The distance to the start node is 0",
      "mutated_line": "distances[start] = -1",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = -1\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distances[start] = 0  # The distance to the start node is 0",
      "mutated_line": "distances[start] = 1",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 1\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if current_distance > distances[current_vertex]:",
      "mutated_line": "if current_distance >= distances[current_vertex]:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance >= distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if current_distance > distances[current_vertex]:",
      "mutated_line": "if current_distance <= distances[current_vertex]:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance <= distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if current_distance > distances[current_vertex]:",
      "mutated_line": "if current_distance != distances[current_vertex]:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance != distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pq = [(0, start)]  # The priority is the distance",
      "mutated_line": "pq = [(1, start)]",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(1, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pq = [(0, start)]  # The priority is the distance",
      "mutated_line": "pq = [(-1, start)]",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(-1, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pq = [(0, start)]  # The priority is the distance",
      "mutated_line": "pq = [(1, start)]",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(1, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight >= 0:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight >= 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight <= 0:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight <= 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight != 0:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight != 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight > 1:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 1:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight > -1:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > -1:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight > 1:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 1:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "distance = current_distance + weight",
      "mutated_line": "distance = current_distance - weight",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance - weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "distance = current_distance + weight",
      "mutated_line": "distance = current_distance * weight",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance * weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance <= distances[neighbor]:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance <= distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance >= distances[neighbor]:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance >= distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance != distances[neighbor]:",
      "code": "import sys\nimport heapq\n\ndef dijkstra_algorithm(graph, start):\n    \"\"\"\n    This function calculates the shortest path in a graph with non-negative edge weights.\n    \n    Args:\n        graph (list of lists): A 2D list representing the adjacency matrix of the graph.\n        start (int): The starting vertex.\n        \n    Returns:\n        dict: A dictionary with the shortest distances from the starting vertex to all other vertices.\n    \"\"\"\n    distances = {i: sys.maxsize for i in range(len(graph))}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_distance, current_vertex) = heapq.heappop(pq)\n        if current_distance > distances[current_vertex]:\n            continue\n        for (neighbor, weight) in enumerate(graph[current_vertex]):\n            if weight > 0:\n                distance = current_distance + weight\n                if distance != distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    return distances"
    }
  ]
}