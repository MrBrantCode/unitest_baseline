{
  "task_id": "cf_52403",
  "entry_point": "timsort",
  "mutant_count": 167,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "min_run = 32",
      "mutated_line": "min_run = 33",
      "code": "def timsort(arr):\n    min_run = 33\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "min_run = 32",
      "mutated_line": "min_run = 31",
      "code": "def timsort(arr):\n    min_run = 31\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "min_run = 32",
      "mutated_line": "min_run = 0",
      "code": "def timsort(arr):\n    min_run = 0\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "min_run = 32",
      "mutated_line": "min_run = 1",
      "code": "def timsort(arr):\n    min_run = 1\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "min_run = 32",
      "mutated_line": "min_run = -32",
      "code": "def timsort(arr):\n    min_run = -32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while size < n:",
      "mutated_line": "while size <= n:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size <= n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while size < n:",
      "mutated_line": "while size >= n:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size >= n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while size < n:",
      "mutated_line": "while size != n:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size != n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "size *= 2",
      "mutated_line": "size /= 2",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size /= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if right is None:",
      "mutated_line": "if right is not None:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is not None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "left_index = 0",
      "mutated_line": "left_index = 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 1\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "left_index = 0",
      "mutated_line": "left_index = -1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = -1\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "left_index = 0",
      "mutated_line": "left_index = 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 1\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "right_index = 0",
      "mutated_line": "right_index = 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 1\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "right_index = 0",
      "mutated_line": "right_index = -1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = -1\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "right_index = 0",
      "mutated_line": "right_index = 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 1\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "while left_index < len(left) and right_index < len(right):",
      "mutated_line": "while left_index < len(left) or right_index < len(right):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) or right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(0, n, min_run):",
      "mutated_line": "insertion_sort(i, min(i + min_run - 1, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(1, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(0, n, min_run):",
      "mutated_line": "insertion_sort(i, min(i + min_run - 1, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(-1, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(0, n, min_run):",
      "mutated_line": "insertion_sort(i, min(i + min_run - 1, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(1, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "size *= 2",
      "mutated_line": "size *= 3",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 3\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "size *= 2",
      "mutated_line": "size *= 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 1\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "size *= 2",
      "mutated_line": "size *= 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 0\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "size *= 2",
      "mutated_line": "size *= 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 1\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "size *= 2",
      "mutated_line": "size *= -2",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= -2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "right = len(arr) - 1",
      "mutated_line": "right = len(arr) + 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) + 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "right = len(arr) - 1",
      "mutated_line": "right = len(arr) * 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) * 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left - 1, right + 1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left - 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left * 1, right + 1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left * 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left + 1, right - 1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right - 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left + 1, right * 1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right * 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "j = i - 1",
      "mutated_line": "j = i + 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i + 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "j = i - 1",
      "mutated_line": "j = i * 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i * 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "while j >= left and arr[j] > key_item:",
      "mutated_line": "while j >= left or arr[j] > key_item:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left or arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j += 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while left_index < len(left) and right_index < len(right):",
      "mutated_line": "while left_index <= len(left) and right_index < len(right):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index <= len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while left_index < len(left) and right_index < len(right):",
      "mutated_line": "while left_index >= len(left) and right_index < len(right):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index >= len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while left_index < len(left) and right_index < len(right):",
      "mutated_line": "while left_index != len(left) and right_index < len(right):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index != len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while left_index < len(left) and right_index < len(right):",
      "mutated_line": "while left_index < len(left) and right_index <= len(right):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index <= len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while left_index < len(left) and right_index < len(right):",
      "mutated_line": "while left_index < len(left) and right_index >= len(right):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index >= len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while left_index < len(left) and right_index < len(right):",
      "mutated_line": "while left_index < len(left) and right_index != len(right):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index != len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if left[left_index] <= right[right_index]:",
      "mutated_line": "if left[left_index] < right[right_index]:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] < right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if left[left_index] <= right[right_index]:",
      "mutated_line": "if left[left_index] > right[right_index]:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] > right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if left[left_index] <= right[right_index]:",
      "mutated_line": "if left[left_index] == right[right_index]:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] == right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "left_index += 1",
      "mutated_line": "left_index -= 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index -= 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "right_index += 1",
      "mutated_line": "right_index -= 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index -= 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(1, n, size * 2):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(1, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(-1, n, size * 2):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(-1, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(1, n, size * 2):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(1, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(0, n, size / 2):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size / 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(0, n, size + 2):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size + 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(0, n, size ** 2):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size ** 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "midpoint = start + size - 1",
      "mutated_line": "midpoint = start + size + 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size + 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "midpoint = start + size - 1",
      "mutated_line": "midpoint = (start + size) * 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = (start + size) * 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "right = len(arr) - 1",
      "mutated_line": "right = len(arr) - 2",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 2\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "right = len(arr) - 1",
      "mutated_line": "right = len(arr) - 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 0\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "right = len(arr) - 1",
      "mutated_line": "right = len(arr) - 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 0\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "right = len(arr) - 1",
      "mutated_line": "right = len(arr) - -1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - -1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left + 2, right + 1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 2, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left + 0, right + 1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 0, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left + 0, right + 1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 0, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left + -1, right + 1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + -1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left + 1, right + 2):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 2):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left + 1, right + 0):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 0):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left + 1, right + 0):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 0):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(left + 1, right + 1):",
      "mutated_line": "for i in range(left + 1, right + -1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + -1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j = i - 1",
      "mutated_line": "j = i - 2",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 2\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j = i - 1",
      "mutated_line": "j = i - 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 0\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j = i - 1",
      "mutated_line": "j = i - 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 0\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j = i - 1",
      "mutated_line": "j = i - -1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - -1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while j >= left and arr[j] > key_item:",
      "mutated_line": "while j > left and arr[j] > key_item:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j > left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while j >= left and arr[j] > key_item:",
      "mutated_line": "while j < left and arr[j] > key_item:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j < left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while j >= left and arr[j] > key_item:",
      "mutated_line": "while j == left and arr[j] > key_item:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j == left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while j >= left and arr[j] > key_item:",
      "mutated_line": "while j >= left and arr[j] >= key_item:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] >= key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while j >= left and arr[j] > key_item:",
      "mutated_line": "while j >= left and arr[j] <= key_item:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] <= key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while j >= left and arr[j] > key_item:",
      "mutated_line": "while j >= left and arr[j] != key_item:",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] != key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 2\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 0\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 0\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= -1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "arr[j + 1] = key_item",
      "mutated_line": "arr[j - 1] = key_item",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j - 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "arr[j + 1] = key_item",
      "mutated_line": "arr[j * 1] = key_item",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j * 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left_index += 1",
      "mutated_line": "left_index += 2",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 2\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left_index += 1",
      "mutated_line": "left_index += 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 0\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left_index += 1",
      "mutated_line": "left_index += 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 0\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left_index += 1",
      "mutated_line": "left_index += -1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += -1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right_index += 1",
      "mutated_line": "right_index += 2",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 2\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right_index += 1",
      "mutated_line": "right_index += 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 0\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right_index += 1",
      "mutated_line": "right_index += 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 0\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right_index += 1",
      "mutated_line": "right_index += -1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += -1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run + 1, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run + 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min((i + min_run) * 1, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min((i + min_run) * 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run - 1, n + 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n + 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run - 1, n * 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n * 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(0, n, size * 3):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 3):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(0, n, size * 1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 1):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(0, n, size * 0):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 0):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(0, n, size * 1):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 1):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for start in range(0, n, size * 2):",
      "mutated_line": "for start in range(0, n, size * -2):",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * -2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "midpoint = start + size - 1",
      "mutated_line": "midpoint = start - size - 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start - size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "midpoint = start + size - 1",
      "mutated_line": "midpoint = start * size - 1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start * size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "midpoint = start + size - 1",
      "mutated_line": "midpoint = start + size - 2",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 2\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "midpoint = start + size - 1",
      "mutated_line": "midpoint = start + size - 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 0\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "midpoint = start + size - 1",
      "mutated_line": "midpoint = start + size - 0",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 0\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "midpoint = start + size - 1",
      "mutated_line": "midpoint = start + size - -1",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - -1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 + 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 + 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min((start + size * 2) * 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min((start + size * 2) * 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 - 1, n + 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n + 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 - 1, n * 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n * 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "arr[j + 1] = arr[j]",
      "mutated_line": "arr[j - 1] = arr[j]",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j - 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "arr[j + 1] = arr[j]",
      "mutated_line": "arr[j * 1] = arr[j]",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j * 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "arr[j + 1] = key_item",
      "mutated_line": "arr[j + 2] = key_item",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 2] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "arr[j + 1] = key_item",
      "mutated_line": "arr[j + 0] = key_item",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 0] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "arr[j + 1] = key_item",
      "mutated_line": "arr[j + 0] = key_item",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 0] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "arr[j + 1] = key_item",
      "mutated_line": "arr[j + -1] = key_item",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + -1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i - min_run - 1, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i - min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i * min_run - 1, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i * min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run - 2, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 2, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run - 0, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 0, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run - 0, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 0, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run - -1, n - 1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - -1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run - 1, n - 2))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 2))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run - 1, n - 0))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 0))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run - 1, n - 0))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 0))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "insertion_sort(i, min((i + min_run - 1), n - 1))",
      "mutated_line": "insertion_sort(i, min(i + min_run - 1, n - -1))",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - -1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start - size * 2 - 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start - size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start * (size * 2) - 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start * (size * 2) - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 - 2, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 2, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 - 0, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 0, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 - 0, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 0, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 - -1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - -1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 - 1, n - 2)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 2)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 - 1, n - 0)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 0)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 - 1, n - 0)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 0)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 2 - 1, n - -1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - -1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "arr[start:start + len(merged)] = merged",
      "mutated_line": "arr[start:start - len(merged)] = merged",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start - len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "arr[start:start + len(merged)] = merged",
      "mutated_line": "arr[start:start * len(merged)] = merged",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start * len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "arr[j + 1] = arr[j]",
      "mutated_line": "arr[j + 2] = arr[j]",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 2] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "arr[j + 1] = arr[j]",
      "mutated_line": "arr[j + 0] = arr[j]",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 0] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "arr[j + 1] = arr[j]",
      "mutated_line": "arr[j + 0] = arr[j]",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 0] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "arr[j + 1] = arr[j]",
      "mutated_line": "arr[j + -1] = arr[j]",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + -1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size / 2 - 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size / 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + (size + 2) - 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + (size + 2) - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size ** 2 - 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size ** 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 3 - 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 3 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 1 - 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 1 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 0 - 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 0 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * 1 - 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 1 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "end = min((start + size * 2 - 1), (n-1))",
      "mutated_line": "end = min(start + size * -2 - 1, n - 1)",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * -2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "left=arr[start:midpoint + 1],",
      "mutated_line": "merged = merge(left=arr[start:midpoint - 1], right=arr[midpoint + 1:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint - 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "left=arr[start:midpoint + 1],",
      "mutated_line": "merged = merge(left=arr[start:midpoint * 1], right=arr[midpoint + 1:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint * 1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint - 1:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint - 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint * 1:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint * 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end - 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end - 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end * 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end * 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "left=arr[start:midpoint + 1],",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 2], right=arr[midpoint + 1:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 2], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "left=arr[start:midpoint + 1],",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 0], right=arr[midpoint + 1:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 0], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "left=arr[start:midpoint + 1],",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 0], right=arr[midpoint + 1:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 0], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "left=arr[start:midpoint + 1],",
      "mutated_line": "merged = merge(left=arr[start:midpoint + -1], right=arr[midpoint + 1:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + -1], right=arr[midpoint + 1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 2:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 2:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 0:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 0:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 0:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 0:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + -1:end + 1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + -1:end + 1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 2])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 2])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 0])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 0])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 0])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 0])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "right=arr[midpoint + 1:end + 1])",
      "mutated_line": "merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + -1])",
      "code": "def timsort(arr):\n    min_run = 32\n    n = len(arr)\n\n    def insertion_sort(left, right=None):\n        if right is None:\n            right = len(arr) - 1\n        for i in range(left + 1, right + 1):\n            key_item = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key_item:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key_item\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n    for i in range(0, n, min_run):\n        insertion_sort(i, min(i + min_run - 1, n - 1))\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min(start + size * 2 - 1, n - 1)\n            merged = merge(left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + -1])\n            arr[start:start + len(merged)] = merged\n        size *= 2\n    return arr"
    }
  ]
}