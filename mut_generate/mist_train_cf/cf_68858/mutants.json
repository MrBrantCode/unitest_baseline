{
  "task_id": "cf_68858",
  "entry_point": "quartiles",
  "mutant_count": 185,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 != 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 != 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k < len(left):",
      "mutated_line": "if k <= len(left):",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k <= len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k < len(left):",
      "mutated_line": "if k >= len(left):",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k >= len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k < len(left):",
      "mutated_line": "if k != len(left):",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k != len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n * 2 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n * 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n + 2 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n + 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 2:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 2:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 0:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 0:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == -1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n * 2 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n * 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n + 2 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n + 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 2:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 2:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 0:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 0:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == -1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 / (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 / (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 + (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 + (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 ** (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 ** (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pivot = nums[len(nums) // 2]",
      "mutated_line": "pivot = nums[len(nums) / 2]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) / 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pivot = nums[len(nums) // 2]",
      "mutated_line": "pivot = nums[len(nums) * 2]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) * 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif k < len(left) + len(mid):",
      "mutated_line": "elif k <= len(left) + len(mid):",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k <= len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif k < len(left) + len(mid):",
      "mutated_line": "elif k >= len(left) + len(mid):",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k >= len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif k < len(left) + len(mid):",
      "mutated_line": "elif k != len(left) + len(mid):",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k != len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 3 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 3 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 1 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 0 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 0 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 1 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % -2 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % -2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 / (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 / (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 + (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 + (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 ** (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 ** (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 / (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 / (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 + (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 + (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 ** (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 ** (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 3 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 3 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 1 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 0 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 0 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 1 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % -2 == 1:",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % -2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return findKthLargest(lst, n // 2)",
      "mutated_line": "return findKthLargest(lst, n / 2)",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n / 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return findKthLargest(lst, n // 2)",
      "mutated_line": "return findKthLargest(lst, n * 2)",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n * 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 1.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 1.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return -0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return -0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 1 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 1 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return -0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return -0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) - findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) - findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) * findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) * findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pivot = nums[len(nums) // 2]",
      "mutated_line": "pivot = nums[len(nums) // 3]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 3]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pivot = nums[len(nums) // 2]",
      "mutated_line": "pivot = nums[len(nums) // 1]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 1]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pivot = nums[len(nums) // 2]",
      "mutated_line": "pivot = nums[len(nums) // 0]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 0]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pivot = nums[len(nums) // 2]",
      "mutated_line": "pivot = nums[len(nums) // 1]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 1]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pivot = nums[len(nums) // 2]",
      "mutated_line": "pivot = nums[len(nums) // -2]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // -2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "left = [x for x in nums if x < pivot]",
      "mutated_line": "left = [x for x in nums if x <= pivot]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x <= pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "left = [x for x in nums if x < pivot]",
      "mutated_line": "left = [x for x in nums if x >= pivot]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x >= pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "left = [x for x in nums if x < pivot]",
      "mutated_line": "left = [x for x in nums if x != pivot]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x != pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "mid = [x for x in nums if x == pivot]",
      "mutated_line": "mid = [x for x in nums if x != pivot]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x != pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "right = [x for x in nums if x > pivot]",
      "mutated_line": "right = [x for x in nums if x >= pivot]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x >= pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "right = [x for x in nums if x > pivot]",
      "mutated_line": "right = [x for x in nums if x <= pivot]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x <= pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "right = [x for x in nums if x > pivot]",
      "mutated_line": "right = [x for x in nums if x != pivot]",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x != pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif k < len(left) + len(mid):",
      "mutated_line": "elif k < len(left) - len(mid):",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) - len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif k < len(left) + len(mid):",
      "mutated_line": "elif k < len(left) * len(mid):",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) * len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n / 4), findKthLargest(lst, n * 3 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n / 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n * 4), findKthLargest(lst, n * 3 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n * 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 / 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 / 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 * 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 * 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (1.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (1.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (-0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (-0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (1 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (1 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (-0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (-0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) - findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) - findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) * findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) * findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 1.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 1.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), -0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), -0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 1 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 1 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), -0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), -0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) - findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) - findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) * findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) * findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return findKthLargest(lst, n // 2)",
      "mutated_line": "return findKthLargest(lst, n // 3)",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 3)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return findKthLargest(lst, n // 2)",
      "mutated_line": "return findKthLargest(lst, n // 1)",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 1)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return findKthLargest(lst, n // 2)",
      "mutated_line": "return findKthLargest(lst, n // 0)",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 0)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return findKthLargest(lst, n // 2)",
      "mutated_line": "return findKthLargest(lst, n // 1)",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 1)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return findKthLargest(lst, n // 2)",
      "mutated_line": "return findKthLargest(lst, n // -2)",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // -2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return findKthLargest(right, k - len(left) - len(mid))",
      "mutated_line": "return findKthLargest(right, k - len(left) + len(mid))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) + len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return findKthLargest(right, k - len(left) - len(mid))",
      "mutated_line": "return findKthLargest(right, (k - len(left)) * len(mid))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, (k - len(left)) * len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 5), findKthLargest(lst, n * 3 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 5), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 3), findKthLargest(lst, n * 3 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 3), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 0), findKthLargest(lst, n * 3 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 0), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 1), findKthLargest(lst, n * 3 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 1), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // -4), findKthLargest(lst, n * 3 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // -4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n / 3 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n / 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, (n + 3) // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, (n + 3) // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n ** 3 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n ** 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 5))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 5))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 3))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 3))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 0))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 0))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 1))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 1))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // -4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // -4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 + 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 + 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 * 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 * 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n / 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n / 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n * 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n * 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return findKthLargest(right, k - len(left) - len(mid))",
      "mutated_line": "return findKthLargest(right, k + len(left) - len(mid))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k + len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return findKthLargest(right, k - len(left) - len(mid))",
      "mutated_line": "return findKthLargest(right, k * len(left) - len(mid))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k * len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 4 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 4 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 2 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 2 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 0 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 0 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 1 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 1 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))",
      "mutated_line": "return (findKthLargest(lst, n // 4), findKthLargest(lst, n * -3 // 4))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * -3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 + 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 + 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 * 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 * 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n / 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n / 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n * 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n * 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 + 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 + 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 * 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 * 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 / 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 / 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 * 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 * 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n / 2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n / 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n * 2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n * 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 2) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 2) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 0) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 0) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 0) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 0) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - -1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - -1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 3))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 3))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 1))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 1))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 0))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 0))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 1))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 1))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // -2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // -2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n / 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n / 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n * 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n * 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 2) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 2) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 0) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 0) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 0) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 0) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - -1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - -1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 5)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 5)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 3)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 3)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 0)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 0)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 1)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 1)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // -4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // -4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 / 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 / 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 * 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 * 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 2) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 2) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 0) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 0) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 0) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 0) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - -1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - -1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n / 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n / 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, (n + 3) // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, (n + 3) // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n ** 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n ** 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 5)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 5)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 3)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 3)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 0)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 0)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 1)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // -4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // -4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 3 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 3 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 1 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 1 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 0 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 0 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // 1 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 1 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))",
      "mutated_line": "return 0.5 * (findKthLargest(lst, n // -2 - 1) + findKthLargest(lst, n // 2))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // -2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 5 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 5 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 3 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 3 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 0 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 0 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 1 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 1 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)),",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // -4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // -4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n / 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n / 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, (n + 3) // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, (n + 3) // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n ** 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n ** 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 5 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 5 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 3 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 3 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 0 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 0 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 1 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 1 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // -4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // -4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 4 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 4 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 2 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 2 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 0 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 0 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 1 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 1 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * -3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * -3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 4 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 4 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 2 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 2 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 0 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 0 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 1 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * 1 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "0.5 * (findKthLargest(lst, n * 3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "mutated_line": "return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * -3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))",
      "code": "def quartiles(lst):\n\n    def median(lst):\n        n = len(lst)\n        if n % 2 == 1:\n            return findKthLargest(lst, n // 2)\n        else:\n            return 0.5 * (findKthLargest(lst, n // 2 - 1) + findKthLargest(lst, n // 2))\n\n    def findKthLargest(nums, k):\n        pivot = nums[len(nums) // 2]\n        left = [x for x in nums if x < pivot]\n        mid = [x for x in nums if x == pivot]\n        right = [x for x in nums if x > pivot]\n        if k < len(left):\n            return findKthLargest(left, k)\n        elif k < len(left) + len(mid):\n            return nums[k]\n        else:\n            return findKthLargest(right, k - len(left) - len(mid))\n    n = len(lst)\n    if n % 2 == 1:\n        return (findKthLargest(lst, n // 4), findKthLargest(lst, n * 3 // 4))\n    else:\n        return (0.5 * (findKthLargest(lst, n // 4 - 1) + findKthLargest(lst, n // 4)), 0.5 * (findKthLargest(lst, n * -3 // 4 - 1) + findKthLargest(lst, n * 3 // 4)))"
    }
  ]
}