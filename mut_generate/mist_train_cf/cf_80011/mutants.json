{
  "task_id": "cf_80011",
  "entry_point": "visiblePoints",
  "mutant_count": 65,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "angle_rad = math.pi * angle / 180",
      "mutated_line": "angle_rad = math.pi * angle * 180",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle * 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "angle_rad = math.pi * angle / 180",
      "mutated_line": "angle_rad = math.pi * angle // 180",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle // 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "same_location = 0",
      "mutated_line": "same_location = 1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 1\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "same_location = 0",
      "mutated_line": "same_location = -1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = -1\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "same_location = 0",
      "mutated_line": "same_location = 1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 1\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "max_count = 0",
      "mutated_line": "max_count = 1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 1\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "max_count = 0",
      "mutated_line": "max_count = -1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = -1\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "max_count = 0",
      "mutated_line": "max_count = 1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 1\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 1\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "left = 0",
      "mutated_line": "left = -1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = -1\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 1\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "return max_count + same_location",
      "mutated_line": "return max_count - same_location",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count - same_location"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "return max_count + same_location",
      "mutated_line": "return max_count * same_location",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count * same_location"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "angle_rad = math.pi * angle / 180",
      "mutated_line": "angle_rad = math.pi / angle / 180",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi / angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "angle_rad = math.pi * angle / 180",
      "mutated_line": "angle_rad = (math.pi + angle) / 180",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = (math.pi + angle) / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "angle_rad = math.pi * angle / 180",
      "mutated_line": "angle_rad = math.pi ** angle / 180",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi ** angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "angle_rad = math.pi * angle / 180",
      "mutated_line": "angle_rad = math.pi * angle / 181",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 181\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "angle_rad = math.pi * angle / 180",
      "mutated_line": "angle_rad = math.pi * angle / 179",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 179\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "angle_rad = math.pi * angle / 180",
      "mutated_line": "angle_rad = math.pi * angle / 0",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 0\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "angle_rad = math.pi * angle / 180",
      "mutated_line": "angle_rad = math.pi * angle / 1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 1\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "angle_rad = math.pi * angle / 180",
      "mutated_line": "angle_rad = math.pi * angle / -180",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / -180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if point == location:",
      "mutated_line": "if point != location:",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point != location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "same_location += 1",
      "mutated_line": "same_location -= 1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location -= 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "while angles[right] - angles[left] > angle_rad:",
      "mutated_line": "while angles[right] - angles[left] >= angle_rad:",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] >= angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "while angles[right] - angles[left] > angle_rad:",
      "mutated_line": "while angles[right] - angles[left] <= angle_rad:",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] <= angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "while angles[right] - angles[left] > angle_rad:",
      "mutated_line": "while angles[right] - angles[left] != angle_rad:",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] != angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "left += 1",
      "mutated_line": "left -= 1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left -= 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "same_location += 1",
      "mutated_line": "same_location += 2",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 2\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "same_location += 1",
      "mutated_line": "same_location += 0",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 0\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "same_location += 1",
      "mutated_line": "same_location += 0",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 0\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "same_location += 1",
      "mutated_line": "same_location += -1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += -1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "while angles[right] - angles[left] > angle_rad:",
      "mutated_line": "while angles[right] + angles[left] > angle_rad:",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] + angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "while angles[right] - angles[left] > angle_rad:",
      "mutated_line": "while angles[right] * angles[left] > angle_rad:",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] * angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "left += 1",
      "mutated_line": "left += 2",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 2\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "left += 1",
      "mutated_line": "left += 0",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 0\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "left += 1",
      "mutated_line": "left += 0",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 0\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "left += 1",
      "mutated_line": "left += -1",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += -1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "max_count = max(max_count, right - left + 1)",
      "mutated_line": "max_count = max(max_count, right - left - 1)",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left - 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "max_count = max(max_count, right - left + 1)",
      "mutated_line": "max_count = max(max_count, (right - left) * 1)",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, (right - left) * 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] + location[0], point[1] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] + location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] * location[0], point[1] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] * location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[0], point[1] + location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] + location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[0], point[1] * location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] * location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "angles.append(-angle_point)",
      "mutated_line": "angles.append(+angle_point)",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(+angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "max_count = max(max_count, right - left + 1)",
      "mutated_line": "max_count = max(max_count, right + left + 1)",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right + left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "max_count = max(max_count, right - left + 1)",
      "mutated_line": "max_count = max(max_count, right * left + 1)",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right * left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "max_count = max(max_count, right - left + 1)",
      "mutated_line": "max_count = max(max_count, right - left + 2)",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 2)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "max_count = max(max_count, right - left + 1)",
      "mutated_line": "max_count = max(max_count, right - left + 0)",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 0)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "max_count = max(max_count, right - left + 1)",
      "mutated_line": "max_count = max(max_count, right - left + 0)",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 0)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "max_count = max(max_count, right - left + 1)",
      "mutated_line": "max_count = max(max_count, right - left + -1)",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + -1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[1] - location[0], point[1] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[1] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[-1] - location[0], point[1] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[-1] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[1] - location[0], point[1] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[1] - location[0], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[1], point[1] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[1], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[-1], point[1] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[-1], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[1], point[1] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[1], point[1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[0], point[2] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[2] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[0], point[0] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[0] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[0], point[0] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[0] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[0], point[-1] - location[1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[-1] - location[1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[0], point[1] - location[2])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[2])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[0], point[1] - location[0])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[0])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[0], point[1] - location[0])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[0])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dx, dy = point[0] - location[0], point[1] - location[1]",
      "mutated_line": "(dx, dy) = (point[0] - location[0], point[1] - location[-1])",
      "code": "import math\n\ndef visiblePoints(points, angle, location):\n    \"\"\"\n    This function calculates the minimum number of visible points given an array of points, \n    a viewing angle, and a location.\n\n    Args:\n    points (list): A list of points, where each point is a list of two integers.\n    angle (int): The viewing angle in degrees.\n    location (list): The location as a list of two integers.\n\n    Returns:\n    int: The minimum number of visible points.\n    \"\"\"\n    angle_rad = math.pi * angle / 180\n    angles = []\n    same_location = 0\n    for point in points:\n        if point == location:\n            same_location += 1\n        else:\n            (dx, dy) = (point[0] - location[0], point[1] - location[-1])\n            angle_point = math.atan2(dy, dx)\n            angles.append(-angle_point)\n    if not angles:\n        return same_location\n    angles.sort()\n    max_count = 0\n    left = 0\n    for right in range(len(angles)):\n        while angles[right] - angles[left] > angle_rad:\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count + same_location"
    }
  ]
}