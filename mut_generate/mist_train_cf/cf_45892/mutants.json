{
  "task_id": "cf_45892",
  "entry_point": "minStack",
  "mutant_count": 18,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return \"Stack is empty\"",
      "mutated_line": "return ''",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return ''\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return \"Stack is empty\"",
      "mutated_line": "return ''",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return ''\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return self.data[-1]",
      "mutated_line": "return self.data[+1]",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[+1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return \"Stack is empty\"",
      "mutated_line": "return ''",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return ''\n            return self.mins[-1]"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return self.mins[-1]",
      "mutated_line": "return self.mins[+1]",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[+1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return self.data[-1]",
      "mutated_line": "return self.data[-2]",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-2]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return self.data[-1]",
      "mutated_line": "return self.data[-0]",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-0]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return self.data[-1]",
      "mutated_line": "return self.data[-0]",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-0]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return self.data[-1]",
      "mutated_line": "return self.data[--1]",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[--1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return self.mins[-1]",
      "mutated_line": "return self.mins[-2]",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-2]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return self.mins[-1]",
      "mutated_line": "return self.mins[-0]",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return self.mins[-1]",
      "mutated_line": "return self.mins[-0]",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return self.mins[-1]",
      "mutated_line": "return self.mins[--1]",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[--1]"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "self.mins.append(min(x, self.mins[-1]))",
      "mutated_line": "self.mins.append(min(x, self.mins[+1]))",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[+1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.mins.append(min(x, self.mins[-1]))",
      "mutated_line": "self.mins.append(min(x, self.mins[-2]))",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-2]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.mins.append(min(x, self.mins[-1]))",
      "mutated_line": "self.mins.append(min(x, self.mins[-0]))",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-0]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.mins.append(min(x, self.mins[-1]))",
      "mutated_line": "self.mins.append(min(x, self.mins[-0]))",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[-0]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.mins.append(min(x, self.mins[-1]))",
      "mutated_line": "self.mins.append(min(x, self.mins[--1]))",
      "code": "def minStack(self, ops):\n\n    class MinStack:\n\n        def __init__(self):\n            self.data = []\n            self.mins = []\n\n        def push(self, x):\n            self.data.append(x)\n            if self.mins:\n                self.mins.append(min(x, self.mins[--1]))\n            else:\n                self.mins.append(x)\n\n        def pop(self):\n            if not self.data:\n                return 'Stack is empty'\n            self.mins.pop()\n            return self.data.pop()\n\n        def top(self):\n            if not self.data:\n                return 'Stack is empty'\n            return self.data[-1]\n\n        def getMinimum(self):\n            if not self.mins:\n                return 'Stack is empty'\n            return self.mins[-1]"
    }
  ]
}