{
  "task_id": "cf_2071",
  "entry_point": "breadthFirstSearch",
  "mutant_count": 17,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if target not in previous:",
      "mutated_line": "if target in previous:",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while current is not None:",
      "mutated_line": "while current is None:",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances = {start: 0}",
      "mutated_line": "distances = {start: 1}",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 1}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances = {start: 0}",
      "mutated_line": "distances = {start: -1}",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: -1}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances = {start: 0}",
      "mutated_line": "distances = {start: 1}",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 1}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if current == target:",
      "mutated_line": "if current != target:",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current != target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if neighbor not in visited:",
      "mutated_line": "if neighbor in visited:",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "path.insert(0, current)",
      "mutated_line": "path.insert(1, current)",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(1, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "path.insert(0, current)",
      "mutated_line": "path.insert(-1, current)",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(-1, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "path.insert(0, current)",
      "mutated_line": "path.insert(1, current)",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(1, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "new_distance = distances[current] + weight",
      "mutated_line": "new_distance = distances[current] - weight",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] - weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "new_distance = distances[current] + weight",
      "mutated_line": "new_distance = distances[current] * weight",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] * weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if neighbor not in distances or new_distance < distances[neighbor]:",
      "mutated_line": "if neighbor not in distances and new_distance < distances[neighbor]:",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances and new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if neighbor not in distances or new_distance < distances[neighbor]:",
      "mutated_line": "if neighbor in distances or new_distance < distances[neighbor]:",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if neighbor not in distances or new_distance < distances[neighbor]:",
      "mutated_line": "if neighbor not in distances or new_distance <= distances[neighbor]:",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance <= distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if neighbor not in distances or new_distance < distances[neighbor]:",
      "mutated_line": "if neighbor not in distances or new_distance >= distances[neighbor]:",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance >= distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if neighbor not in distances or new_distance < distances[neighbor]:",
      "mutated_line": "if neighbor not in distances or new_distance != distances[neighbor]:",
      "code": "from collections import deque\n\ndef breadthFirstSearch(graph, start, target):\n    queue = deque([start])\n    visited = set()\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            break\n        visited.add(current)\n        for (neighbor, weight) in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if neighbor not in distances or new_distance != distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    queue.append(neighbor)\n    if target not in previous:\n        return []\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = previous.get(current)\n    return path"
    }
  ]
}