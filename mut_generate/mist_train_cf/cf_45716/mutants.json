{
  "task_id": "cf_45716",
  "entry_point": "bfs",
  "mutant_count": 85,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) != (rows - 1, cols - 1):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) != (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [[False for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "visited = [[True for _ in range(cols)] for _ in range(rows)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[True for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(-1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(-1, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 2), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 2), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, -1), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, -1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (2, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (2, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (-1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (-1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, -1), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, -1), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (-1, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (-1, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, +1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, +1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -1), (+1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (+1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, -1)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows or 0 <= nc < cols or maze[nr][nc] == 1 or (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows or 0 <= nc < cols or maze[nr][nc] == 1 or (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[1]))",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[1]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[-1]))",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[-1]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[1]))",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[1]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, 0)])  # (row, col, steps)",
      "mutated_line": "queue = deque([(1, 0, 0)])",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(1, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, 0)])  # (row, col, steps)",
      "mutated_line": "queue = deque([(-1, 0, 0)])",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(-1, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, 0)])  # (row, col, steps)",
      "mutated_line": "queue = deque([(1, 0, 0)])",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(1, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, 0)])  # (row, col, steps)",
      "mutated_line": "queue = deque([(0, 1, 0)])",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 1, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, 0)])  # (row, col, steps)",
      "mutated_line": "queue = deque([(0, -1, 0)])",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, -1, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, 0)])  # (row, col, steps)",
      "mutated_line": "queue = deque([(0, 1, 0)])",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 1, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, 0)])  # (row, col, steps)",
      "mutated_line": "queue = deque([(0, 0, 1)])",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 1)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, 0)])  # (row, col, steps)",
      "mutated_line": "queue = deque([(0, 0, -1)])",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, -1)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, 0)])  # (row, col, steps)",
      "mutated_line": "queue = deque([(0, 0, 1)])",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 1)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -2), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -2), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, --1), (-1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, --1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -1), (-2, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-2, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up",
      "mutated_line": "moves = [(0, 1), (1, 0), (0, -1), (--1, 0)]",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (--1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows + 1, cols - 1):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows + 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows * 1, cols - 1):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows * 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows - 1, cols + 1):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols + 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows - 1, cols * 1):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols * 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nr, nc = r + dr, c + dc",
      "mutated_line": "if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r - dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nr, nc = r + dr, c + dc",
      "mutated_line": "if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r * dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nr, nc = r + dr, c + dc",
      "mutated_line": "if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c - dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nr, nc = r + dr, c + dc",
      "mutated_line": "if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c * dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 < nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 < nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 > nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 > nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 == nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 == nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and 0 < nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 < nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and 0 > nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 > nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and 0 == nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 == nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] != 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] != 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited[nr][nc] = True",
      "mutated_line": "visited[nr][nc] = False",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = False\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows - 2, cols - 1):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 2, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows - 0, cols - 1):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 0, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows - 0, cols - 1):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 0, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows - -1, cols - 1):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - -1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows - 1, cols - 2):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 2):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows - 1, cols - 0):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 0):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows - 1, cols - 0):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 0):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (rows-1, cols-1):",
      "mutated_line": "if (r, c) == (rows - 1, cols - -1):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - -1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 1 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 1 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if -1 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if -1 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 1 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 1 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and 1 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 1 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and -1 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and -1 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and 1 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 1 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 2) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 2) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 0) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 0) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 0) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 0) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and not visited[nr][nc]:",
      "mutated_line": "if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == -1) and (not visited[nr][nc]):",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == -1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append((nr, nc, steps + 1))",
      "mutated_line": "queue.append((nr, nc, steps - 1))",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps - 1))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append((nr, nc, steps + 1))",
      "mutated_line": "queue.append((nr, nc, steps * 1))",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps * 1))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((nr, nc, steps + 1))",
      "mutated_line": "queue.append((nr, nc, steps + 2))",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 2))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((nr, nc, steps + 1))",
      "mutated_line": "queue.append((nr, nc, steps + 0))",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 0))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((nr, nc, steps + 1))",
      "mutated_line": "queue.append((nr, nc, steps + 0))",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 0))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append((nr, nc, steps + 1))",
      "mutated_line": "queue.append((nr, nc, steps + -1))",
      "code": "from collections import deque\n\ndef bfs(maze):\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        for (dr, dc) in moves:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (maze[nr][nc] == 1) and (not visited[nr][nc]):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + -1))"
    }
  ]
}