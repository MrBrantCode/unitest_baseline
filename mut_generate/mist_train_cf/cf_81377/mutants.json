{
  "task_id": "cf_81377",
  "entry_point": "price_american_option",
  "mutant_count": 185,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def price_american_option(S, K, T, r, sigma, n=100, option_type='call'):",
      "mutated_line": "def price_american_option(S, K, T, r, sigma, n=101, option_type='call'):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=101, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def price_american_option(S, K, T, r, sigma, n=100, option_type='call'):",
      "mutated_line": "def price_american_option(S, K, T, r, sigma, n=99, option_type='call'):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=99, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def price_american_option(S, K, T, r, sigma, n=100, option_type='call'):",
      "mutated_line": "def price_american_option(S, K, T, r, sigma, n=0, option_type='call'):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=0, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def price_american_option(S, K, T, r, sigma, n=100, option_type='call'):",
      "mutated_line": "def price_american_option(S, K, T, r, sigma, n=1, option_type='call'):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=1, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def price_american_option(S, K, T, r, sigma, n=100, option_type='call'):",
      "mutated_line": "def price_american_option(S, K, T, r, sigma, n=-100, option_type='call'):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=-100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def price_american_option(S, K, T, r, sigma, n=100, option_type='call'):",
      "mutated_line": "def price_american_option(S, K, T, r, sigma, n=100, option_type=''):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type=''):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dt = T / n",
      "mutated_line": "dt = T * n",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T * n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dt = T / n",
      "mutated_line": "dt = T // n",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T // n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "d = 1 / u",
      "mutated_line": "d = 1 * u",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 * u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "d = 1 / u",
      "mutated_line": "d = 1 // u",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 // u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "p = (np.exp(r * dt) - d) / (u - d)",
      "mutated_line": "p = (np.exp(r * dt) - d) * (u - d)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) * (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "p = (np.exp(r * dt) - d) / (u - d)",
      "mutated_line": "p = (np.exp(r * dt) - d) // (u - d)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) // (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "u = np.exp(sigma * np.sqrt(dt))",
      "mutated_line": "u = np.exp(sigma / np.sqrt(dt))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma / np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "u = np.exp(sigma * np.sqrt(dt))",
      "mutated_line": "u = np.exp(sigma + np.sqrt(dt))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma + np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "u = np.exp(sigma * np.sqrt(dt))",
      "mutated_line": "u = np.exp(sigma ** np.sqrt(dt))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma ** np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d = 1 / u",
      "mutated_line": "d = 2 / u",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 2 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d = 1 / u",
      "mutated_line": "d = 0 / u",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 0 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d = 1 / u",
      "mutated_line": "d = 0 / u",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 0 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d = 1 / u",
      "mutated_line": "d = -1 / u",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = -1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "p = (np.exp(r * dt) - d) / (u - d)",
      "mutated_line": "p = (np.exp(r * dt) + d) / (u - d)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) + d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "p = (np.exp(r * dt) - d) / (u - d)",
      "mutated_line": "p = np.exp(r * dt) * d / (u - d)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = np.exp(r * dt) * d / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "p = (np.exp(r * dt) - d) / (u - d)",
      "mutated_line": "p = (np.exp(r * dt) - d) / (u + d)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u + d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "p = (np.exp(r * dt) - d) / (u - d)",
      "mutated_line": "p = (np.exp(r * dt) - d) / (u * d)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u * d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n - 1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n - 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n * 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if option_type == 'call':",
      "mutated_line": "if option_type != 'call':",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type != 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n + 1, -1, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n + 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n * 1, -1, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n * 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, +1, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, +1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, +1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, +1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n - 1, n + 1))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n - 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n * 1, n + 1))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n * 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n + 1, n - 1))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n - 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n + 1, n * 1))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n * 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 2):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 2):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 0):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 0):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + -1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if option_type == 'call':",
      "mutated_line": "if option_type == '':",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == '':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "elif option_type == 'put':",
      "mutated_line": "elif option_type != 'put':",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type != 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 2, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 0, -1, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 0, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 0, -1, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 0, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - -1, -1, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - -1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -2, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -2, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -0, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -0, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -0, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -0, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, --1, -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, --1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, -2):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -2):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, -0):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -0):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, -0):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -0):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, --1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, --1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in range(j + 1):",
      "mutated_line": "for i in range(j - 1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j - 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in range(j + 1):",
      "mutated_line": "for i in range(j * 1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j * 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return lattice[0, 0]",
      "mutated_line": "return lattice[1, 0]",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[1, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return lattice[0, 0]",
      "mutated_line": "return lattice[-1, 0]",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[-1, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return lattice[0, 0]",
      "mutated_line": "return lattice[1, 0]",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[1, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return lattice[0, 0]",
      "mutated_line": "return lattice[0, 1]",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return lattice[0, 0]",
      "mutated_line": "return lattice[0, -1]",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, -1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return lattice[0, 0]",
      "mutated_line": "return lattice[0, 1]",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "p = (np.exp(r * dt) - d) / (u - d)",
      "mutated_line": "p = (np.exp(r / dt) - d) / (u - d)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r / dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "p = (np.exp(r * dt) - d) / (u - d)",
      "mutated_line": "p = (np.exp(r + dt) - d) / (u - d)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r + dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "p = (np.exp(r * dt) - d) / (u - d)",
      "mutated_line": "p = (np.exp(r ** dt) - d) / (u - d)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r ** dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n + 2, n + 1))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 2, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n + 0, n + 1))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 0, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n + 0, n + 1))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 0, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n + -1, n + 1))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + -1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n + 1, n + 2))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 2))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n + 1, n + 0))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 0))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n + 1, n + 0))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 0))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lattice = np.zeros((n + 1, n + 1))",
      "mutated_line": "lattice = np.zeros((n + 1, n + -1))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + -1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(1, S * u ** (n - i) * d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(1, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(-1, S * u ** (n - i) * d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(-1, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(1, S * u ** (n - i) * d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(1, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S * u ** (n - i) * d ** i + K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i + K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S * u ** (n - i) * d ** i * K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i * K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif option_type == 'put':",
      "mutated_line": "elif option_type == '':",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == '':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(j + 1):",
      "mutated_line": "for i in range(j + 2):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 2):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(j + 1):",
      "mutated_line": "for i in range(j + 0):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 0):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(j + 1):",
      "mutated_line": "for i in range(j + 0):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 0):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(j + 1):",
      "mutated_line": "for i in range(j + -1):",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + -1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max((option_type == 'call' and S * u ** (j - i) * d ** i - K) and (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max((option_type == 'call' and S * u ** (j - i) * d ** i - K) and (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) / (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) / (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) + (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) + (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) ** (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) ** (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S * u ** (n - i) / d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) / d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S * u ** (n - i) + d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) + d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, (S * u ** (n - i)) ** d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, (S * u ** (n - i)) ** d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(1, K - S * u ** (n - i) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(1, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(-1, K - S * u ** (n - i) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(-1, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(1, K - S * u ** (n - i) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(1, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K + S * u ** (n - i) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K + S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K * (S * u ** (n - i) * d ** i))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K * (S * u ** (n - i) * d ** i))\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max((option_type == 'call' or S * u ** (j - i) * d ** i - K) or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max((option_type == 'call' or S * u ** (j - i) * d ** i - K) or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "LCR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' or K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' or K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] - (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] - (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] * ((1 - p) * lattice[i + 1, j + 1])))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] * ((1 - p) * lattice[i + 1, j + 1])))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S / u ** (n - i) * d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S / u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, (S + u ** (n - i)) * d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, (S + u ** (n - i)) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S ** u ** (n - i) * d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S ** u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S * u ** (n - i) * (d * i) - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * (d * i) - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S * u ** (n - i) * (d + i) - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * (d + i) - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - S * u ** (n - i) / d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) / d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - (S * u ** (n - i) + d ** i))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - (S * u ** (n - i) + d ** i))\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - (S * u ** (n - i)) ** d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - (S * u ** (n - i)) ** d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type != 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type != 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i + K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i + K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i * K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i * K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type != 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type != 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K + S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K + S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K * (S * u ** (j - i) * d ** i)), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K * (S * u ** (j - i) * d ** i)), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r / dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r / dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r + dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r + dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp((-r) ** dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp((-r) ** dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p / lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p / lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p + lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p + lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p ** lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p ** lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) / lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) / lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p + lattice[i + 1, j + 1])))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p + lattice[i + 1, j + 1])))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) ** lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) ** lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S * (u * (n - i)) * d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * (u * (n - i)) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S * (u + (n - i)) * d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * (u + (n - i)) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - S / u ** (n - i) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S / u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - (S + u ** (n - i)) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - (S + u ** (n - i)) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - S ** u ** (n - i) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S ** u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - S * u ** (n - i) * (d * i))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * (d * i))\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - S * u ** (n - i) * (d + i))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * (d + i))\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == '' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == '' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) / d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) / d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) + d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) + d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and (S * u ** (j - i)) ** d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and (S * u ** (j - i)) ** d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == '' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == '' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) / d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) / d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - (S * u ** (j - i) + d ** i)), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - (S * u ** (j - i) + d ** i)), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - (S * u ** (j - i)) ** d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - (S * u ** (j - i)) ** d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(+r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(+r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 + p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 + p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + 1 * p * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + 1 * p * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S * u ** (n + i) * d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n + i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "lattice[i, n] = max(0, S * (u ** (n - i)) * (d ** i) - K)",
      "mutated_line": "lattice[i, n] = max(0, S * u ** (n * i) * d ** i - K)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n * i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - S * (u * (n - i)) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * (u * (n - i)) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - S * (u + (n - i)) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * (u + (n - i)) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S / u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S / u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and (S + u ** (j - i)) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and (S + u ** (j - i)) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S ** u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S ** u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * (d * i) - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * (d * i) - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * (d + i) - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * (d + i) - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S / u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S / u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - (S + u ** (j - i)) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - (S + u ** (j - i)) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S ** u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S ** u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * (d * i)), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * (d * i)), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * (d + i)), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * (d + i)), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (2 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (2 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (0 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (0 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (0 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (0 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (-1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (-1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - S * u ** (n + i) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n + i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "lattice[i, n] = max(0, K - S * (u ** (n - i)) * (d ** i))",
      "mutated_line": "lattice[i, n] = max(0, K - S * u ** (n * i) * d ** i)",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n * i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * (u * (j - i)) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * (u * (j - i)) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * (u + (j - i)) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * (u + (j - i)) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * (u * (j - i)) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * (u * (j - i)) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * (u + (j - i)) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * (u + (j - i)) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j - 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j - 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j * 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j * 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i - 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i - 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i * 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i * 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j - 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j - 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j * 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j * 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j + i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j + i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "(option_type == 'call' and (S * (u ** (j - i)) * (d ** i) - K)) or",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j * i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j * i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j + i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j + i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(option_type == 'put' and (K - S * (u ** (j - i)) * (d ** i))),",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j * i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j * i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 2] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 2] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 0] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 0] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 0] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 0] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + -1] + (1 - p) * lattice[i + 1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + -1] + (1 - p) * lattice[i + 1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 2, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 2, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 0, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 0, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 0, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 0, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + -1, j + 1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + -1, j + 1]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 2]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 2]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 0]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 0]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 0]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 0]))\n    return lattice[0, 0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + 1])",
      "mutated_line": "lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + -1]))",
      "code": "import numpy as np\n\ndef price_american_option(S, K, T, r, sigma, n=100, option_type='call'):\n    \"\"\"\n    Calculate the theoretical price of an American option using a binomial lattice model.\n\n    Parameters:\n    S (float): Underlying asset price\n    K (float): Strike price\n    T (float): Time to expiration in years\n    r (float): Risk-free interest rate\n    sigma (float): Volatility\n    n (int): Number of steps in the binomial lattice\n    option_type (str): Type of option ('call' or 'put')\n\n    Returns:\n    float: Theoretical price of the American option\n    \"\"\"\n    dt = T / n\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    lattice = np.zeros((n + 1, n + 1))\n    for i in range(n + 1):\n        if option_type == 'call':\n            lattice[i, n] = max(0, S * u ** (n - i) * d ** i - K)\n        elif option_type == 'put':\n            lattice[i, n] = max(0, K - S * u ** (n - i) * d ** i)\n    for j in range(n - 1, -1, -1):\n        for i in range(j + 1):\n            lattice[i, j] = max(option_type == 'call' and S * u ** (j - i) * d ** i - K or (option_type == 'put' and K - S * u ** (j - i) * d ** i), np.exp(-r * dt) * (p * lattice[i, j + 1] + (1 - p) * lattice[i + 1, j + -1]))\n    return lattice[0, 0]"
    }
  ]
}