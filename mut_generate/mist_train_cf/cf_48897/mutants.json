{
  "task_id": "cf_48897",
  "entry_point": "lexicographical_distance",
  "mutant_count": 16,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 1\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 1\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 1\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = -1\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 1\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 1\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 1\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if(len_str1 != len_str2):",
      "mutated_line": "count += abs(len_str1 - len_str2)",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 1\n    if len_str1 == len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "count += abs(len_str1-len_str2)",
      "mutated_line": "count -= abs(len_str1 - len_str2)",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 1\n    if len_str1 != len_str2:\n        count -= abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "string1 = unicodedata.normalize('NFC', string1)",
      "mutated_line": "string1 = unicodedata.normalize('', string1)",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 1\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "string2 = unicodedata.normalize('NFC', string2)",
      "mutated_line": "string2 = unicodedata.normalize('', string2)",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 1\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if(string1[i] != string2[i]):",
      "mutated_line": "if string1[i] == string2[i]:",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] == string2[i]:\n            count += 1\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count -= 1\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 2\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 0\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 0\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += -1\n    if len_str1 != len_str2:\n        count += abs(len_str1 - len_str2)\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "count += abs(len_str1-len_str2)",
      "mutated_line": "count += abs(len_str1 + len_str2)",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 1\n    if len_str1 != len_str2:\n        count += abs(len_str1 + len_str2)\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "count += abs(len_str1-len_str2)",
      "mutated_line": "count += abs(len_str1 * len_str2)",
      "code": "import unicodedata\n\ndef lexicographical_distance(string1, string2):\n    \"\"\"\n    Calculate the lexicographical distance between two strings.\n    \n    The lexicographical distance is the number of character changes required to make the two strings identical,\n    without considering the order of characters. This function considers case sensitivity, handles Unicode characters,\n    and accounts for strings of different lengths.\n    \n    Parameters:\n    string1 (str): The first string.\n    string2 (str): The second string.\n    \n    Returns:\n    int: The lexicographical distance between the two strings.\n    \"\"\"\n    len_str1 = len(string1)\n    len_str2 = len(string2)\n    count = 0\n    string1 = unicodedata.normalize('NFC', string1)\n    string2 = unicodedata.normalize('NFC', string2)\n    for i in range(min(len_str1, len_str2)):\n        if string1[i] != string2[i]:\n            count += 1\n    if len_str1 != len_str2:\n        count += abs(len_str1 * len_str2)\n    return count"
    }
  ]
}