{
  "task_id": "cf_17316",
  "entry_point": "minimum_edit_distance",
  "mutant_count": 52,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if m == 0:",
      "mutated_line": "if m != 0:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m != 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n == 0:",
      "mutated_line": "if n != 0:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n != 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if m > n:",
      "mutated_line": "if m >= n:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m >= n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if m > n:",
      "mutated_line": "if m <= n:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m <= n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if m > n:",
      "mutated_line": "if m != n:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m != n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 1:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if m == 0:",
      "mutated_line": "if m == -1:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == -1:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 1:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 1:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0:",
      "mutated_line": "if n == -1:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == -1:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 1:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "previous_row = range(n + 1)",
      "mutated_line": "previous_row = range(n - 1)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n - 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "previous_row = range(n + 1)",
      "mutated_line": "previous_row = range(n * 1)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n * 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i, char1 in enumerate(str1, 1):",
      "mutated_line": "for (i, char1) in enumerate(str1, 2):",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 2):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i, char1 in enumerate(str1, 1):",
      "mutated_line": "for (i, char1) in enumerate(str1, 0):",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 0):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i, char1 in enumerate(str1, 1):",
      "mutated_line": "for (i, char1) in enumerate(str1, 0):",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 0):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i, char1 in enumerate(str1, 1):",
      "mutated_line": "for (i, char1) in enumerate(str1, -1):",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, -1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "previous_row = range(n + 1)",
      "mutated_line": "previous_row = range(n + 2)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 2)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "previous_row = range(n + 1)",
      "mutated_line": "previous_row = range(n + 0)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 0)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "previous_row = range(n + 1)",
      "mutated_line": "previous_row = range(n + 0)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 0)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "previous_row = range(n + 1)",
      "mutated_line": "previous_row = range(n + -1)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + -1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j, char2 in enumerate(str2, 1):",
      "mutated_line": "for (j, char2) in enumerate(str2, 2):",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 2):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j, char2 in enumerate(str2, 1):",
      "mutated_line": "for (j, char2) in enumerate(str2, 0):",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 0):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j, char2 in enumerate(str2, 1):",
      "mutated_line": "for (j, char2) in enumerate(str2, 0):",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 0):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j, char2 in enumerate(str2, 1):",
      "mutated_line": "for (j, char2) in enumerate(str2, -1):",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, -1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "insertions = previous_row[j] + 1",
      "mutated_line": "insertions = previous_row[j] - 1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] - 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "insertions = previous_row[j] + 1",
      "mutated_line": "insertions = previous_row[j] * 1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] * 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j - 1] - 1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] - 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j - 1] * 1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] * 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "substitutions = previous_row[j - 1] + (char1 != char2)",
      "mutated_line": "substitutions = previous_row[j - 1] - (char1 != char2)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] - (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "substitutions = previous_row[j - 1] + (char1 != char2)",
      "mutated_line": "substitutions = previous_row[j - 1] * (char1 != char2)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] * (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "insertions = previous_row[j] + 1",
      "mutated_line": "insertions = previous_row[j] + 2",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 2\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "insertions = previous_row[j] + 1",
      "mutated_line": "insertions = previous_row[j] + 0",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 0\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "insertions = previous_row[j] + 1",
      "mutated_line": "insertions = previous_row[j] + 0",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 0\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "insertions = previous_row[j] + 1",
      "mutated_line": "insertions = previous_row[j] + -1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + -1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j - 1] + 2",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 2\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j - 1] + 0",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 0\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j - 1] + 0",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 0\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j - 1] + -1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + -1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "substitutions = previous_row[j - 1] + (char1 != char2)",
      "mutated_line": "substitutions = previous_row[j - 1] + (char1 == char2)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (char1 == char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j + 1] + 1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j + 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j * 1] + 1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j * 1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "substitutions = previous_row[j - 1] + (char1 != char2)",
      "mutated_line": "substitutions = previous_row[j + 1] + (char1 != char2)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j + 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "substitutions = previous_row[j - 1] + (char1 != char2)",
      "mutated_line": "substitutions = previous_row[j * 1] + (char1 != char2)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j * 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j - 2] + 1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 2] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j - 0] + 1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 0] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j - 0] + 1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 0] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "deletions = current_row[j - 1] + 1",
      "mutated_line": "deletions = current_row[j - -1] + 1",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - -1] + 1\n            substitutions = previous_row[j - 1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "substitutions = previous_row[j - 1] + (char1 != char2)",
      "mutated_line": "substitutions = previous_row[j - 2] + (char1 != char2)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 2] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "substitutions = previous_row[j - 1] + (char1 != char2)",
      "mutated_line": "substitutions = previous_row[j - 0] + (char1 != char2)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 0] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "substitutions = previous_row[j - 1] + (char1 != char2)",
      "mutated_line": "substitutions = previous_row[j - 0] + (char1 != char2)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 0] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "substitutions = previous_row[j - 1] + (char1 != char2)",
      "mutated_line": "substitutions = previous_row[j - -1] + (char1 != char2)",
      "code": "def minimum_edit_distance(str1, str2):\n    (m, n) = (len(str1), len(str2))\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n    if m > n:\n        (str1, str2) = (str2, str1)\n        (m, n) = (n, m)\n    previous_row = range(n + 1)\n    for (i, char1) in enumerate(str1, 1):\n        current_row = [i]\n        for (j, char2) in enumerate(str2, 1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - -1] + (char1 != char2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[n]"
    }
  ]
}