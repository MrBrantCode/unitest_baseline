{
  "task_id": "cf_44134",
  "entry_point": "american_barrier_option_price",
  "mutant_count": 68,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):",
      "mutated_line": "def american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=101):",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=101):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):",
      "mutated_line": "def american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=99):",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=99):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):",
      "mutated_line": "def american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=0):",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=0):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):",
      "mutated_line": "def american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=1):",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=1):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):",
      "mutated_line": "def american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=-100):",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=-100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dt = T / steps",
      "mutated_line": "dt = T * steps",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T * steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dt = T / steps",
      "mutated_line": "dt = T // steps",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T // steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "total_price = 0",
      "mutated_line": "total_price = 1",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 1\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "total_price = 0",
      "mutated_line": "total_price = -1",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = -1\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "total_price = 0",
      "mutated_line": "total_price = 1",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 1\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "total_price += price",
      "mutated_line": "total_price -= price",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price -= price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return total_price / steps",
      "mutated_line": "return total_price * steps",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price * steps"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return total_price / steps",
      "mutated_line": "return total_price // steps",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price // steps"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "expiry = (i + 1) * dt",
      "mutated_line": "expiry = (i + 1) / dt",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) / dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "expiry = (i + 1) * dt",
      "mutated_line": "expiry = i + 1 + dt",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = i + 1 + dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "expiry = (i + 1) * dt",
      "mutated_line": "expiry = (i + 1) ** dt",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) ** dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if option_type == 'call':",
      "mutated_line": "if option_type != 'call':",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type != 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if S <= B:",
      "mutated_line": "if S < B:",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S < B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if S <= B:",
      "mutated_line": "if S > B:",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S > B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if S <= B:",
      "mutated_line": "if S == B:",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S == B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "expiry = (i + 1) * dt",
      "mutated_line": "expiry = (i - 1) * dt",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i - 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "expiry = (i + 1) * dt",
      "mutated_line": "expiry = i * 1 * dt",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = i * 1 * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if option_type == 'call':",
      "mutated_line": "if option_type == '':",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == '':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) / np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) / np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) + np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) + np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = (S * np.maximum(0, 1 - np.exp(-r * expiry))) ** np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = (S * np.maximum(0, 1 - np.exp(-r * expiry))) ** np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif option_type == 'put':",
      "mutated_line": "elif option_type != 'put':",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type != 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "price = 0",
      "mutated_line": "price = 1",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 1\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "price = 0",
      "mutated_line": "price = -1",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = -1\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "price = 0",
      "mutated_line": "price = 1",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 1\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "expiry = (i + 1) * dt",
      "mutated_line": "expiry = (i + 2) * dt",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 2) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "expiry = (i + 1) * dt",
      "mutated_line": "expiry = (i + 0) * dt",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 0) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "expiry = (i + 1) * dt",
      "mutated_line": "expiry = (i + 0) * dt",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 0) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "expiry = (i + 1) * dt",
      "mutated_line": "expiry = (i + -1) * dt",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + -1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S / np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S / np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = (S + np.maximum(0, 1 - np.exp(-r * expiry))) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = (S + np.maximum(0, 1 - np.exp(-r * expiry))) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S ** np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S ** np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif option_type == 'put':",
      "mutated_line": "elif option_type == '':",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == '':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(0, K - S) / np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) / np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(0, K - S) + np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) + np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(0, K - S) ** np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) ** np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r / expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r / expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r + expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r + expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp((-r) ** expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp((-r) ** expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(1, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(1, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(-1, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(-1, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(1, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(1, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 + np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 + np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 * np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 * np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(+r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(+r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(1, K - S) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(1, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(-1, K - S) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(-1, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(1, K - S) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(1, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(0, K + S) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K + S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(0, K * S) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K * S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(0, K - S) * np.exp(-r / expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r / expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(0, K - S) * np.exp(-r + expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r + expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(0, K - S) * np.exp((-r) ** expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp((-r) ** expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 2 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 2 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 0 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 0 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 0 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 0 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, -1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, -1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "price = np.maximum(0, K - S) * np.exp(-r * expiry)",
      "mutated_line": "price = np.maximum(0, K - S) * np.exp(+r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(+r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 - np.exp(-r / expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r / expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 - np.exp(-r + expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(-r + expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 - np.exp((-r) ** expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp((-r) ** expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "price = S * np.maximum(0, 1 - np.exp(-r * expiry)) * np.exp(-r * expiry)",
      "mutated_line": "price = S * np.maximum(0, 1 - np.exp(+r * expiry)) * np.exp(-r * expiry)",
      "code": "import numpy as np\n\ndef american_barrier_option_price(S, K, B, T, sigma, r, option_type, steps=100):\n    \"\"\"\n    Approximates the price of an American barrier option using a sequence of European barrier options.\n\n    Parameters:\n    S (float): Underlying asset's price.\n    K (float): Strike price.\n    B (float): Barrier price.\n    T (float): Time to expiry.\n    sigma (float): Volatility.\n    r (float): Risk-free rate.\n    option_type (str): Type of option (call or put).\n    steps (int): Number of European options to use for approximation.\n\n    Returns:\n    float: Approximate price of the American barrier option.\n    \"\"\"\n    dt = T / steps\n    total_price = 0\n    for i in range(steps):\n        expiry = (i + 1) * dt\n        if option_type == 'call':\n            price = S * np.maximum(0, 1 - np.exp(+r * expiry)) * np.exp(-r * expiry)\n        elif option_type == 'put':\n            price = np.maximum(0, K - S) * np.exp(-r * expiry)\n        if S <= B:\n            price = 0\n        total_price += price\n    return total_price / steps"
    }
  ]
}