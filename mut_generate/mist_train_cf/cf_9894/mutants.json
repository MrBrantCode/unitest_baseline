{
  "task_id": "cf_9894",
  "entry_point": "find_combinations",
  "mutant_count": 24,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 1\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = -1\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 1\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if remain == 0:",
      "mutated_line": "if remain != 0:",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain != 0:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count -= 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "backtrack(target, [], 0)",
      "mutated_line": "backtrack(target, [], 1)",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 1)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "backtrack(target, [], 0)",
      "mutated_line": "backtrack(target, [], -1)",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], -1)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "backtrack(target, [], 0)",
      "mutated_line": "backtrack(target, [], 1)",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 1)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if remain == 0:",
      "mutated_line": "if remain == 1:",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 1:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if remain == 0:",
      "mutated_line": "if remain == -1:",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == -1:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if remain == 0:",
      "mutated_line": "if remain == 1:",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 1:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 2\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 0\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 0\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += -1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif remain < 0:",
      "mutated_line": "elif remain <= 0:",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain <= 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif remain < 0:",
      "mutated_line": "elif remain >= 0:",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain >= 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif remain < 0:",
      "mutated_line": "elif remain != 0:",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain != 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif remain < 0:",
      "mutated_line": "elif remain < 1:",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 1:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif remain < 0:",
      "mutated_line": "elif remain < -1:",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < -1:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif remain < 0:",
      "mutated_line": "elif remain < 1:",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 1:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain - nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "backtrack(remain - nums[i], comb, i)",
      "mutated_line": "backtrack(remain + nums[i], comb, i)",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain + nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "backtrack(remain - nums[i], comb, i)",
      "mutated_line": "backtrack(remain * nums[i], comb, i)",
      "code": "from typing import List\n\ndef find_combinations(nums: List[int], target: int) -> int:\n    \"\"\"\n    Returns the number of distinct combinations of the given integers in `nums` that sum up to the `target`.\n    \n    :param nums: A list of integers.\n    :type nums: List[int]\n    :param target: The target sum.\n    :type target: int\n    :return: The number of distinct combinations.\n    :rtype: int\n    \"\"\"\n    count = 0\n\n    def backtrack(remain, comb, start):\n        nonlocal count\n        if remain == 0:\n            count += 1\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(remain * nums[i], comb, i)\n            comb.pop()\n    backtrack(target, [], 0)\n    return count"
    }
  ]
}