{
  "task_id": "cf_44035",
  "entry_point": "distribute_data",
  "mutant_count": 22,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "chunk_size = len(data) // num_nodes",
      "mutated_line": "chunk_size = len(data) / num_nodes",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) / num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "chunk_size = len(data) // num_nodes",
      "mutated_line": "chunk_size = len(data) * num_nodes",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) * num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "start = i * chunk_size",
      "mutated_line": "start = i / chunk_size",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i / chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "start = i * chunk_size",
      "mutated_line": "start = i + chunk_size",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i + chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "start = i * chunk_size",
      "mutated_line": "start = i ** chunk_size",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i ** chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "end = start + chunk_size",
      "mutated_line": "end = start - chunk_size",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start - chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "end = start + chunk_size",
      "mutated_line": "end = start * chunk_size",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start * chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i == num_nodes - 1:",
      "mutated_line": "if i != num_nodes - 1:",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i != num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i == num_nodes - 1:",
      "mutated_line": "if i == num_nodes + 1:",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes + 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i == num_nodes - 1:",
      "mutated_line": "if i == num_nodes * 1:",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes * 1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == num_nodes - 1:",
      "mutated_line": "if i == num_nodes - 2:",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 2:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == num_nodes - 1:",
      "mutated_line": "if i == num_nodes - 0:",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 0:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == num_nodes - 1:",
      "mutated_line": "if i == num_nodes - 0:",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 0:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == num_nodes - 1:",
      "mutated_line": "if i == num_nodes - -1:",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - -1:\n            end = len(data)\n        distributed_data[f'Node {i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "distributed_data[f'Node {i+1}'] = data[start:end]",
      "mutated_line": "distributed_data[f'{i + 1}'] = data[start:end]",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'{i + 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "distributed_data[f'Node {i+1}'] = data[start:end]",
      "mutated_line": "distributed_data[f'Node {i - 1}'] = data[start:end]",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i - 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "distributed_data[f'Node {i+1}'] = data[start:end]",
      "mutated_line": "distributed_data[f'Node {i * 1}'] = data[start:end]",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i * 1}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "distributed_data[f'Node {i+1}'] = data[start:end]",
      "mutated_line": "distributed_data[f'Node {i + 2}'] = data[start:end]",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 2}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "distributed_data[f'Node {i+1}'] = data[start:end]",
      "mutated_line": "distributed_data[f'Node {i + 0}'] = data[start:end]",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 0}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "distributed_data[f'Node {i+1}'] = data[start:end]",
      "mutated_line": "distributed_data[f'Node {i + 0}'] = data[start:end]",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + 0}'] = data[start:end]\n    return distributed_data"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "distributed_data[f'Node {i+1}'] = data[start:end]",
      "mutated_line": "distributed_data[f'Node {i + -1}'] = data[start:end]",
      "code": "def distribute_data(data, num_nodes):\n    \"\"\"\n    Distributes data across nodes to prevent data skew.\n\n    Args:\n        data (list): The list of data to be distributed.\n        num_nodes (int): The number of nodes to distribute the data across.\n\n    Returns:\n        dict: A dictionary where the keys are the node IDs and the values are the data distributed across these nodes.\n    \"\"\"\n    chunk_size = len(data) // num_nodes\n    distributed_data = {}\n    for i in range(num_nodes):\n        start = i * chunk_size\n        end = start + chunk_size\n        if i == num_nodes - 1:\n            end = len(data)\n        distributed_data[f'Node {i + -1}'] = data[start:end]\n    return distributed_data"
    }
  ]
}