{
  "task_id": "cf_36882",
  "entry_point": "calculate_entropy",
  "mutant_count": 40,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0.0  # Return 0.0 for empty input",
      "mutated_line": "return 1.0",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 1.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0.0  # Return 0.0 for empty input",
      "mutated_line": "return -1.0",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return -1.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0.0  # Return 0.0 for empty input",
      "mutated_line": "return 1",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 1\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "entropy = -sum(p * math.log2(p) for p in probabilities)",
      "mutated_line": "entropy = +sum((p * math.log2(p) for p in probabilities))",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = +sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "total_bits = len(data) * 8  # Assuming 8 bits per byte",
      "mutated_line": "total_bits = len(data) / 8",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) / 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "total_bits = len(data) * 8  # Assuming 8 bits per byte",
      "mutated_line": "total_bits = len(data) + 8",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) + 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "total_bits = len(data) * 8  # Assuming 8 bits per byte",
      "mutated_line": "total_bits = len(data) ** 8",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) ** 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "p = ones / total_bits",
      "mutated_line": "p = ones * total_bits",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones * total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "p = ones / total_bits",
      "mutated_line": "p = ones // total_bits",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones // total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) + (1 - p) * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) + (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) * ((1 - p) * math.log2(1 - p))",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) * ((1 - p) * math.log2(1 - p))\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "probabilities = [float(data.count(c)) / len(data) for c in set(data)]",
      "mutated_line": "entropy = -sum((p * math.log2(p) for p in probabilities))",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) * len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "probabilities = [float(data.count(c)) / len(data) for c in set(data)]",
      "mutated_line": "entropy = -sum((p * math.log2(p) for p in probabilities))",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) // len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total_bits = len(data) * 8  # Assuming 8 bits per byte",
      "mutated_line": "total_bits = len(data) * 9",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 9\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total_bits = len(data) * 8  # Assuming 8 bits per byte",
      "mutated_line": "total_bits = len(data) * 7",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 7\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total_bits = len(data) * 8  # Assuming 8 bits per byte",
      "mutated_line": "total_bits = len(data) * 0",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 0\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total_bits = len(data) * 8  # Assuming 8 bits per byte",
      "mutated_line": "total_bits = len(data) * 1",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 1\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total_bits = len(data) * 8  # Assuming 8 bits per byte",
      "mutated_line": "total_bits = len(data) * -8",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * -8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p / math.log2(p) - (1 - p) * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p / math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p + math.log2(p) - (1 - p) * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p + math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = (-p) ** math.log2(p) - (1 - p) * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = (-p) ** math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (1 - p) / math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) / math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (1 - p + math.log2(1 - p))",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p + math.log2(1 - p))\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (1 - p) ** math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) ** math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = +p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = +p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (1 + p) * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 + p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - 1 * p * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - 1 * p * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "entropy = -sum(p * math.log2(p) for p in probabilities)",
      "mutated_line": "entropy = -sum((p / math.log2(p) for p in probabilities))",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p / math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "entropy = -sum(p * math.log2(p) for p in probabilities)",
      "mutated_line": "entropy = -sum((p + math.log2(p) for p in probabilities))",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p + math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "entropy = -sum(p * math.log2(p) for p in probabilities)",
      "mutated_line": "entropy = -sum((p ** math.log2(p) for p in probabilities))",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p ** math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (2 - p) * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (2 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (0 - p) * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (0 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (0 - p) * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (0 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (-1 - p) * math.log2(1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (-1 - p) * math.log2(1 - p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 + p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 + p)\n    return entropy"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 * p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(1 * p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(2 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(2 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(0 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(0 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(0 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(0 - p)\n    return entropy"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(1 - p)",
      "mutated_line": "entropy = -p * math.log2(p) - (1 - p) * math.log2(-1 - p)",
      "code": "from typing import Union\nimport math\n\ndef calculate_entropy(data: Union[str, bytes]) -> float:\n    if not data:\n        return 0.0\n    if isinstance(data, str):\n        probabilities = [float(data.count(c)) / len(data) for c in set(data)]\n        entropy = -sum((p * math.log2(p) for p in probabilities))\n    else:\n        ones = data.count(b'\\x01')\n        total_bits = len(data) * 8\n        p = ones / total_bits\n        entropy = -p * math.log2(p) - (1 - p) * math.log2(-1 - p)\n    return entropy"
    }
  ]
}