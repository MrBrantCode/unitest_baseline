{
  "task_id": "cf_13708",
  "entry_point": "dfs",
  "mutant_count": 9,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def dfs(graph, source, target):\n    \"\"\"\"\"\"\n    visited = [False] * len(graph)\n    path = []\n    all_paths = []\n    dfs_util(graph, source, target, visited, path, all_paths)\n    return all_paths\n\ndef dfs_util(graph, u, target, visited, path, all_paths):\n    \"\"\"\n    Recursive utility function to perform DFS traversal.\n    \"\"\"\n    visited[u] = True\n    path.append(u)\n    if u == target:\n        all_paths.append(list(path))\n    else:\n        for v in graph[u]:\n            if not visited[v]:\n                dfs_util(graph, v, target, visited, path, all_paths)\n    path.pop()\n    visited[u] = False"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visited = [False] * len(graph)",
      "mutated_line": "visited = [False] / len(graph)",
      "code": "def dfs(graph, source, target):\n    \"\"\"\n    Finds all possible paths from a starting node to a target node in a directed graph.\n\n    Args:\n    graph: Adjacency list representation of the graph.\n    source: Starting node.\n    target: Target node.\n\n    Returns:\n    A list of all possible paths from the source node to the target node.\n    \"\"\"\n    visited = [False] / len(graph)\n    path = []\n    all_paths = []\n    dfs_util(graph, source, target, visited, path, all_paths)\n    return all_paths\n\ndef dfs_util(graph, u, target, visited, path, all_paths):\n    \"\"\"\n    Recursive utility function to perform DFS traversal.\n    \"\"\"\n    visited[u] = True\n    path.append(u)\n    if u == target:\n        all_paths.append(list(path))\n    else:\n        for v in graph[u]:\n            if not visited[v]:\n                dfs_util(graph, v, target, visited, path, all_paths)\n    path.pop()\n    visited[u] = False"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visited = [False] * len(graph)",
      "mutated_line": "visited = [False] + len(graph)",
      "code": "def dfs(graph, source, target):\n    \"\"\"\n    Finds all possible paths from a starting node to a target node in a directed graph.\n\n    Args:\n    graph: Adjacency list representation of the graph.\n    source: Starting node.\n    target: Target node.\n\n    Returns:\n    A list of all possible paths from the source node to the target node.\n    \"\"\"\n    visited = [False] + len(graph)\n    path = []\n    all_paths = []\n    dfs_util(graph, source, target, visited, path, all_paths)\n    return all_paths\n\ndef dfs_util(graph, u, target, visited, path, all_paths):\n    \"\"\"\n    Recursive utility function to perform DFS traversal.\n    \"\"\"\n    visited[u] = True\n    path.append(u)\n    if u == target:\n        all_paths.append(list(path))\n    else:\n        for v in graph[u]:\n            if not visited[v]:\n                dfs_util(graph, v, target, visited, path, all_paths)\n    path.pop()\n    visited[u] = False"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visited = [False] * len(graph)",
      "mutated_line": "visited = [False] ** len(graph)",
      "code": "def dfs(graph, source, target):\n    \"\"\"\n    Finds all possible paths from a starting node to a target node in a directed graph.\n\n    Args:\n    graph: Adjacency list representation of the graph.\n    source: Starting node.\n    target: Target node.\n\n    Returns:\n    A list of all possible paths from the source node to the target node.\n    \"\"\"\n    visited = [False] ** len(graph)\n    path = []\n    all_paths = []\n    dfs_util(graph, source, target, visited, path, all_paths)\n    return all_paths\n\ndef dfs_util(graph, u, target, visited, path, all_paths):\n    \"\"\"\n    Recursive utility function to perform DFS traversal.\n    \"\"\"\n    visited[u] = True\n    path.append(u)\n    if u == target:\n        all_paths.append(list(path))\n    else:\n        for v in graph[u]:\n            if not visited[v]:\n                dfs_util(graph, v, target, visited, path, all_paths)\n    path.pop()\n    visited[u] = False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def dfs(graph, source, target):\n    \"\"\"\n    Finds all possible paths from a starting node to a target node in a directed graph.\n\n    Args:\n    graph: Adjacency list representation of the graph.\n    source: Starting node.\n    target: Target node.\n\n    Returns:\n    A list of all possible paths from the source node to the target node.\n    \"\"\"\n    visited = [False] * len(graph)\n    path = []\n    all_paths = []\n    dfs_util(graph, source, target, visited, path, all_paths)\n    return all_paths\n\ndef dfs_util(graph, u, target, visited, path, all_paths):\n    \"\"\"\"\"\"\n    visited[u] = True\n    path.append(u)\n    if u == target:\n        all_paths.append(list(path))\n    else:\n        for v in graph[u]:\n            if not visited[v]:\n                dfs_util(graph, v, target, visited, path, all_paths)\n    path.pop()\n    visited[u] = False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[u] = True",
      "mutated_line": "visited[u] = False",
      "code": "def dfs(graph, source, target):\n    \"\"\"\n    Finds all possible paths from a starting node to a target node in a directed graph.\n\n    Args:\n    graph: Adjacency list representation of the graph.\n    source: Starting node.\n    target: Target node.\n\n    Returns:\n    A list of all possible paths from the source node to the target node.\n    \"\"\"\n    visited = [False] * len(graph)\n    path = []\n    all_paths = []\n    dfs_util(graph, source, target, visited, path, all_paths)\n    return all_paths\n\ndef dfs_util(graph, u, target, visited, path, all_paths):\n    \"\"\"\n    Recursive utility function to perform DFS traversal.\n    \"\"\"\n    visited[u] = False\n    path.append(u)\n    if u == target:\n        all_paths.append(list(path))\n    else:\n        for v in graph[u]:\n            if not visited[v]:\n                dfs_util(graph, v, target, visited, path, all_paths)\n    path.pop()\n    visited[u] = False"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if u == target:",
      "mutated_line": "if u != target:",
      "code": "def dfs(graph, source, target):\n    \"\"\"\n    Finds all possible paths from a starting node to a target node in a directed graph.\n\n    Args:\n    graph: Adjacency list representation of the graph.\n    source: Starting node.\n    target: Target node.\n\n    Returns:\n    A list of all possible paths from the source node to the target node.\n    \"\"\"\n    visited = [False] * len(graph)\n    path = []\n    all_paths = []\n    dfs_util(graph, source, target, visited, path, all_paths)\n    return all_paths\n\ndef dfs_util(graph, u, target, visited, path, all_paths):\n    \"\"\"\n    Recursive utility function to perform DFS traversal.\n    \"\"\"\n    visited[u] = True\n    path.append(u)\n    if u != target:\n        all_paths.append(list(path))\n    else:\n        for v in graph[u]:\n            if not visited[v]:\n                dfs_util(graph, v, target, visited, path, all_paths)\n    path.pop()\n    visited[u] = False"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "visited[u] = False",
      "mutated_line": "visited[u] = True",
      "code": "def dfs(graph, source, target):\n    \"\"\"\n    Finds all possible paths from a starting node to a target node in a directed graph.\n\n    Args:\n    graph: Adjacency list representation of the graph.\n    source: Starting node.\n    target: Target node.\n\n    Returns:\n    A list of all possible paths from the source node to the target node.\n    \"\"\"\n    visited = [False] * len(graph)\n    path = []\n    all_paths = []\n    dfs_util(graph, source, target, visited, path, all_paths)\n    return all_paths\n\ndef dfs_util(graph, u, target, visited, path, all_paths):\n    \"\"\"\n    Recursive utility function to perform DFS traversal.\n    \"\"\"\n    visited[u] = True\n    path.append(u)\n    if u == target:\n        all_paths.append(list(path))\n    else:\n        for v in graph[u]:\n            if not visited[v]:\n                dfs_util(graph, v, target, visited, path, all_paths)\n    path.pop()\n    visited[u] = True"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [False] * len(graph)",
      "mutated_line": "visited = [True] * len(graph)",
      "code": "def dfs(graph, source, target):\n    \"\"\"\n    Finds all possible paths from a starting node to a target node in a directed graph.\n\n    Args:\n    graph: Adjacency list representation of the graph.\n    source: Starting node.\n    target: Target node.\n\n    Returns:\n    A list of all possible paths from the source node to the target node.\n    \"\"\"\n    visited = [True] * len(graph)\n    path = []\n    all_paths = []\n    dfs_util(graph, source, target, visited, path, all_paths)\n    return all_paths\n\ndef dfs_util(graph, u, target, visited, path, all_paths):\n    \"\"\"\n    Recursive utility function to perform DFS traversal.\n    \"\"\"\n    visited[u] = True\n    path.append(u)\n    if u == target:\n        all_paths.append(list(path))\n    else:\n        for v in graph[u]:\n            if not visited[v]:\n                dfs_util(graph, v, target, visited, path, all_paths)\n    path.pop()\n    visited[u] = False"
    }
  ]
}