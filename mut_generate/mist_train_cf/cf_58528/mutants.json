{
  "task_id": "cf_58528",
  "entry_point": "minProjectComplexity",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total_complexity = 0",
      "mutated_line": "total_complexity = 1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 1\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total_complexity = 0",
      "mutated_line": "total_complexity = -1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = -1\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total_complexity = 0",
      "mutated_line": "total_complexity = 1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 1\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 1\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "j = 0",
      "mutated_line": "j = -1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = -1\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 1\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:",
      "mutated_line": "while j < len(projectComplexity) or projectComplexity[j] <= constraints[i]:",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) or projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j -= 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "total_complexity += -heapq.heappop(queue)",
      "mutated_line": "total_complexity -= -heapq.heappop(queue)",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity -= -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "return total_complexity if j == len(projectComplexity) else -1",
      "mutated_line": "return total_complexity if j != len(projectComplexity) else -1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j != len(projectComplexity) else -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "return total_complexity if j == len(projectComplexity) else -1",
      "mutated_line": "return total_complexity if j == len(projectComplexity) else +1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else +1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "projectComplexity.sort(reverse=True)",
      "mutated_line": "projectComplexity.sort(reverse=False)",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=False)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "constraints.sort(reverse=True)",
      "mutated_line": "constraints.sort(reverse=False)",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=False)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:",
      "mutated_line": "while j <= len(projectComplexity) and projectComplexity[j] <= constraints[i]:",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j <= len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:",
      "mutated_line": "while j >= len(projectComplexity) and projectComplexity[j] <= constraints[i]:",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j >= len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:",
      "mutated_line": "while j != len(projectComplexity) and projectComplexity[j] <= constraints[i]:",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j != len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:",
      "mutated_line": "while j < len(projectComplexity) and projectComplexity[j] < constraints[i]:",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] < constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:",
      "mutated_line": "while j < len(projectComplexity) and projectComplexity[j] > constraints[i]:",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] > constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:",
      "mutated_line": "while j < len(projectComplexity) and projectComplexity[j] == constraints[i]:",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] == constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 2\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 0\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 0\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += -1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "total_complexity += -heapq.heappop(queue)",
      "mutated_line": "total_complexity += +heapq.heappop(queue)",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += +heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif j < len(projectComplexity):",
      "mutated_line": "elif j <= len(projectComplexity):",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j <= len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif j < len(projectComplexity):",
      "mutated_line": "elif j >= len(projectComplexity):",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j >= len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif j < len(projectComplexity):",
      "mutated_line": "elif j != len(projectComplexity):",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j != len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return total_complexity if j == len(projectComplexity) else -1",
      "mutated_line": "return total_complexity if j == len(projectComplexity) else -2",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return total_complexity if j == len(projectComplexity) else -1",
      "mutated_line": "return total_complexity if j == len(projectComplexity) else -0",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return total_complexity if j == len(projectComplexity) else -1",
      "mutated_line": "return total_complexity if j == len(projectComplexity) else -0",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return total_complexity if j == len(projectComplexity) else -1",
      "mutated_line": "return total_complexity if j == len(projectComplexity) else --1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else --1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "heapq.heappush(queue, -projectComplexity[j])",
      "mutated_line": "heapq.heappush(queue, +projectComplexity[j])",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, +projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return +1\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -2\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -0\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return -0\n    return total_complexity if j == len(projectComplexity) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef minProjectComplexity(projectComplexity, d, constraints):\n    projectComplexity.sort(reverse=True)\n    constraints.sort(reverse=True)\n    queue = []\n    total_complexity = 0\n    j = 0\n    for i in range(d):\n        while j < len(projectComplexity) and projectComplexity[j] <= constraints[i]:\n            heapq.heappush(queue, -projectComplexity[j])\n            j += 1\n        if queue:\n            total_complexity += -heapq.heappop(queue)\n        elif j < len(projectComplexity):\n            return --1\n    return total_complexity if j == len(projectComplexity) else -1"
    }
  ]
}