{
  "task_id": "cf_26552",
  "entry_point": "calculate_starting_addresses",
  "mutant_count": 9,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"Calculates the starting addresses of memory regions based on a 4K aligned memory layout.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def calculate_starting_addresses(num_regions):\n    \"\"\"\"\"\"\n    starting_addresses = []\n    for i in range(num_regions):\n        start_address = hex(i * 4096)\n        starting_addresses.append(start_address)\n    return starting_addresses"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "start_address = hex(i * 4096)  # Calculate the starting address based on 4K boundaries",
      "mutated_line": "start_address = hex(i / 4096)",
      "code": "def calculate_starting_addresses(num_regions):\n    \"\"\"Calculates the starting addresses of memory regions based on a 4K aligned memory layout.\"\"\"\n    starting_addresses = []\n    for i in range(num_regions):\n        start_address = hex(i / 4096)\n        starting_addresses.append(start_address)\n    return starting_addresses"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "start_address = hex(i * 4096)  # Calculate the starting address based on 4K boundaries",
      "mutated_line": "start_address = hex(i + 4096)",
      "code": "def calculate_starting_addresses(num_regions):\n    \"\"\"Calculates the starting addresses of memory regions based on a 4K aligned memory layout.\"\"\"\n    starting_addresses = []\n    for i in range(num_regions):\n        start_address = hex(i + 4096)\n        starting_addresses.append(start_address)\n    return starting_addresses"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "start_address = hex(i * 4096)  # Calculate the starting address based on 4K boundaries",
      "mutated_line": "start_address = hex(i ** 4096)",
      "code": "def calculate_starting_addresses(num_regions):\n    \"\"\"Calculates the starting addresses of memory regions based on a 4K aligned memory layout.\"\"\"\n    starting_addresses = []\n    for i in range(num_regions):\n        start_address = hex(i ** 4096)\n        starting_addresses.append(start_address)\n    return starting_addresses"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "start_address = hex(i * 4096)  # Calculate the starting address based on 4K boundaries",
      "mutated_line": "start_address = hex(i * 4097)",
      "code": "def calculate_starting_addresses(num_regions):\n    \"\"\"Calculates the starting addresses of memory regions based on a 4K aligned memory layout.\"\"\"\n    starting_addresses = []\n    for i in range(num_regions):\n        start_address = hex(i * 4097)\n        starting_addresses.append(start_address)\n    return starting_addresses"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "start_address = hex(i * 4096)  # Calculate the starting address based on 4K boundaries",
      "mutated_line": "start_address = hex(i * 4095)",
      "code": "def calculate_starting_addresses(num_regions):\n    \"\"\"Calculates the starting addresses of memory regions based on a 4K aligned memory layout.\"\"\"\n    starting_addresses = []\n    for i in range(num_regions):\n        start_address = hex(i * 4095)\n        starting_addresses.append(start_address)\n    return starting_addresses"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "start_address = hex(i * 4096)  # Calculate the starting address based on 4K boundaries",
      "mutated_line": "start_address = hex(i * 0)",
      "code": "def calculate_starting_addresses(num_regions):\n    \"\"\"Calculates the starting addresses of memory regions based on a 4K aligned memory layout.\"\"\"\n    starting_addresses = []\n    for i in range(num_regions):\n        start_address = hex(i * 0)\n        starting_addresses.append(start_address)\n    return starting_addresses"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "start_address = hex(i * 4096)  # Calculate the starting address based on 4K boundaries",
      "mutated_line": "start_address = hex(i * 1)",
      "code": "def calculate_starting_addresses(num_regions):\n    \"\"\"Calculates the starting addresses of memory regions based on a 4K aligned memory layout.\"\"\"\n    starting_addresses = []\n    for i in range(num_regions):\n        start_address = hex(i * 1)\n        starting_addresses.append(start_address)\n    return starting_addresses"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "start_address = hex(i * 4096)  # Calculate the starting address based on 4K boundaries",
      "mutated_line": "start_address = hex(i * -4096)",
      "code": "def calculate_starting_addresses(num_regions):\n    \"\"\"Calculates the starting addresses of memory regions based on a 4K aligned memory layout.\"\"\"\n    starting_addresses = []\n    for i in range(num_regions):\n        start_address = hex(i * -4096)\n        starting_addresses.append(start_address)\n    return starting_addresses"
    }
  ]
}