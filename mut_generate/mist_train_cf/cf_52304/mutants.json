{
  "task_id": "cf_52304",
  "entry_point": "complex_sort",
  "mutant_count": 16,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def complex_sort(lst):\n    \"\"\"\"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] + types[float] + types[str] + types['other']"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return types[int] + types[float] + types[str] + types['other']",
      "mutated_line": "return types[int] + types[float] + types[str] - types['other']",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] + types[float] + types[str] - types['other']"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return types[int] + types[float] + types[str] + types['other']",
      "mutated_line": "return (types[int] + types[float] + types[str]) * types['other']",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return (types[int] + types[float] + types[str]) * types['other']"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "types = {int: [], float: [], str: [], 'other': []}",
      "mutated_line": "types = {int: [], float: [], str: [], '': []}",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], '': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] + types[float] + types[str] + types['other']"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if type(el) == int:",
      "mutated_line": "if type(el) != int:",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) != int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] + types[float] + types[str] + types['other']"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "types['other'] = sorted(types['other'], key=str)",
      "mutated_line": "types[''] = sorted(types['other'], key=str)",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types[''] = sorted(types['other'], key=str)\n    return types[int] + types[float] + types[str] + types['other']"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return types[int] + types[float] + types[str] + types['other']",
      "mutated_line": "return types[int] + types[float] - types[str] + types['other']",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] + types[float] - types[str] + types['other']"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return types[int] + types[float] + types[str] + types['other']",
      "mutated_line": "return (types[int] + types[float]) * types[str] + types['other']",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return (types[int] + types[float]) * types[str] + types['other']"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif type(el) == float:",
      "mutated_line": "elif type(el) != float:",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) != float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] + types[float] + types[str] + types['other']"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "types[int] = sorted(types[int], reverse=True)",
      "mutated_line": "types[int] = sorted(types[int], reverse=False)",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=False)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] + types[float] + types[str] + types['other']"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "types['other'] = sorted(types['other'], key=str)",
      "mutated_line": "types['other'] = sorted(types[''], key=str)",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types[''], key=str)\n    return types[int] + types[float] + types[str] + types['other']"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return types[int] + types[float] + types[str] + types['other']",
      "mutated_line": "return types[int] - types[float] + types[str] + types['other']",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] - types[float] + types[str] + types['other']"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return types[int] + types[float] + types[str] + types['other']",
      "mutated_line": "return types[int] * types[float] + types[str] + types['other']",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] * types[float] + types[str] + types['other']"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return types[int] + types[float] + types[str] + types['other']",
      "mutated_line": "return types[int] + types[float] + types[str] + types['']",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] + types[float] + types[str] + types['']"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif type(el) == str:",
      "mutated_line": "elif type(el) != str:",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) != str:\n            types[str].append(el)\n        else:\n            types['other'].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] + types[float] + types[str] + types['other']"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "types['other'].append(el)",
      "mutated_line": "types[''].append(el)",
      "code": "def complex_sort(lst):\n    \"\"\"\n    Sorts a list of elements of different data types.\n\n    The sorting priority is:\n    - Integers (sorted in descending order)\n    - Floats (sorted in ascending order)\n    - Strings (sorted in alphabetical order)\n    - Others (sorted based on their string representation, alphabetical order)\n\n    Args:\n        lst (list): A list of elements of different data types.\n\n    Returns:\n        list: A sorted list.\n    \"\"\"\n    types = {int: [], float: [], str: [], 'other': []}\n    for el in lst:\n        if type(el) == int:\n            types[int].append(el)\n        elif type(el) == float:\n            types[float].append(el)\n        elif type(el) == str:\n            types[str].append(el)\n        else:\n            types[''].append(el)\n    types[int] = sorted(types[int], reverse=True)\n    types[float] = sorted(types[float])\n    types[str] = sorted(types[str])\n    types['other'] = sorted(types['other'], key=str)\n    return types[int] + types[float] + types[str] + types['other']"
    }
  ]
}