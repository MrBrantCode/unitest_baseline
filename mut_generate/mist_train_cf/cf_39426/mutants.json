{
  "task_id": "cf_39426",
  "entry_point": "Fourier_approx",
  "mutant_count": 54,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f -= 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f -= 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(2, N + 1, 2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(2, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(0, N + 1, 2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(0, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(0, N + 1, 2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(0, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(-1, N + 1, 2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(-1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N - 1, 2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N - 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N * 1, 2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N * 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N + 1, 3):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 3):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N + 1, 1):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 1):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N + 1, 0):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 0):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N + 1, 1):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 1):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N + 1, -2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, -2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) / np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) / np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) + np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) + np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += (4 * A / np.pi * (1 / n)) ** np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += (4 * A / np.pi * (1 / n)) ** np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N + 2, 2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 2, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N + 0, 2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 0, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N + 0, 2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 0, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for n in range(1, N+1, 2):  # Sum over odd terms",
      "mutated_line": "for n in range(1, N + -1, 2):",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + -1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi / (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi / (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += (4 * A / np.pi + 1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += (4 * A / np.pi + 1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += (4 * A / np.pi) ** (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += (4 * A / np.pi) ** (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A * np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A * np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A // np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A // np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 * n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 * n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 // n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 // n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t * T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t * T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t // T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t // T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 / A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 / A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += (4 + A) / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += (4 + A) / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 ** A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 ** A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (2 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (2 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (0 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (0 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (0 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (0 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (-1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (-1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n / t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n / t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin((2 * np.pi * n + t) / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin((2 * np.pi * n + t) / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin((2 * np.pi * n) ** t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin((2 * np.pi * n) ** t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 5 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 5 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 3 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 3 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 0 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 0 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 1 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 1 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += -4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += -4 * A / np.pi * (1 / n) * np.sin(2 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi / n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 * np.pi / n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin((2 * np.pi + n) * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin((2 * np.pi + n) * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin((2 * np.pi) ** n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin((2 * np.pi) ** n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(2 / np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 / np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin((2 + np.pi) * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin((2 + np.pi) * n * t / T)\n    return f"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(2 ** np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(2 ** np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(3 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(3 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(1 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(1 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(0 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(0 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(1 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(1 * np.pi * n * t / T)\n    return f"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (4*A/np.pi) * (1/n) * np.sin(2*np.pi*n*t/T)",
      "mutated_line": "f += 4 * A / np.pi * (1 / n) * np.sin(-2 * np.pi * n * t / T)",
      "code": "import numpy as np\n\ndef Fourier_approx(N, t, T, A):\n    f = np.zeros_like(t)\n    for n in range(1, N + 1, 2):\n        f += 4 * A / np.pi * (1 / n) * np.sin(-2 * np.pi * n * t / T)\n    return f"
    }
  ]
}