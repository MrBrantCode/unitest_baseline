{
  "task_id": "cf_100900",
  "entry_point": "calculate_weighted_rank",
  "mutant_count": 39,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 * population_index - 0.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index - 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 * population_index * (0.4 * gdp_index)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index * (0.4 * gdp_index)\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)",
      "mutated_line": "population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=False)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=False)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)",
      "mutated_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=False)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=False)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 / population_index + 0.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 / population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 + population_index + 0.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 + population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 ** population_index + 0.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 ** population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 * population_index + 0.4 / gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 / gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 * population_index + (0.4 + gdp_index)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + (0.4 + gdp_index)\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 * population_index + 0.4 ** gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 ** gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 1.6 * population_index + 0.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 1.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = -0.4 * population_index + 0.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = -0.4 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0 * population_index + 0.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 1 * population_index + 0.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 1 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = -0.6 * population_index + 0.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = -0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 * population_index + 1.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 1.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 * population_index + -0.6 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + -0.6 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 * population_index + 0 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 * population_index + 1 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 1 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "rank = (0.6 * population_index) + (0.4 * gdp_index)",
      "mutated_line": "rank = 0.6 * population_index + -0.4 * gdp_index",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + -0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)",
      "mutated_line": "population_rank = sorted(city_data.items(), key=lambda x: x[1][''], reverse=True)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1][''], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)",
      "mutated_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[1][''], reverse=True)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1][''], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "population_index = next(i for i, x in enumerate(population_rank) if x[0] == city)",
      "mutated_line": "population_index = next((i for (i, x) in enumerate(population_rank) if x[0] != city))",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] != city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "gdp_index = next(i for i, x in enumerate(gdp_rank) if x[0] == city)",
      "mutated_line": "gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] != city))",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] != city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)",
      "mutated_line": "population_rank = sorted(city_data.items(), key=lambda x: x[2]['population'], reverse=True)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[2]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)",
      "mutated_line": "population_rank = sorted(city_data.items(), key=lambda x: x[0]['population'], reverse=True)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[0]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)",
      "mutated_line": "population_rank = sorted(city_data.items(), key=lambda x: x[0]['population'], reverse=True)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[0]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)",
      "mutated_line": "population_rank = sorted(city_data.items(), key=lambda x: x[-1]['population'], reverse=True)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[-1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)",
      "mutated_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[2]['gdp_per_capita'], reverse=True)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[2]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)",
      "mutated_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[0]['gdp_per_capita'], reverse=True)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[0]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)",
      "mutated_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[0]['gdp_per_capita'], reverse=True)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[0]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)",
      "mutated_line": "gdp_rank = sorted(city_data.items(), key=lambda x: x[-1]['gdp_per_capita'], reverse=True)",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[-1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "population_index = next(i for i, x in enumerate(population_rank) if x[0] == city)",
      "mutated_line": "population_index = next((i for (i, x) in enumerate(population_rank) if x[1] == city))",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[1] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "population_index = next(i for i, x in enumerate(population_rank) if x[0] == city)",
      "mutated_line": "population_index = next((i for (i, x) in enumerate(population_rank) if x[-1] == city))",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[-1] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "population_index = next(i for i, x in enumerate(population_rank) if x[0] == city)",
      "mutated_line": "population_index = next((i for (i, x) in enumerate(population_rank) if x[1] == city))",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[1] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[0] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "gdp_index = next(i for i, x in enumerate(gdp_rank) if x[0] == city)",
      "mutated_line": "gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[1] == city))",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[1] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "gdp_index = next(i for i, x in enumerate(gdp_rank) if x[0] == city)",
      "mutated_line": "gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[-1] == city))",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[-1] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "gdp_index = next(i for i, x in enumerate(gdp_rank) if x[0] == city)",
      "mutated_line": "gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[1] == city))",
      "code": "def calculate_weighted_rank(city_data):\n    \"\"\"\n    Calculate the weighted rank of cities based on their population sizes and GDP per capita.\n    \n    Args:\n        city_data (dict): A dictionary of city data, where each city is a key and its corresponding value is another dictionary containing the city's population size and GDP per capita.\n    \n    Returns:\n        dict: A dictionary with the city names as keys and their corresponding weighted ranks as values.\n    \"\"\"\n    population_rank = sorted(city_data.items(), key=lambda x: x[1]['population'], reverse=True)\n    gdp_rank = sorted(city_data.items(), key=lambda x: x[1]['gdp_per_capita'], reverse=True)\n    weighted_rank = {}\n    for city in city_data:\n        population_index = next((i for (i, x) in enumerate(population_rank) if x[0] == city))\n        gdp_index = next((i for (i, x) in enumerate(gdp_rank) if x[1] == city))\n        rank = 0.6 * population_index + 0.4 * gdp_index\n        weighted_rank[city] = rank\n    return weighted_rank"
    }
  ]
}