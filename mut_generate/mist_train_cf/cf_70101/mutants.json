{
  "task_id": "cf_70101",
  "entry_point": "levenshtein_distance",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(s1) < len(s2):",
      "mutated_line": "if len(s1) <= len(s2):",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) <= len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(s1) < len(s2):",
      "mutated_line": "if len(s1) >= len(s2):",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) >= len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(s1) < len(s2):",
      "mutated_line": "if len(s1) != len(s2):",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) != len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(s2) == 0:",
      "mutated_line": "if len(s2) != 0:",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) != 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(s2) == 0:",
      "mutated_line": "if len(s2) == 1:",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 1:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(s2) == 0:",
      "mutated_line": "if len(s2) == -1:",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == -1:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(s2) == 0:",
      "mutated_line": "if len(s2) == 1:",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 1:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "previous_row = range(len(s2) + 1)",
      "mutated_line": "for (i, c1) in enumerate(s1):",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) - 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "previous_row = range(len(s2) + 1)",
      "mutated_line": "for (i, c1) in enumerate(s1):",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) * 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "return previous_row[-1]",
      "mutated_line": "return previous_row[+1]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[+1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "previous_row = range(len(s2) + 1)",
      "mutated_line": "for (i, c1) in enumerate(s1):",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 2)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "previous_row = range(len(s2) + 1)",
      "mutated_line": "for (i, c1) in enumerate(s1):",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 0)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "previous_row = range(len(s2) + 1)",
      "mutated_line": "for (i, c1) in enumerate(s1):",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 0)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "previous_row = range(len(s2) + 1)",
      "mutated_line": "for (i, c1) in enumerate(s1):",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + -1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "current_row = [i + 1]",
      "mutated_line": "current_row = [i - 1]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i - 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "current_row = [i + 1]",
      "mutated_line": "current_row = [i * 1]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i * 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j + 1] - 1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] - 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j + 1] * 1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] * 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "deletions = current_row[j] + 1",
      "mutated_line": "deletions = current_row[j] - 1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] - 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "deletions = current_row[j] + 1",
      "mutated_line": "deletions = current_row[j] * 1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] * 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "substitutions = previous_row[j] + (c1 != c2)",
      "mutated_line": "substitutions = previous_row[j] - (c1 != c2)",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] - (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "substitutions = previous_row[j] + (c1 != c2)",
      "mutated_line": "substitutions = previous_row[j] * (c1 != c2)",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] * (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return previous_row[-1]",
      "mutated_line": "return previous_row[-2]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-2]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return previous_row[-1]",
      "mutated_line": "return previous_row[-0]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return previous_row[-1]",
      "mutated_line": "return previous_row[-0]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return previous_row[-1]",
      "mutated_line": "return previous_row[--1]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[--1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "current_row = [i + 1]",
      "mutated_line": "current_row = [i + 2]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 2]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "current_row = [i + 1]",
      "mutated_line": "current_row = [i + 0]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 0]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "current_row = [i + 1]",
      "mutated_line": "current_row = [i + 0]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 0]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "current_row = [i + 1]",
      "mutated_line": "current_row = [i + -1]",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + -1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j + 1] + 2",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 2\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j + 1] + 0",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 0\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j + 1] + 0",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 0\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j + 1] + -1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + -1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "deletions = current_row[j] + 1",
      "mutated_line": "deletions = current_row[j] + 2",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 2\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "deletions = current_row[j] + 1",
      "mutated_line": "deletions = current_row[j] + 0",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 0\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "deletions = current_row[j] + 1",
      "mutated_line": "deletions = current_row[j] + 0",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 0\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "deletions = current_row[j] + 1",
      "mutated_line": "deletions = current_row[j] + -1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + -1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "substitutions = previous_row[j] + (c1 != c2)",
      "mutated_line": "substitutions = previous_row[j] + (c1 == c2)",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 == c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j - 1] + 1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j - 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j * 1] + 1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j * 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j + 2] + 1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 2] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j + 0] + 1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 0] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j + 0] + 1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + 0] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "insertions = previous_row[j + 1] + 1",
      "mutated_line": "insertions = previous_row[j + -1] + 1",
      "code": "def levenshtein_distance(s1, s2):\n    \"\"\"\n    Calculate the minimum number of single-character operations (insertions, deletions, and substitutions) \n    necessary to transform one alphanumeric string into another in a case-insensitive manner.\n\n    Args:\n    s1 (str): The first alphanumeric string.\n    s2 (str): The second alphanumeric string.\n\n    Returns:\n    int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    (s1, s2) = (s1.lower(), s2.lower())\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for (i, c1) in enumerate(s1):\n        current_row = [i + 1]\n        for (j, c2) in enumerate(s2):\n            insertions = previous_row[j + -1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]"
    }
  ]
}