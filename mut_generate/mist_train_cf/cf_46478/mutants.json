{
  "task_id": "cf_46478",
  "entry_point": "operate_on_dicts",
  "mutant_count": 26,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if operation == \"merge\":",
      "mutated_line": "if operation != 'merge':",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation != 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if operation == \"merge\":",
      "mutated_line": "if operation == '':",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == '':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif operation == \"common_keys\":",
      "mutated_line": "elif operation != 'common_keys':",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation != 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif operation == \"common_keys\":",
      "mutated_line": "elif operation == '':",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == '':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "common_keys = dict1.keys() & dict2.keys()",
      "mutated_line": "common_keys = dict1.keys() | dict2.keys()",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() | dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif operation == \"unique_keys\":",
      "mutated_line": "elif operation != 'unique_keys':",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation != 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif operation == \"unique_keys\":",
      "mutated_line": "elif operation == '':",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == '':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "unique_keys = (dict1.keys() - dict2.keys()) | (dict2.keys() - dict1.keys())",
      "mutated_line": "unique_keys = dict1.keys() - dict2.keys() & dict2.keys() - dict1.keys()",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() & dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "unique_keys = (dict1.keys() - dict2.keys()) | (dict2.keys() - dict1.keys())",
      "mutated_line": "unique_keys = dict1.keys() - dict2.keys() ^ dict2.keys() - dict1.keys()",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() ^ dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if len(unique_keys) == 0:",
      "mutated_line": "return 'Both dictionaries are identical, no unique keys found.'",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) != 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif operation == \"sort_by_value\":",
      "mutated_line": "elif operation != 'sort_by_value':",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation != 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "unique_keys = (dict1.keys() - dict2.keys()) | (dict2.keys() - dict1.keys())",
      "mutated_line": "unique_keys = dict1.keys() + dict2.keys() | dict2.keys() - dict1.keys()",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() + dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "unique_keys = (dict1.keys() - dict2.keys()) | (dict2.keys() - dict1.keys())",
      "mutated_line": "unique_keys = dict1.keys() * dict2.keys() | dict2.keys() - dict1.keys()",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() * dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "unique_keys = (dict1.keys() - dict2.keys()) | (dict2.keys() - dict1.keys())",
      "mutated_line": "unique_keys = dict1.keys() - dict2.keys() | dict2.keys() + dict1.keys()",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() + dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "unique_keys = (dict1.keys() - dict2.keys()) | (dict2.keys() - dict1.keys())",
      "mutated_line": "unique_keys = dict1.keys() - dict2.keys() | dict2.keys() * dict1.keys()",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() * dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(unique_keys) == 0:",
      "mutated_line": "return 'Both dictionaries are identical, no unique keys found.'",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 1:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(unique_keys) == 0:",
      "mutated_line": "return 'Both dictionaries are identical, no unique keys found.'",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == -1:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(unique_keys) == 0:",
      "mutated_line": "return 'Both dictionaries are identical, no unique keys found.'",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 1:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return \"Both dictionaries are identical, no unique keys found.\"",
      "mutated_line": "return ''",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return ''\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif operation == \"sort_by_value\":",
      "mutated_line": "elif operation == '':",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == '':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return \"Invalid operation.\"",
      "mutated_line": "return ''",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[1]))\n            else:\n                return ''\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result = dict(sorted(result.items(), key=lambda item: item[1]))",
      "mutated_line": "result = dict(sorted(result.items(), key=lambda item: item[2]))",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[2]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result = dict(sorted(result.items(), key=lambda item: item[1]))",
      "mutated_line": "result = dict(sorted(result.items(), key=lambda item: item[0]))",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[0]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result = dict(sorted(result.items(), key=lambda item: item[1]))",
      "mutated_line": "result = dict(sorted(result.items(), key=lambda item: item[0]))",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[0]))\n            else:\n                return 'Invalid operation.'\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result = dict(sorted(result.items(), key=lambda item: item[1]))",
      "mutated_line": "result = dict(sorted(result.items(), key=lambda item: item[-1]))",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    \"\"\"\n    Performs operations on two dictionaries based on the operations provided.\n\n    Args:\n    dict1 (dict): The first dictionary with string keys and integer values.\n    dict2 (dict): The second dictionary with string keys and integer values.\n    operations_dict (dict): A dictionary with operation names as keys and a boolean status as values.\n\n    Returns:\n    dict: The result dictionary after performing all operations.\n    \"\"\"\n    result = {}\n    for (operation, status) in sorted(operations_dict.items()):\n        if status:\n            if operation == 'merge':\n                result = {**dict1, **dict2}\n            elif operation == 'common_keys':\n                common_keys = dict1.keys() & dict2.keys()\n                result = {key: dict1[key] for key in common_keys}\n            elif operation == 'unique_keys':\n                unique_keys = dict1.keys() - dict2.keys() | dict2.keys() - dict1.keys()\n                if len(unique_keys) == 0:\n                    return 'Both dictionaries are identical, no unique keys found.'\n                result = {key: dict1.get(key, dict2.get(key)) for key in unique_keys}\n            elif operation == 'sort_by_value':\n                result = dict(sorted(result.items(), key=lambda item: item[-1]))\n            else:\n                return 'Invalid operation.'\n    return result"
    }
  ]
}