{
  "task_id": "cf_47984",
  "entry_point": "shortest_path",
  "mutant_count": 16,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if node not in seen:",
      "mutated_line": "if node in seen:",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return float(\"inf\")",
      "mutated_line": "return float('')",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "queue = [(0, start, [])]",
      "mutated_line": "queue = [(1, start, [])]",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(1, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "queue = [(0, start, [])]",
      "mutated_line": "queue = [(-1, start, [])]",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(-1, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "queue = [(0, start, [])]",
      "mutated_line": "queue = [(1, start, [])]",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(1, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "path = path + [node]",
      "mutated_line": "path = path - [node]",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path - [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "path = path + [node]",
      "mutated_line": "path = path * [node]",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path * [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if node == end:",
      "mutated_line": "if node != end:",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node != end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if neighbour not in seen:",
      "mutated_line": "if neighbour in seen:",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_cost = cost + c",
      "mutated_line": "new_cost = cost - c",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost - c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_cost = cost + c",
      "mutated_line": "new_cost = cost * c",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost * c\n                    if old_cost is None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if old_cost is None or new_cost < old_cost:",
      "mutated_line": "if old_cost is None and new_cost < old_cost:",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None and new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if old_cost is None or new_cost < old_cost:",
      "mutated_line": "if old_cost is not None or new_cost < old_cost:",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is not None or new_cost < old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if old_cost is None or new_cost < old_cost:",
      "mutated_line": "if old_cost is None or new_cost <= old_cost:",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost <= old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if old_cost is None or new_cost < old_cost:",
      "mutated_line": "if old_cost is None or new_cost >= old_cost:",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost >= old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if old_cost is None or new_cost < old_cost:",
      "mutated_line": "if old_cost is None or new_cost != old_cost:",
      "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_dist = defaultdict(int)\n    while queue:\n        (cost, node, path) = heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == end:\n                return (cost, path)\n            for (c, neighbour) in graph.get(node, []):\n                if neighbour not in seen:\n                    old_cost = min_dist.get(neighbour, None)\n                    new_cost = cost + c\n                    if old_cost is None or new_cost != old_cost:\n                        min_dist[neighbour] = new_cost\n                        heappush(queue, (new_cost, neighbour, path))\n    return float('inf')"
    }
  ]
}